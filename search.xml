<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[问题详情录]]></title>
    <url>%2Fproblem%2F120180711%2F</url>
    <content type="text"><![CDATA[本地使用uploadifive上传插件，上传视屏到七牛云时报错。本地是采用了nginx做代理的。上传图片可以成功，使用却出错。报错提示：413 Request Entity Too Large原来是nginx对上传的文件大小有限制，配置的时候加上client_max_body_size 20m;控制视频的上传大小。不一定是20M 上传文件的时候，点击弹框会延迟3s~5s。这是谷歌浏览器的问题。谷歌浏览器会验证文件类型解决办法补全限制文件类型 images/* ==》 images/png,images/jpeg 等 document.cookie保存一个值得时候一直不成功。浏览器是开启了cookie存储的原因：代码在本地，开启服务后成功存值]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>问题详情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prompt提示框]]></title>
    <url>%2Fjjs%2F1120180702%2F</url>
    <content type="text"><![CDATA[最近项目中有很多地方需要用到prompt框。之前写的时候都是需要引一个css，一个js。标签还需要写在页面上。对此开发很有意见。所以封装了下。 依据项目要求，暂只有三种状态如下： 下边详细介绍下： 代码结构是这样的 ,主要介绍下promptLayer.prototype 里面的代码： init 1234567891011121314init: function(opts) &#123; var o = this; var scriptCode = '(function() &#123;var docEle = document.documentElement, evt = "onorientationchange" in window ? "orientationchange" : "",fn = function() &#123;var width = docEle.clientWidth;width &amp;&amp; (docEle.style.fontSize = width / 7.5 + "px");&#125;;fn(); if (window.addEventListener) &#123; if (evt) &#123; window.addEventListener(evt, fn, false);&#125;window.addEventListener("resize", fn, false);document.addEventListener("DOMContentLoaded", fn, false);&#125;&#125;)();'; o.brithStructure(opts); var styleCode = 'body&#123;font-size:0.24rem&#125;' + '.prompt-bg &#123;opacity: 0;visibility: hidden;position: fixed; top: 0;right: 0;bottom: 0;left: 0;z-index: 1040;overflow-x: hidden;overflow-y: auto;display: flex;display: -webkit-box;display: -ms-flexbox;display: -webkit-flex;justify-content: center; -webkit-justify-content: center; align-items: center;-webkit-align-items: center; -moz-box-align: center; -webkit-box-align: center; -webkit-box-pack: center;background: transparent;&#125;' + '.prompt-bg.is-visible &#123; opacity: 1; visibility: visible;-webkit-transition: opacity 0.3s 0s, visibility 0s 0s;-moz-transition: opacity 0.3s 0s, visibility 0s 0s;transition: opacity 0.3s 0s, visibility 0s 0s;&#125;' + '.prompt &#123;font-size: 0.28rem;text-align: center;padding: 0.3rem 0.64rem; background-color: rgba(0, 0, 0, .6); border-radius: 5px;&#125;' + '.prompt span &#123; font-size: 0.28rem; color: #fff;&#125;'; var iconCode = '.prompt img &#123;width: 0.56rem; height: 0.56rem; margin: 0 auto 0.2rem;display:block;border:0 &#125;'; styleCode += iconCode; if (!window.returnFlag) &#123; window.returnFlag = true; o.loadJSCode(scriptCode); o.loadCssCode(styleCode); &#125; &#125;, ① scriptCode 是为了rem布局自适应。这是以375px屏为基础的。② brithStructure是下边的方法，等会会写到。③ styleCode是提示框的样式。iconCode是图标样式。这样就避免了引入样式表。④ loadJSCode，loadCssCode 这两个方法很好理解。就是将样式和js加入html里面 birthStructure 1234567891011121314151617181920212223brithStructure: function(opts) &#123; var promptHtml = ""; var curCont = (!opts.content) ? '操作成功' : opts.content; this.hideLayer(opts); switch (opts.type) &#123; case 0: //纯文字 promptHtml = '&lt;div class="prompt-bg is-visible"&gt;&lt;div class="prompt"&gt;&lt;span&gt;' + curCont + '&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;'; $(opts.obj).append(promptHtml); break; case 1: //操作成功 promptHtml = '&lt;div class="prompt-bg is-visible"&gt;&lt;div class="prompt"&gt;&lt;img src="prompt_yes.png" /&gt;&lt;span&gt;' + curCont + '&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;'; $(opts.obj).append(promptHtml); break; case 2: //操作失败 promptHtml = '&lt;div class="prompt-bg is-visible"&gt;&lt;div class="prompt"&gt;&lt;img src="prompt_no.png" /&gt;&lt;span&gt;' + curCont + '&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;'; $(opts.obj).append(promptHtml); break; default: promptHtml = '&lt;div class="prompt-bg is-visible"&gt;&lt;div class="prompt"&gt;&lt;span&gt;' + curCont + '&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;'; $(opts.obj).append(promptHtml); break; &#125; &#125;, ① 这边可以看到 0,1,2 三种情况。这个方法是将标签加入页面② hideLayer 这个也很好理解，就是隐藏提示框 hideLayer ,loadJSCode12345678910111213hideLayer: function(opts) &#123; var time = !opts.time ? '1500' : opts.time; setTimeout(function() &#123; $('.prompt-bg').removeClass('is-visible'); &#125;, time); &#125;, loadJSCode: function(code) &#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.appendChild(document.createTextNode(code)); var head = document.getElementsByTagName('head')[0]; head.appendChild(script); &#125;, ① 这个方法是隐藏提示框② loadJSCode和loadCSSCode一样，就是将代码加入到页面，此列举一个为例 showPromptLayer 此方法是呈现如何调用这个弹框 123456789function showPromptLayer(type, content, obj, time) &#123; var opts = &#123; type: type, content: content, obj: (!obj) ? obj : 'body', time: time &#125; new promptLayer(opts); &#125;; ① 此方法有四个参数。均为非必填。 showPromptLayer()默认是type:0 纯文字状态 type:1 success提示 type:2 fail提示② 参数详解 content 表示要传递的内容 ; obj 表示标签加载在页面的部位 默认Body; time 表示提示框关闭时间 默认1500 使用步骤1showPromptLayer(1, '操作成功', 'body', 5000); 详细代码： https://github.com/sulishibaobei/loadingOrPrompt/tree/master/prompt 另外，也封装过一个类似的loading加载。适用于后台系统。 https://github.com/sulishibaobei/loadingOrPrompt/tree/master/loading]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>提示框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现两端对齐]]></title>
    <url>%2Fjjs%2F1020180622%2F</url>
    <content type="text"><![CDATA[项目中很多时候都需要实现两端对齐。 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt; &lt;label&gt;应聘者：&lt;/label&gt; &lt;span&gt;那些神奇的歌声在把我召唤&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;招聘者：&lt;/label&gt; &lt;span&gt;这里有与世无争的笑颜;娇艳的花开满山间&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;主要责任人：&lt;/label&gt; &lt;span&gt;彩虹下的歌声笑语中嘹亮&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;事件：&lt;/label&gt; &lt;span&gt;拉起低下头抿嘴笑的姑娘&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;事件彩虹：&lt;/label&gt; &lt;span&gt;编一支花环为她戴在头上&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; 现在的效果是这样的： 现在我们要对label里面的文字进行两端对齐 一般我们会这样写，为此我们还做了点兼容：1234567891011 label &#123; min-width: 100px; max-width: 100px; display: inline-block; text-align: justify; text-justify: inter-ideograph; //IE text-align-last: justify; -moz-text-align-last: justify; //firefox position: relative;&#125; 这样的效果是这样的： 我们需要的是字对齐，现在由于有“：”在显然影响了我们。如果我们去掉“：”,将会是这样的 现在这样才算是真正意义上的两端对齐。我们在补上“：” 12345label:after &#123; content: "："; position: absolute; display: inline-block&#125; 我们通过伪元素来补上“：” 现在是实现两端对齐了，是不是很方便。 但是通过测试，发现firefox并不行。经原来firefox必须要有空格才行,也就是字与字之间必须有一个空格12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt; &lt;label&gt;应 聘 者&lt;/label&gt; &lt;span&gt;那些神奇的歌声在把我召唤&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;招 聘 者&lt;/label&gt; &lt;span&gt;这里有与世无争的笑颜;娇艳的花开满山间&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;主 要 责 任 人&lt;/label&gt; &lt;span&gt;彩虹下的歌声笑语中嘹亮&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;事 件&lt;/label&gt; &lt;span&gt;拉起低下头抿嘴笑的姑娘&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;事 件 彩 虹 &lt;/label&gt; &lt;span&gt;编一支花环为她戴在头上&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; IE浏览器的话，目前IE9以下测试后是不支持的。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>兼容移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地址筛选]]></title>
    <url>%2Fjjs%2F920180620%2F</url>
    <content type="text"><![CDATA[最近项目中需要一个选择地址的弹框，自己先随便写了下，数据均为模拟。 大致效果： 其实代码还是有点冗余，但是已经尽量优化过。先上主要代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112var filter = &#123; init: function() &#123; //初次进入获取数据 这时候加载的是省份 $.ajax(&#123; url: "mask.json", type: "get", success: function(data) &#123; getCityCode(data); $.each(data, function(i, val) &#123; if (val.item_code.substr(2, 4) == '0000') &#123; //这边是筛选值，如果是请求的话，就按照自己的来 $("#addrList").append("&lt;li value='" + val.item_code + "' level=1" + "&gt;" + val.item_name + "&lt;/li&gt;"); &#125; &#125;) &#125; &#125;); &#125;, bindEvent: function() &#123; $("body").on('click', '.adddress', function() &#123; //点击选择地区 filter.init(); $("#addrSelDiv").show(); &#125;); $("body").on('click', '.mod_address_slide_list_2 li', function(e) &#123; //点击列表数据 e.preventDefault(); var that = $(this); //点击第一级菜单时 1.显示选中 2.存值 3.查询有没有下一级(根据val 根据name) 4.(先清空数据)存在数据更新列表 5.值回显（有下一级显示在上面，无下一级关闭弹框，获取全部值） that.addClass('on').siblings().removeClass('on'); //1.将自身值设置为选中 var level2 = that.attr('level'); //当前列表显示的值是第几级 var targetLi = $(".mod_address_slide_tabs_1").find('li[level=' + level2 + ']'); //当再次回来点击清空后面的值，变成请选择 if (targetLi &amp;&amp; targetLi.length &gt; 0) &#123; targetLi.nextAll().remove(); var clone = targetLi.clone(); $(".mod_address_slide_tabs_1").append(clone); $(".mod_address_slide_tabs_1").find('li:last-child').addClass('cur').siblings().removeClass('cur').end().removeAttr('level').find('span').html('请选择'); &#125; if (level2 == "1") &#123; //不管有没有值都进行这一步 列表==市 setCookie('province', that.parent().html()); //2.存值 $("#addrList").html(""); filter.updateLevel(that); //5 $.each(cityCode, function(i, val) &#123; if (val.item_code.substr(4, 2) == '00' &amp;&amp; val.item_code.substr(0, 2) == that.val().toString().substr(0, 2) &amp;&amp; val.item_code.substr(2, 4) != '0000') &#123; if (val) &#123; $("#addrList").append("&lt;li value='" + val.item_code + "' level=2" + "&gt;" + val.item_name + "&lt;/li&gt;"); //4 &#125; else &#123; filter.setValue(); &#125; &#125; &#125;); &#125; else if (level2 == "2") &#123; // 列表==区 setCookie('city', that.parent().html()); //2.存值 $("#addrList").html(""); filter.updateLevel(that); //5 $.each(cityCode, function(i, val) &#123; if (val.item_code.substr(0, 4) == that.val().toString().substr(0, 4) &amp;&amp; val.item_code.substr(4, 2) != '00') &#123; if (val) &#123; $("#addrList").append("&lt;li value='" + val.item_code + "' level=3" + "&gt;" + val.item_name + "&lt;/li&gt;"); //4 &#125; else &#123; filter.setValue(); &#125; &#125; &#125;) &#125; else if (level2 == "3") &#123; //清空列表 setCookie('place', that.parent().html()); //2.存值 filter.updateLevel(that); //5 filter.setValue(); &#125; else &#123; return; &#125; &#125;); $("body").on('click', '.mod_address_slide_tabs_1 li:not(:last-child)', function() &#123; //点击第一个tab切换 var index = $(this).index(); if ($(this).parents('.mod_address_slide_tabs_1').find('li').length == 1) &#123; return false; &#125; $(this).addClass('cur').siblings().removeClass('cur'); if (index == '0') &#123; $("#addrList").html(getCookie('province')); &#125; else if (index == "1") &#123; $("#addrList").html(getCookie('city')); &#125; &#125;); $("body").on('click', '.showAddr', function() &#123; //显示值在页面 if ($(this).html() == "") &#123; $(".adddress").click(); &#125; else &#123; $(".adddress").click(); $(".mod_address_slide_tabs_1").find('li:last-child').prev().addClass('cur').siblings().removeClass('cur'); $(".mod_address_slide_tabs_1").find('li:last-child').hide(); &#125; &#125;) $("body").on("click", '.close', function() &#123; //点击关闭按钮 if ($(".showAddr").html() == "") &#123; delCookie('province'); delCookie('city'); delCookie('place'); $(".mod_address_slide_tabs_1").find('li:not(:last-child)').remove(); $(".mod_address_slide_tabs_1").find('li').removeAttr('level').removeClass('cur'); $(".mod_address_slide_list_2").html(""); &#125; $("#addrSelDiv").hide(); &#125;) &#125;, updateLevel: function(val) &#123; // 更新第一个tab上面的level编号 var obj = $(".mod_address_slide_tabs_1").find('li[level=' + $(val).attr('level') + ']'); //不在重复显示添加相同的Li 如果存在 if (obj &amp;&amp; obj.length &gt; 0) &#123; obj.find('span').html($(val).html()); &#125; else &#123; var clonehtml = $(".mod_address_slide_tabs_1").find('li:last-child').clone(); //请选择部分 clonehtml = $(clonehtml).attr('level', $(val).attr('level')).find('span').html($(val).html()).end(); $(".mod_address_slide_tabs_1").find('li:last-child').before(clonehtml); &#125; $(".mod_address_slide_tabs_1").find('li:last-child').addClass('cur').siblings().removeClass('cur'); &#125;, 这是只要的核心代码。这个有几个核心点： 头脑逻辑要清晰，一不小心就会出错； 采用的cookie，所以要开启服务前提下。数据其实只请求一次，后面都是重cookie中取 要给每一级li都有一个对应的标识符便于区分 遇见多个的情况就可以封装下。这是我在项目组使用的情况 详细的代码请看 https://github.com/sulishibaobei/area-linkage]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>选择地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯前端控制的数字验证]]></title>
    <url>%2Fjjs%2F820180611%2F</url>
    <content type="text"><![CDATA[今日要实现一个纯字母和数字的前端验证。很多时候我们看到的验证都是后端传图片过来前端验证的。但是有些安全性要求不是很高的页面往往就不需要后端支持。 只显示核心代码：1234&lt;input class="form-input" type="text" placeholder="请输入图片验证码" id="authCode" /&gt;&lt;span class="form-valid"&gt; &lt;a id="code" href="#" onclick="filter.createCode()" title="点击更换验证码" &gt;&lt;/a&gt;&lt;/span&gt; 1234567#code &#123; padding: 0.1rem 0.2rem; background: -webkit-linear-gradient(rgb(221, 221, 221), rgb(8, 167, 80)); font-size: 0.28rem; color: #ffffff; cursor: pointer;&#125; 123456789101112131415161718192021222324252627282930313233343536373839var code; //在全局定义验证码 var filter = &#123; createCode: function() &#123; //生成二维码 code = ""; var codeLength = 4; //验证码的长度 var random = new Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'); //随机数 for (var i = 0; i &lt; codeLength; i++) &#123; //循环操作 var index = Math.floor(Math.random() * 36); //取得随机数的索引（0~35） code += random[index]; //根据索引取得随机数加到code上 &#125; $("#code").html(code); //把code值赋给验证码 $("#code").attr('style', 'background:-webkit-linear-gradient(' + filter.randomColor() + ',' + filter.randomColor()); &#125;, randomColor: function() &#123; //更换背景色 var codeColor = ""; var random = new Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F'); //颜色范围编码 for (var i = 0; i &lt; 6; i++) &#123; //循环操作 var index = Math.floor(Math.random() * 16); //取得随机数的索引（0~35） codeColor += random[index]; //根据索引取得随机数加到code上 &#125; return "#" + codeColor; &#125;, validate: function() &#123; //校验二维码 var inputCode = $("#authCode").val().toUpperCase(); //取得输入的验证码并转化为大写 (因为上边没有出现小写情况) if (inputCode.length &lt;= 0) &#123; //若输入的验证码长度为0 showDialogOrPromptSuccessMsg(yprompt, "请输入验证码！", 1500); //则弹出请输入验证码 ( showDialogOrPromptSuccessMsg 请忽略，只是一个自定义弹框。用alert一样的) &#125; else if (inputCode != code) &#123; //若输入的验证码与产生的验证码不一致时 showDialogOrPromptSuccessMsg(yprompt, "验证码输入错误！@_@", 1500); //则弹出验证码输入错误 filter.createCode(); //刷新验证码 $("#authCode").val(""); //清空文本框 &#125; else &#123; //输入正确时 showDialogOrPromptSuccessMsg(yprompt, "合格！^-^", 1500); &#125; &#125;&#125;$(function() &#123; filter.createCode();&#125;) 注释上都写的很清楚了： 一个生成验证码的方法，验证码长度自己定义。这边用的全部是大写，还可以加入小写，小写的话验证那边也要稍微改下。 生成背景色的方法，这边采用的的是渐变色。按照功能点讲，这个方法可以不需要。只是为了追求色彩丰富点。 验证二维码的方法。这个也比较简单。就是和值进行比较。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>数字验证码</tag>
        <tag>四位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现纯三角]]></title>
    <url>%2Fjjs%2F720180426%2F</url>
    <content type="text"><![CDATA[使用css实现一个三角形具体的效果是这样的：虽然是一个小的功能，但是项目开发中还是经常用到。用图片觉得太累赘，用css实现更好。 123&lt;div class="triangle_border_up"&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; 注意：一般用一个div里面包裹一个标签实现。外层标签提供边框。内层div提供背景色 123456789101112131415161718192021.triangle_border_up &#123; width: 0; height: 0; border-width: 0 7px 7px; border-style: solid; border-color: transparent transparent #ddd; margin: -7px 10px; position: relative; &#125; .triangle_border_up span &#123; display: block; width: 0; height: 0; border-width: 0 6px 6px; border-style: solid; border-color: transparent transparent #fafafa; position: absolute; top: 1px; left: -6px; &#125; 位置，大小，三角朝向都可以自己调整。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>三角形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端实现下拉加载]]></title>
    <url>%2Fjjs%2F520180420%2F</url>
    <content type="text"><![CDATA[使用dropload.min.js实现上下拉刷新加载页面 代码全部只有主要代码1234567891011121314151617181920212223&lt;input type="hidden" id="pageSize" value="10" /&gt;&lt;input type="hidden" id="pageNum" value="1" /&gt;&lt;input type="hidden" id="totalPages" value="100" /&gt;&lt;section class="clear wrapper-box" id="wrapper"&gt; &lt;div class="scroll-box"&gt; &lt;ul class="photograph-list"&gt; &lt;li&gt; &lt;div class="display-box"&gt; &lt;div class="box-nine pho-info"&gt; &lt;p style="padding-bottom:0.15rem"&gt;&lt;strong&gt;测试数据&lt;/strong&gt;&lt;span class="status"&gt;待确认&lt;/span&gt;&lt;/p&gt; &lt;p style="padding-bottom:0.1rem"&gt;&lt;span&gt;测试时间：&lt;/span&gt;&lt;span&gt;9月18日 13:00-13:30&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;测试人：&lt;/span&gt;&lt;span&gt;周杰伦（歌手）&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="box-one pho-call"&gt; &lt;img src="images/call@2x.png" class="call"&gt; &lt;p class="callPhone"&gt;打电话&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;!--可以复制n个li标签试试--&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt; css代码就不贴出来。就是平常的css样式。提一点dropload的css123456789101112131415161718192021222324252627282930313233343536.dropload-up,.dropload-down &#123; position: relative; height: 0; overflow: hidden; font-size: 0.24rem; /* 开启硬件加速 */ -webkit-transform: translateZ(0); transform: translateZ(0);&#125;.dropload-down &#123; height: 0.88rem;&#125;.dropload-refresh,.dropload-update,.dropload-load,.dropload-noData &#123; height: 0.88rem; line-height: 0.88rem; text-align: center;&#125;.dropload-load .loading &#123; display: inline-block; height: 0.3rem; width: 0.3rem; border-radius: 100%; margin: 0.12rem; border: 0.04rem solid #666; border-bottom-color: transparent; vertical-align: middle; -webkit-animation: rotate 0.75s linear infinite; animation: rotate 0.75s linear infinite;&#125; 重点是js代码。记得引入jquery和dropload.min.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061droploadData(); // 下拉刷新 function droploadData() &#123; var pageNum = parseInt($("#pageNum").val()), totalPages = parseInt($("#totalPages").val()); var dropload = $('#wrapper').dropload(&#123; scrollArea: window, //绑定元素自身 distance: 100, threshold: 200, domDown: &#123; //往下拉 domClass: 'dropload-down', domRefresh: '&lt;div class="dropload-refresh"&gt;↑上拉加载更多&lt;/div&gt;', domLoad: '&lt;div class="dropload-load"&gt;&lt;span class="loading"&gt;&lt;/span&gt;加载中...&lt;/div&gt;', domNoData: '&lt;div class="dropload-noData"&gt;已经全部加载完毕&lt;/div&gt;' &#125;, domUp: &#123; //往上拉 domClass: 'dropload-up', domRefresh: '&lt;div class = "dropload-refresh"&gt; ↓下拉刷新 &lt;/div&gt;', domUpdate: '&lt;div class = "dropload-update"&gt; ↑释放更新 &lt;/div&gt;', domLoad: '&lt;div class = "dropload-load"&gt; &lt;span class="loading"&gt;&lt;/span&gt;加载中… &lt;/div&gt;' &#125;, loadDownFn: function(me) &#123; //往下拉的方法 pageNum++; if (pageNum &lt;= totalPages) &#123; loadData(pageNum, function(data) &#123; $("#wrapper").find("ul").append(data); me.resetload(); // 每次数据加载完，必须重置 &#125;) &#125; else &#123; me.lock(); //锁定dropload me.noData(); me.resetload(); // 每次数据加载完，必须重置 &#125; &#125;, loadUpFn: function(me) &#123; //往下拉的方法 pageNum++; if (pageNum &lt;= totalPages) &#123; loadData(pageNum, function(data) &#123; $("#wrapper").find("ul").prepend(data); me.resetload(); // 每次数据加载完，必须重置 &#125;) &#125; else &#123; me.lock(); me.noData(); me.resetload(); // 每次数据加载完，必须重置 &#125; &#125; &#125;); &#125; function loadData(pageNum, callback) &#123; //模拟数据 setTimeout(function() &#123; var data = []; for (var i = pageNum; i &lt; 10; i++) &#123; data.push('&lt;li&gt;&lt;div class="display-box"&gt;&lt;div class="box-nine pho-info"&gt;&lt;p style="padding-bottom:0.15rem"&gt;&lt;strong&gt;kkOne&lt;/strong&gt;&lt;span class="status"&gt;待确认&lt;/span&gt;&lt;/p&gt;&lt;p style="padding-bottom:0.1rem"&gt;&lt;span&gt;相约时间：&lt;/span&gt;&lt;span&gt;9月18日 13:00-13:30&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;逛街人：&lt;/span&gt;&lt;span&gt;mary（俱乐部）&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class="box-one pho-call"&gt;&lt;img src="images/call@2x.png" class="call"&gt;&lt;p class="callPhone"&gt;打电话&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;'); &#125; callback(data); &#125;, 1000); &#125; 注意一点的是，下拉和上拉有时候并不是同时存在的。根据自己的方式选中上拉还是下拉。每一次加入数据都需要调用resetload（）；me.noData(); 和 me.noData(true); 表示当前无数据，也就是会在下方出现 （暂无数据）的表示 me.noData(false);则表示有数据，这时不会显示（暂无数据）。如果使用了me.unlock() ，则需要调用me.noData(false)才能继续功能最近试用了淘宝的sui moblie框架，里面也有下拉刷新，无限滚动功能。感觉也不错。只是现在框架不维护可惜了。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>下拉加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript TypeOf 深究]]></title>
    <url>%2Fjjs%2F620180420%2F</url>
    <content type="text"><![CDATA[typeOf可能返回的类型 number ,string, object, boolean,function ,undefined 1.number类型很容易判断typeof 3.14 === ‘number’ //truetypeof Infinity === ‘number’; //truetypeof NaN === ‘number’; //true 2.string类型typeof typeof 3.14 === ‘string’ //true 因为所有的typeof返回的类型都是string类型的。typeof “” === “string” //true 3.objecttypeof null === ‘object’ //truetypeof [1,2] === ‘object’ //true Array,Null等特殊对象使用typeof一律返回object 4.booleantypeof true === ‘boolean’; 5.undefindtypeof a === ‘undefined’ //true因为没有事先被声明var a=undefined; typeof a === ‘undefined’ 6.functiontypeof Date === ‘function’ //truetypeof function a(){} //‘function’ 加深理解的话，可以看下面这个。https://www.cnblogs.com/xcr1234/p/5527816.html#commentform]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>typeOf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[城市搜索]]></title>
    <url>%2Fjjs%2F420180416%2F</url>
    <content type="text"><![CDATA[项目中最近需要实现一个城市搜索导航的。效果大体如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;header class="head-fixed" style="background: #FFFFFF;"&gt; &lt;div class="city-search-wrap"&gt; &lt;div id="city-search"&gt; &lt;i class="sprite-search icon-search"&gt;&lt;/i&gt; &lt;input type="text" class="ser-txt" placeholder="请输入城市名" id="searchContext" maxlength="50"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;section class="choose-city-wrap"&gt; &lt;div class="box"&gt; &lt;div class="city-list-title"&gt;当前城市&lt;/div&gt; &lt;div class="city-list clear"&gt; &lt;span class="nowCity chooseCity" style="display: none"&gt;深圳&lt;/span&gt; &lt;span class="nowCity"&gt;定位失败&lt;img src="images/circle@2x.png" class='seekFailed' /&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;div class="city-list-title" id="A"&gt;A&lt;/div&gt; &lt;div class="city-list clear"&gt; &lt;span class="nowCity" data-name="北京"&gt;北京&lt;i&gt;&lt;/i&gt;&lt;/span&gt; &lt;span class="nowCity" data-name="深圳"&gt;深圳&lt;i&gt;&lt;/i&gt;&lt;/span&gt; &lt;span class="nowCity" data-name="沈阳"&gt;沈阳&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="choose-city-chart"&gt; &lt;a href="javascript:void(0);"&gt;#&lt;/a&gt; &lt;a href="javascript:void(0);" data-key="A"&gt;A&lt;/a&gt; &lt;a href="javascript:void(0);" data-key="B"&gt;B&lt;/a&gt; &lt;a href="javascript:void(0);" data-key="C"&gt;C&lt;/a&gt; &lt;a href="javascript:void(0);" data-key="D"&gt;D&lt;/a&gt; &lt;a href="javascript:void(0);" data-key="F"&gt;F&lt;/a&gt; &lt;a href="javascript:void(0);" data-key="G"&gt;G&lt;/a&gt; &lt;a href="javascript:void(0);" data-key="H"&gt;H&lt;/a&gt; &lt;a href="javascript:void(0);" data-key="J"&gt;J&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;div class="city-search-list"&gt; &lt;div class="mask"&gt;&lt;/div&gt; &lt;div class="search-list"&gt; &lt;a name="city" data-code="null" data-name="惠州"&gt;惠州&lt;/a&gt; &lt;a name="city" data-code="null" data-name="深圳"&gt;深圳&lt;/a&gt; &lt;a name="city" data-code="null" data-name="广州"&gt;广州&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 这边主要列出主要的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** 一般来说，录数据库的会输入助力码 例如 惠州 hz*/ var city=[]; $("#searchContext").on("focus", function() &#123; $(".city-search-list").show(); $(".city-search-list .mask").show(); $("body").css('overflow', 'hidden'); $(".city-search-list .search-list").hide(); &#125;).on("input propertychange", function() &#123; var val = $.trim($(this).val()); if (val == "") &#123; $(".city-search-list .mask").show(); $("body").css('overflow', 'hidden'); $(".city-search-list .search-list").hide(); return; &#125; //1.如果输入的是拼音 匹配首字母 2.输入的字，匹配所有含有字的 val = val.toUpperCase(); $("#searchList").html(""); if (val.length == 1) &#123; var id = $(".city-list-title[id=" + val + "]"); if (id.length == 0) &#123; $("#searchList").html('&lt;span style="font-size:0.28rem;margin-top:10px;display:block"&gt;暂无匹配结果&lt;/span&gt;'); &#125; else if (id.length == 1) &#123; city=[]; var obj=id.next().find('span'); for(var i=0;i&lt;obj.length;i++)&#123; $("#searchList").append(' &lt;a name="city" data-code="null" data-name='+obj.eq(i).attr('data-name')+'&gt;'+obj.eq(i).attr('data-name')+'&lt;/a&gt;'); city.push(obj.eq(i).attr('data-name')); &#125; &#125; &#125;else if(val.length&gt;=2)&#123; for(var i=0;i&lt;city.length;i++)&#123; if(getPinYinFirstCharacter(city[i],"",true).indexOf(val)&gt;-1)&#123; $("#searchList").append(' &lt;a name="city" data-code="null" data-name='+city[i]+'&gt;'+city[i]+'&lt;/a&gt;'); &#125; &#125; &#125;else&#123; $("#searchList").html('&lt;span style="font-size:0.28rem;margin-top:10px;display:block"&gt;暂无匹配结果&lt;/span&gt;'); &#125; $(".city-search-list .search-list").show(); &#125;) $("#searchList").on('click','a',function()&#123; $(".chooseCity").html($(this).html()); $(".city-search-list .search-list").hide(); $(".city-search-list .mask").hide(); $("body").css('overflow', 'unset'); &#125;) // 字母定位 $(".choose-city-chart").on("click", "a", function() &#123; var key = $(this).data("key"); $("body,html").animate(&#123; "scrollTop": $("#" + key).offset().top - $(".head-fixed").outerHeight() - 10 &#125;, 100); &#125;); $("body").on("click", "span.nowCity", function() &#123; var val = $(this).data('name'); $(".chooseCity").show().html(val).css('color', 'red'); $(".chooseCity").next().hide(); $("body,html").animate(&#123; "scrollTop": $(".chooseCity").offset().top - $(".head-fixed").outerHeight() - 10 &#125;, 100); &#125;) 功能还是比较简单的。主要是样式写的漂亮一点就可以了。 新增功能点给右边的导航栏新增了一个滚轮滑动到响应位置对应A标签变颜色。 123456789101112131415161718192021222324252627282930&lt;!--这是新增代码--&gt; $(window).scroll(function() &#123; var scrollTop = $(document).scrollTop(); var oItem = $(".choose-city-wrap").find('.box'); var oName = ''; $.each(oItem, function(i) &#123; var oneItem = $(this); if (i == 0) &#123; //剔除掉当前城市 return; &#125; var offsetTop = oneItem.offset().top; if (offsetTop - scrollTop &lt; oneItem.prev().height()) &#123; //当上一个彻底看不见时再跳到下一个 oName = oneItem.find('.city-list-title').attr("id"); $(".choose-city-chart a.curr").removeClass("curr"); $(".choose-city-chart").find("[data-key=" + oName + "]").addClass("curr"); &#125; &#125;) &#125;)&lt;!--前代码修改--&gt; // 字母定位 $(".choose-city-chart").on("click", "a", function() &#123; var key = $(this).data("key"); $("body,html").animate(&#123; "scrollTop": $("#" + key).offset().top - $(".head-fixed").outerHeight() - 10 &#125;, 100); $(this).addClass('curr').siblings('a').removeClass('curr'); //这时候记得写一个curr的样式。eg:color:#e03236; if ($(document).height() == $('body').height() + $(window).scrollTop()) &#123; //判断滚动条是不是到底了，到底之后需要自己加上样式。因为为true时，不会触发scroll事件，所以需要手动加上 $(this).addClass('curr').siblings('a').removeClass('curr'); &#125; &#125;); 详细的代码请看 https://github.com/sulishibaobei/searchCity.git]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>城市搜索导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css控制显示多少行]]></title>
    <url>%2Fjjs%2F320180414%2F</url>
    <content type="text"><![CDATA[最近遇见一个需求。默认收起只显示两行。展开显示全部 以往我们都知道只显示一行，剩下…表示 1234567891011121314151617&lt;div&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;span&gt;华强北&lt;/span&gt; &lt;/div&gt; 1234567div &#123; width: 200px; &#125; span &#123; display: inline-block; &#125; 效果是这样的 一般我们默认显示一行是这样的。1234567891011div &#123; width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; word-break: break-all; &#125; span &#123; display: inline-block; &#125; 效果是这样的默认显示一行我们都知道。但是默认两行呢？ 12345678910111213div &#123; width: 200px; overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; text-overflow: ellipsis; word-break: break-all; &#125; span &#123; display: inline-block; &#125; 效果是这样的 注意 -webkit-box-orient 和 -webkit-line-clamp 一定要搭配 display: -webkit-box;使用才可以。当然如果遇见这种效果 不需要结尾显示…的要怎么弄呢？这时候就需要换一种方式 12345678910div &#123; width: 200px; overflow: hidden; word-break: break-all; max-height: 40px; &#125; span &#123; display: inline-block; &#125; 通过设置最大高度来表示显示几行数据。高度就是每一行的行高之和。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>高度控制</tag>
        <tag>overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿商城关闭动画效果]]></title>
    <url>%2Fjjs%2F220180412%2F</url>
    <content type="text"><![CDATA[最近项目中用到了许多动画消费，比如loading等。觉得自己用css动画可能比gif要好一点。gif图不清晰的话就会看到有锯齿 简单的来一个仿商城关闭效果123456789&lt;div class="closed-signboard"&gt; &lt;div class="sign"&gt; CLOSED &lt;/div&gt; &lt;div class="strings"&gt;&lt;/div&gt; &lt;div class="circle circle1"&gt;&lt;/div&gt; &lt;div class="circle circle2"&gt;&lt;/div&gt; &lt;div class="circle circle3"&gt;&lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596* &#123; padding: 0; margin: 0;&#125;.closed-signboard &#123; width: 400px; height: 300px; margin: 75px auto; position: relative; transform: scale(1) rotatez(7deg) translate(-17px, 1px); animation: 1s init, 0.7s aa 1s, 3s ab 1.7s infinite; /*infinite 动画执行次数 永远*/&#125;@keyframes init &#123; /*初步加载时有缩放效果*/ from &#123; transform: scale(0); /*缩放旋转*/ &#125; to &#123; transform: scale(1); &#125;&#125;@keyframes aa &#123; 0% &#123; transform: scale(1); &#125; 100% &#123; transform: scale(1) rotateZ(7deg) translate(-17px, 1px); /*retatez向上角度*/ &#125;&#125;@keyframes ab &#123; 0% &#123; transform: rotatez(7deg) translate(-17px, 1px); &#125; 50% &#123; transform: rotatez(-7deg) translate(17px, 1px); &#125; 100% &#123; transform: rotatez(7deg) translate(-17px, 1px); &#125;&#125;.sign &#123; color: white; font-family: "Microsoft YaHei"; font-size: 80px; font-weight: bold; text-align: center; background: #e00909; width: 100%; height: 200px; line-height: 200px; position: absolute; bottom: 0; border-radius: 15px / 20px; text-shadow: 0 2px #700a03;&#125;.strings &#123; width: 150px; height: 150px; border: solid 5px #ad5700; border-bottom: none; border-right: none; position: absolute; top: 38px; left: 122px; transform: rotatez(45deg);&#125;.circle &#123; width: 25px; height: 25px; position: absolute; border-radius: 25px;&#125;.circle.circle1 &#123; background: #9f9f9f; top: 0; left: 187px;&#125;.circle.circle2, .circle.circle3 &#123; background: #9c0a00;&#125;.circle.circle2 &#123; top: 110px; left: 80px;&#125;.circle.circle3 &#123; top: 110px; right: 80px;&#125; 三个点用三个div代表 。两条木棍也是用一个div表示的。给外面最大的一个div增加一个动画。这样看起来就好像全部都在动 看看效果]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端打造0.5px的线]]></title>
    <url>%2Fjjs%2F120180411%2F</url>
    <content type="text"><![CDATA[一：前言：最近慢慢的接触移动端的项目了。作为一个伪前端。算是比较老的 怎么实现0.5px的线呢？PC端都是直接1px。不会出现0.5px的情况。这时候一般使用伪元素来显示 顶部是0.5px的线是怎么实现的呢？123456&lt;ul&gt; &lt;li&gt;测试一下测试一下&lt;/li&gt; &lt;li&gt;测试一下测试一下&lt;/li&gt; &lt;li&gt;测试一下测试一下&lt;/li&gt; &lt;li&gt;测试一下测试一下&lt;/li&gt; &lt;/ul&gt; 123456789101112131415161718192021li &#123; height: 28px; line-height: 28px; text-align: center; padding: 5px; position: relative; &#125; li:after &#123; content: " "; width: 200%; height: 1px; background: #ddd; display: block; transform: scale(0.5); -webkot-transform: scaleY(0.5); position: absolute; left: 0; transform-origin: left; -webkit-transform-origin: left; &#125; 看看效果 伪元素一定要使用占位符才会生效的。按照这种写法，管你要前后左右的0.5px的线都可以实现 0.5px的边框线如何实现html代码还是和上面一样的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!--第一种--&gt; li &#123; height: 28px; line-height: 28px; text-align: center; padding: 5px; position: relative; &#125; li:after &#123; content: " "; width: 200%; height: 200%; display: block; transform: scale(0.5); -webkot-transform: scaleY(0.5); position: absolute; left: 0; top: 0; transform-origin: 0 0; -webkit-transform-origin: 0 0; border: 1px solid #3188e8; border-radius: 22px; box-sizing: border-box; &#125; &lt;!--第二种--&gt; .first &#123; position: relative; font-size: 16px; &#125; .first .first-div:after &#123; content: ""; position: absolute; top: -50%; bottom: -50%; left: -50%; right: -50%; width: 200%; height: 200%; -webkit-transform: scale(0.5); transform: scale(0.5); border: solid 1px #3188e8; border-radius: 22px; box-sizing: border-box; &#125; 用了两种写法，但是效果都是一样的。个人比较喜欢第一种看看效果 如果有其他好的方法后续会分享的。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>0.5px</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试中常见的那些HTML/CSS题]]></title>
    <url>%2Fcss%2Fcss-120170926%2F</url>
    <content type="text"><![CDATA[什么是盒子模型？一般面试都会问：盒子模型你是怎么理解的？盒子模型分为两种：W3C(标准的)盒子模型和IE(怪异)盒子模型有图可知，标准的盒子模型包含margin,border,padding,content，并别content部分不包含其他部分；例如一个盒子模型如下：margin:20px;border:10px;padding:10px;width:200px;height:100px;如果用w3c计算盒子模型占用为：宽度为：20x2+10x2+10x2+200=280px;高度为：20x2+10x2+10x2+100=180px;盒子的实际宽度为：10x2+10x2+200=240px; 因为实际的宽度margin是不计算在内；在IE6以上统一盒子的实际高度为：10x2+10x2+100=140px;所以：标准盒子模型下，元素的宽度等于content的宽度；盒子模型占据的位置计算方式是2margin+2border+2padding+width/height;盒子的实际大小：2xborder+2xpadding+width/height有图可知IE盒子模型包含padding，margin，border，content四部分，但是ie盒子模型的content已经计算border和padding在内。还是上面那一题，如果采用IE盒子模型方式计算，盒子需占据的位置宽度为：202+200=240px; 高度为：20*2+100=140px;盒子的实际大小为：宽 200px; 高100px；所以:IE盒子模型下，元素的宽度实际上包含了content+padding+border在内，所以计算的时候实际不需要再加上padding,border;w3c可能也认识到这种差异性，所以允许我们事先定义盒子模型的解析方式；box-sizing:content-box(default) | border-box | inheritcontent-box:让元素维持W3C的标准模型；border-box：让元素维持IE传统盒子模型;接下来通过代码来看一看差别：来一段基本的代码： 12&lt;div id="div1"&gt;content-box&lt;/div&gt;&lt;div id="div2"&gt;border-box&lt;/div&gt; 123456789101112*&#123; margin:0; padding:0;&#125;div&#123; width: 200px; height: 100px; background: red; margin: 20px; padding: 20px; border: 10px solid black;&#125; 这一段简单的代码，来看看效果：这时候，两个div显示的效果是一样的，默认都是采用content-box方式解析的；接下来改变代码看一看：123#div2&#123; box-sizing: border-box;&#125; 先来看看效果图：从肉眼直观来看，第二个盒子显然比第一个盒子小了许多，但是我们要用网页设计的观点来解释这个问题的话就可以看下面两张图：这是第一个div的图；这是第二个div的图；这就是为什么我们上面的题算出来的结果是那样的；IE下认为一个盒子的宽度应该是包含content,padding和border在内的；所以第二张图的时候，padding和border都侵蚀了元素的内容部分；最后总结一点： w3c中的盒子模型占用的大小：margin + border + padding + width/height;width: margin2 + border2 + padding2 + width;height: margin2 + border2 + padding2 + height;w3c中盒子模型的实际大小：border + padding + width/height;width: border2 + padding2 + width;height: border2 + padding2 + height;w3c中盒子模型的内容区域的大小：width/heightwidth: width;height: height; IE 盒子模型占用的宽度：margin + content-width/height;width: margin2 + width;height: margin2 + height;IE 盒子模型的实际大小：content-width/heightwidth: width;height: height; 另外还有一点：css3的伸缩盒模型指的是FlexBox,想了解的戳链接 为什么样式定义开头要定义* {margin:0;padding:0;}是用来清除所有元素的默认内外边距；举一个例子：1&lt;div id="div1"&gt;&lt;/div&gt; 12345div&#123; width: 100px; height: 200px; background: red; &#125; 这时候我们可以看看效果：这时候，我们并没有给div设置margin和padding,但是确有一个边距存在，这就是浏览器给我们的默认边距；当我们设置这样一句：1234*&#123; margin: 0; padding: 0; &#125; 看到效果了吧，也就是设置这样一句的作用;例外平常还有两中比较常见的设置方法，可能有些人会这样设置：1234html&#123; margin:0; padding:0;&#125; 这种方式是没用的，并不能清除脏边距；还有一种123body&#123; margin:0;&#125; 这种方式是有效地，不同的浏览器，不同的兼容性，从代码通用性来说，设置*号是最好的方式； 行内元素有哪些？块级元素有哪些？空元素有哪些？行内元素：a,b,span,img,input ,select,label,button,textarea;块级元素：div ,ul,li ,dl,dd,dt,p,h1-h6,hr,table,p;空元素(没有内容的HTML元素,自动闭合的) : br,meta,hr,link,input,img; 块级元素和行内元素的转换：块级元素默认display:block，行内非替换元素（a,span）默认为display:inline；行内替换元素(input) 默认为display:inline-block；display:none；不显示该元素，也不会为该元素保留原先占有的文档流位置；这就要区别visibility:hidden，两者都会将某个元素隐藏起来，但是visibility:hidden仍然会保留元素的空间在那里;display:block;转换为块级元素；display:inline;转换为行内元素；display:inline-block;转换为行内块级元素；当将行内元素设置为float:left/right，该行内元素的display属性会被赋予block值，且拥有浮动特性；行内元素去除了之间的莫名空白；当为行内元素进行定位时，position:absolute与position:fixed都会使得原因的行内元素变为块级元素； css实现垂直水平居中这是一道经典的题，解决的办法有许多种，曾经写过一篇博客专门讲这个这里这里还是简单说一说：123&lt;div class="wrapper"&gt; &lt;div class="content"&gt;&lt;/div&gt; &lt;/div&gt; 12345678910111213141516.wrapper &#123; position: relative; width: 500px; height: 500px; background-color: #ddd; &#125; .content&#123; background-color:#6699FF; width:200px; height:200px; position: absolute; /*父元素需要相对定位*/ top: 50%; left: 50%; margin-top:-100px ; /*二分之一的height，width*/ margin-left: -100px; &#125; 效果就是这个样子的：具体的可以看看我的博客自己算一算； 简述一下src和href的区别？href是指向网络资源所在位置，建立和当前元素(锚点)或当前文档(链接)之间的链接，用于超链接;src是指向外部资源的位置，指向的内容将会嵌入到文档中当前的位置，在请求src资源时会将其指向的资源下载并应用到文档内；例如js脚本，img图片和frame等元素；当浏览器解析该元素时，会暂停其他资源的下载和处理，直到将该资源加载，编译，执行完毕，图片和框架等元素也如此； 什么是CSS Hack?一般来说是针对不同的浏览器写的不同的CSS，就是 CSS Hack;目的是使你的CSS代码兼容不同的浏览器；大致分为三种：内部Hack，选择器Hack,HTML头部引用(if IE)Hack；内部Hack:IE6能识别下划线”“和星号”*”，IE7能识别下划线”“，而firefox两个都不能识别等；12345.test&#123; color:#090\9; /* For IE8+ */ *color:#f00; /* For IE7 and earlier */ _color:#ff0; /* For IE6 and earlier */&#125; 选择器Hack:IE6能识别html .class{}，IE7能识别+html .class{} 或者 *.first-child+html .class{}等；12* html .test&#123;color:#090;&#125; /* For IE6 and earlier */ * + html .test&#123;color:#ff0;&#125; /* For IE7 */ 具体的可以参照这张表：HTML头部引入(if IE)Hack：针对所有的IE：,具体的实现如下：表示这段文字只在IE显示；1234567&lt;!--[if IE]&gt; &lt;style&gt; .test&#123; color:red &#125; &lt;/style&gt;&lt;![endif]--&gt; 表示这段文字只在IE6显示：12&lt;!--[if IE]&gt;&lt;![endif]--&gt; 只在IE6以上版本生效123&lt;!--[if gte IE 6]&gt;这段文字只在IE6以上(包括)版本IE浏览器显示&lt;![endif]--&gt; 只在IE8上不生效123&lt;!--[if ! IE 8]&gt;这段文字在非IE8浏览器显示&lt;![endif]--&gt; 非IE浏览器生效123&lt;!--[if !IE]&gt;这段文字只在非IE浏览器显示&lt;![endif]--&gt; 页面导入样式时，使用link和@import有什么区别？link属于XHTML标签，除了加载的CSS外，还能用于定义RSS，定义rel连接属性等作用；而@import是css提供的，只能用于加载css；页面被加载完成时，Link会同时被加载，而@import引用的CSS会等到页面被加载完再加载；import是CSS2.1提出来的，只有IE5以上才能识别，而link是xhtml标签，无兼容性问题； 简述同步和异步的区别？同步是阻塞模式，异步是非阻塞模式；同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；像平常的&lt;script&gt;加载js文件，&lt;img/&gt;加载图片都是同步的；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。像我们平常使用的ajax，默认都是异步的； px,em和rem的区别；px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em如果rem呢？是指相对于根元素的字体大小的单位，和em类似，只是一个计算的规则是依赖根元素一个是依赖父元素计算。 什么叫优雅降级和渐进增强？渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后针对高级浏览器进行效果，交互等改进和追加功能达到更好的用户体验；优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容；区别：a.优雅降级是从一个复杂的现状开始，并试图减少用户体验的供给；b.渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩大，以适应未来环境的需要；c.降级(功能衰减)意味着朝前看，同时保证其根基处于安全地带； 浏览器的内核分别是什么？IE：trident内核；Firefox:gecko内核；Safari:webkit内核；Opera:Blink内核；Chrome：Blink(基于webkit，Google和Opera Software共同开发)现在的双核浏览器指的是：拥有IE兼容内核和非IE极速内核两个内核(简而言之就是一个IE内核，一个非IE内核)； 跨域资源请求方式首先理解什么是跨域：由于浏览器的同源策略，凡是发送请求url的协议，域名，端口三者之间任意一与当前页面地址不同即为跨域；解决跨域的几种办法：结合我之前写过的文章1.JSONP只能使用get方式，通过绑定一个jsonpcallback回调函数；例如：http://www.sulishibaobei.com?callback=jsonpCallback;一般我是采用ajax的方式的，需要的参数一目了然；1234567891011121314$(function () &#123; $.ajax(&#123; async: true, type: "GET", dataType: 'jsonp', jsonp: 'callback', jsonpCallback: 'callback', url: "https://www.sina.cn", contentType: "application/json;utf-8", success: function (msg) &#123; alert(msg); &#125; &#125;); &#125;) 这里既然提到了ajax，我也写过具体的文章介绍的，请看2.proxy代理的方式代理的方式有许多种，之前我在网上copy过一段代码，用的yahoo的一个代理：http://query.yahooapis.com/v1/public/yql url前面多加这么一段，让他替我们发请求；后来用过nginx，这篇文章里面有过介绍因为我工作中主要用到的都是angular所以还介绍一种在angular中解决跨域的，配置proxy.config.json文件，原理和nginx是一样的；3.cors 这是现代浏览器支持跨域资源请求的一种方式;通过添加一个响应头：Access-Control-Allow-Origin；1res.setHeader("Access-Control-Allow-Origin","*"); 说道这种方式，之前我使用node的require去发送请求时，就使用过这一种，效果杠杠的； 4.script,iframe采用内嵌的方式也不会产生跨域的；1&lt;script src="url"&gt;&lt;/script&gt; 5.xdr IE8，IE9有一种解决跨域的方案，只支持get,post，而且对于协议不同的跨域是不行的；比如http下发送Https;在ie下，用原生ajax其实也可以得到数据；和xdr类似；1xdr.responseText 谈一谈垃圾回收机制以及内存管理？Javascript 具有自动垃圾回收机制，执行环境会负责管理代码过程中使用的内存；原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面结束，局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束；看看代码：123456789function fn1()&#123; var obj=&#123;name:'sulishibaobei',age:22&#125;&#125;function fn2()&#123; var obj=&#123;name:'sulishibaobei',age:22&#125;; return obj; &#125;var a=fn1();var b=fn2(); 首先，定义两个function,分别叫做fn1和fn2，当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象{name:’sulishibaobei’,age:10}，而当调用结束后，出了fn1环境，那么该块就会被js引擎中垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放；但是垃圾回收器是怎么知道那个需要被清除的，这就需要跟踪哪个标记是无用的变量；对于不再用的变量打上记号，以备垃圾回收机制清除；标记清除是最常用的垃圾回收方式；当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为’进入环境’,当离开时，就标记为’离开环境’;被标记为’离开环境’的就会被清除了；12345function test()&#123; var a=10;//被标记，进入环境 var b=20;//被标记，进入环境&#125;test();//执行完毕之后,a,b又被标记离开环境，被回收 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。采用这种方式的浏览器一般有IE,Firefox,Opera,Chrome,Safari等；引用计数也是垃圾回收的一种方式；原理是跟踪记录每个值被引用的次数；当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1；如果同一个值又被赋予另一个变量，则该值的引用次数加1；相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1；当这个值的引用次数变成0时，则说明没有办法访问这个值了，因而就可以将其占有的内存空间回收回来；这样当垃圾回收机制再次运行时，它就会释放那些引用次数为0的值所占有的内存；123456function test()&#123; var a=&#123;&#125; //a引用次数为0； var b=a; //a的引用次数加1，为1； var c=a; //a的引用次数加1，为2； var b=&#123;&#125;; //a的引用次数减1，为1；&#125; 这种方式中有一个问题，循环引用1234567function fn()&#123; var a=&#123;&#125;; var b=&#123;&#125;; a.pro=b; b.pro=a;&#125;fn(); 以上a，b引用的次数都是2，fn()执行完毕后，两个对象都已经离开环境，在清除标记下不会有问题，但是在引用计数策略下，因为a，b的计数都是2，所以不会被垃圾回收机制清除；如果fn函数被大量的调用，就会造成内存泄露；在IE7和IE8上，内存直线上升；解决办法就是：手动解除循环引用；将变量赋值为null；等垃圾回收机制运行时，就会清除这些值了；IE9+后并不会产生循环引用导致dom内存泄露问题；GC的缺陷：GC时，停止响应其他操作，可能对于连贯性比较高的应用不好；GC的优化：1.分代回收：目的是通过分区”临时”与”持久”对象，多回收”临时对象”区，少回收”持久对象”区；减少每次需要遍历的对象，从而减少每次GC的耗时；2.增量GC：每次处理一点，处理多次；显然对象太多，就不适合采取这种方式；根据实际情况比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。 开发过程中遇到的内存泄露情况，如何解决的？这是和上一个问题连在一块的，什么是内存泄露呢？按我的理解就是，已经不需要使用的变量还存在内存中没有被垃圾回收机制给清除掉，堆积在一起造成了系统内存的浪费，导致程序运行出现缓慢或者崩溃的情况;要搞清楚几点：内存泄露并不是占用很大内存才叫内存泄露，1byte的浪费都可以称为内存泄露;内存泄露是堆区，栈区不会泄露；跳转网页依然存在，直到浏览器的关闭；几种常见的会出现内存泄露的情况:1.循环引用1234567function fn()&#123; var a=&#123;&#125;; var b=&#123;&#125;; a.pro=b; b.pro=a;&#125;fn(); 还是上题中的例子；2.某些dom操作(IE)3.自动类型装箱转换(IE6,IE7)12var s='fffff';alert(s.length); 这里也会造成内存泄露是因为在js类型中，String类型并非对象，但是可以使用（.）运算符，因为js的默认类型转换机制，允许js在遇到（.）运算符时，自动将string类型转换为Object中对应的String对象。该临时转换的对象100%会泄露； 解决办法就是：1.显示转换类型；12var str=new String("hhhhhh");alert(str.length); 这大概就是typescript语言使用的原因；2.避免循环事件引用，将值覆为null；可以采用try..finally3.垃圾箱，将不要的对象放置在垃圾箱中；IE下，DOM对象不会被CG程序回收，只有在离开页面时才会被回收。一旦使用了DOM对象，千万不要试图o=null，可以设置一个叫garbage 的div，并且将其display设置为none，将不用的DOM对象存入其中。阮一峰老师介绍过关于内存泄露的解决办法，可以看看 一次完整的Http过程是怎么样的？基本流程：a.域名解析(查找浏览器解析)b.发起TCP三次握手第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号；第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k),即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESRABLISHED(TCP连接成功)状态，完成三次握手；c.建立TCP连接后发起http请求；d.服务端响应http请求，浏览器得到html代码；e.浏览器解析html代码，并请求html代码中的资源；f.浏览器对页面进行渲染，呈现给用户； Http的状态码有哪些？1.200状态码：成功2xx，成功处理了请求的状态码a.200:服务器已成功处理了请求并提供了请求的网页；b.204：服务器成功处理了请求，但没有返回任何内容；c.206：客户端发送了i一个带有Range头的GET请求，服务器完成了它； 2.300状态码 ： 重定向3xx，每次请求中使用重定向不超过5次；a.301:请求的网页已永久转移到新的位置，当URLs发生变化时，使用301代码。搜索引擎中保存新的URL；b.302:请求的网页临时转移到新的位置，搜索引擎索引中保存原来的URL；c.304：如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销； 3.400状态码：客户端错误4xx，表示请求可能出错，妨碍了服务器的处理；a.400：服务器不理解请求的语法；b.403：服务器拒绝请求；c.404：服务器找不到要请求的网页，服务器上不存在网页经常会返回此代码；d.410：请求的资源永久删除后，服务器返回此响应，该代码与404相似，但是资源以前存在而现在不存在的情况下，有时用来替代404页面代码，如果资源已永久删除，应使用301指定资源的新位置； 4.500状态码服务器错误5xx:表示服务器在处理请求时发生内部错误，这些错误可能是服务器本身的错误，并不是请求出错；a.500:服务器遇到错误，无法完成请求；b.503：服务器目前无法使用（由于超载或停机维护) Https是如何实现加密？https是在http上面多了一层协议ssl,该协议用来给传输的内容加密；https加密流程： 1.客户端将SSL协议的版本号，加密算法的种类，产生的随机数A等信息传给服务器； 2.服务器选择其中的一种组合作为加密方式，同时将自己的证书，公钥，另外一个随机数B一起传给客户端； 3.客户端验证客户端返回的信息(包括证书，签名，域名等),验证成功，则生成对称加密密钥s，用公钥加密后返回给服务器； 4.服务器用私钥将这段密钥解密，得到对称密钥s,并用此密钥加密一段握手消息返回给客户端； 5.客户端收到握手消息，用对称密钥解密，验证成功，则握手成功；单向加密和双向加密：单向加密：服务端有一套(两份)证书:含公钥和私钥的Jks文件(此文件自己保留),和只含公钥的ser文件，其中ser文件是要给客户端的；双向加密：除了具有单向加密的特性(服务端验证客户端),客户端也有一套(两份)证书来验证服务端消息，对于android来说，分别bks文件(含公钥和私钥，自己保留)，ser文件(含公钥给服务端); 关于算法题快速排序算法 可以参考阮一峰老帅的；二分法查找也叫做对半查找：是一种在有序数组中查找特定元素的搜索算法；查找过程： a.首先，从有序数组的中间元素开始搜索，如果该元素正好是目标元素(即要查找的元素),则搜索过程结束，否则进行下一步； b.如果目标元素大于或者小于中间元素，则在数组大于或者小于中间元素的那一半区域查找，然后重复第一步的操作； c.如果某一步为空，则表示找不到目标元素； 对Node的优缺点看法？优：Node是基于事件驱动和无阻塞的适合处理并发请求，客户端代码是由javascript编写，易懂；缺：不稳定如果还有好多看法，欢迎指出； 性能优化的方法？css方面：a.减少http请求次数：css Sprites,js、css源码压缩,使用webp后缀的图片；data缓存，图片服务器，CDN托管；图片大小适中；b.当设置样式很多时，尽量设置className,而不是操作style；c.图片预加载，将样式表放在顶部，脚本放在底部；javascript方面：a.用innerHTML代替操作DOM，优化Javascript性能；b.用变量保存请求结果，每次操作本地变量，避免请求次数；c.少用全局变量，缓存dom节点查找结果，减少IO读取操作；]]></content>
      <categories>
        <category>前端面试题整理</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML5</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx第一课]]></title>
    <url>%2Fnginx%2Fng-120170925%2F</url>
    <content type="text"><![CDATA[有这样一个问题，我的nicefish项目里面要从我的服务器http://112.74.180.53 里面去拿去数据，然后遇见了跨域；然后就想到了用nginx做一个代理去拿数据；其实解决的办法由很多种，单单就跨域的这个问题的话，proxy.config.json也是可以解决，jsonp也可以解决，这里聊一聊我用nginx解决的过程； nginx 下载戳这里我下载的是1.12.1 ,哪个版本都可以打开可以看到几个文件夹和一个可执行文件 ，向下面的一样；html 文件里面主要放html代码或者项目的；conf 主要是放置我们的配置文件；我们切换到当前文件内运行nginx.exe或者nginx start默认的端口号是80，浏览器打开localhost 就可以看到一个页面，这时候运行的是html文件里面的index.html；如果想修改端口号，则是conf文件夹里的nginx.conf 下面会仔细来介绍这个配置文件的； 打开nginx.conf文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#user nobody;worker_processes 1; #允许生成的进程数2 ,默认数1#error_log logs/error.log; #指定日志路径，级别，这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid; #指定ngInx进程运行文件存放地址events &#123; #events块 worker_connections 1024; #最大连接数 默认为512 #accept_mutex on; #设置网络连接序列化，防止惊群现象发生， # multi_accept on; # 设置一个进程是否同时接受多个网络连接，默认为off; # use epoll; #事件驱动模型， select|poll|kqueue|epoll|resig|/dev/poll|eventport;&#125;http &#123; # http 块 可以嵌套多个server ,配置代理 include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #proxy_method get; #access_log off; # 取消服务日志 #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; # 自定义格式 #access_log logs/access.log main; #combined为日志格式默认值 sendfile on; #允许sendfile方式传输文件，默认值为off，可以在http块，server块，location块； #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #链接超时时间，默认值为75s，可以在http块，server块,location块； #sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 #gzip on; #upstream mysvr&#123; #server 127.0.0.1:80; #server 112.74.180.53:80; #&#125; server &#123; # server块 配置虚拟主机的相关参数，一个http中可以有多个server listen 80; #监听端口 server_name tomcat; #监听地址 root html; index index.html; location /file &#123; #配置请求的路由 以及各个页面的处理情况 proxy_pass http://112.74.180.53:80; &#125; location /toutiao &#123; proxy_pass http://v.juhe.cn; &#125; location ~* \.(js|css|png|gif|jpg|mp3|ogg|ttf|woff|woff2|html|json|map)$ &#123; expires 30d; &#125; default_type 'text/html'; charset utf-8; # keepalive_timeout 120; #单链接请求上限次数 # location ~*^.+$ &#123; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 #root path; #根目录 #index vv.txt #设置默认页 #proxy_pass http://mysvr #请求转向mysvr定义的服务器列表 #deny 127.0.0.1; #拒绝的ip #allow 172.18.5.54 #允许的ip # &#125; #charset koi8-r; #access_log logs/host.access.log main; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html #proxy_intercept_errors on; #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。 error_page 500 502 503 504 /50x.html; #错误页 location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; #都是被注释的代码；root html;index index.html;这就是为什么运行localhost会打开html里面index.html文件的原因，都是在配置文件里配置好的；也就是如果我d盘有个项目，root换成d盘路径，打开的就是我的项目了；1234upstream mysvr&#123; #server 127.0.0.1:8081; server 112.74.180.53:80; &#125; 看到有这样一段代码，被我注释掉了；其实是和这个一起使用的123location /file &#123; #配置请求的路由 以及各个页面的处理情况 proxy_pass http://112.74.180.53:80; &#125; 如果上面的upstream mysvr不被注释，那么这段应该这么写： 123location /file &#123; #配置请求的路由 以及各个页面的处理情况 proxy_pass http://mysvr; &#125; 能用到的每一行都在后面写了注释，跟着使用就可以啦；举个例子：我要去这个下面获取数据http://112.74.180.53/file/comment-mock.json注意看看我的location那里怎么配置的；proxy_pass http://112.74.180.53:80; 将地址写在这里；location /file 表示只要遇见/file开头的请求就调用这个代理；这就是为什么配置了多个的原因： 1234567location /file &#123; #配置请求的路由 以及各个页面的处理情况 proxy_pass http://112.74.180.53:80; &#125;location /toutiao &#123; proxy_pass http://v.juhe.cn; &#125; 不同的文件，调用不同的；但是怎么知道是不是file开头呢？就是和我们的html里面的代码有关；我们的url中这样写就可以啦：private url=’/file/comment-mock.json’;碰到是这个请求的就会走入第一个配置啦；这边也推荐几个觉得写得不错的文章，如果还有疑问，可以去这些文章中看一看；用nginx的反向代理机制解决前端跨域问题nginx常用代理配置玩玩nginx或者私信给我，我们一起来聊一聊；]]></content>
      <categories>
        <category>前端那些微小事</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你如何使用正则表达式]]></title>
    <url>%2Fjs%2Fzhengze20170925%2F</url>
    <content type="text"><![CDATA[认识一些元字符\b 表示单词开头或者结尾，也就是单词的分界处；虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔符中的任何一个，它只匹配一个位置；例如：\bhi\b* 代表前边的内容可以连续重复使用任意次以使整个表达式得到匹配;.连在一起就意味着任意数量的不包含换行的字符；例如：\bhi\b.\bLucy\b 表示：一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。\d 表示匹配是一个数字（0,或1，…);\s 匹配任意的空白符，包括空格，制表符，换行符，中文全角空格等；\w 匹配字母或数字或下划线或汉字等；+ 匹配重复1次或更多次。如果我们同时使用元字符，就可以构造出更强大的表达式，例如：0\d\d-\d\d\d\d\d\d\d\d 匹配这样的字符串：以0开头，然后中间有两个数字，然后一个连接符“-” ,最后是8个数字；为了不写这么麻烦，我们也可以这样：0\d{2}-\d{8},这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)；\ba\w\b 匹配以字符a开头的单词–先是某个单词开始出(\b),然后是字母a，然后是任意数字的字母或者数字(\w),最后是单词结束处(\b);\d+ 匹配一个或更多连续的数字。\b\w{6}\b 匹配刚好6个字符的单词；^\d{5,12}$ 匹配5到12个数字；如果想查找元字符本身如等，这时就要用到字符转义；用\来取消这些字符特殊的意义；*，\等；如果想要查找数字，字母或数字，空白就很简单了；[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)；[0-9]代表的含义就是和\d一样的；表示匹配一位数字；[a-z0-9A-Z_]也就完全等同于\w 修饰符修饰符用于执行区分大小写和全局匹配 RedExp对象方法其实个人觉得正则表达式如果不是到非必要的时候，只要会使用简单的就可以啦，复杂一点的会读就行；如果想了解更多复杂的功能，可以看这个人的；正则表达式30分钟入门教程]]></content>
      <categories>
        <category>前端那些微小事</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>正则表达式</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 4 自定义组件封装遇见的一些事儿]]></title>
    <url>%2Fangular%2Fstyle%2Fcomponent-120170908%2F</url>
    <content type="text"><![CDATA[你用Angular 吗？一.介绍说说封装Angular 组建过程中遇见的一些问题和感悟.用久了Angular,就会遇见很多坑，许多基于Angular开发的框架最喜欢做的事情就是封装组件,然后复用因为这是最省事的.二.基本构建组件思想 界面构建草图简要介绍上图：1.View 就是我们需要完成的界面,但是界面无非就是由若干个label,button,table,img,list等一些基本控件构成的,所有的前端页面构成都是一样,只是加上CSS排版确定最后的显示效果。2.五种基类，其实不止五种,只是列举。这里就需要我们将基类都封装成组件的形式,对外提供组件标签就可以使用.不管构建多少个页面,都可以用这几个基本组件完成.eg：一个button组件 button.component.html这个Button组件里面是还包裹一个label组件的. button.component.ts对外只用提供选择器，就可以使用Button了.3.可是为什么还要有中间的UIbuileder呢？是这样的，每次引选择器名是不是也很麻烦，看起来没有省力多少，封装的基本组件只需要对外抛出一个TYPEID，UIbuilder只要知道1是代表button组件，2代表label组件，UIbuilder将组件构建出来。 UIBuilder.html 构建组建图VIEW界面需要Button给我传一个1，需要label传一个2，需要什么传对于的id就行。此时的界面和组件是完全分离的，这样构件界面的时候几乎可以没有代码就出来一个页面啦。而且下次用的时候，基类是完全不用动的。三.样式控制。也许你会觉得这样构件出来的只有最简单的页面，那么样式呢？的确呀，这样就是很老土的界面，那么样式要怎么实现呢？其实Angular 提供了很多的方法的。1.一张样式表，定义所有的样式。相当于boostrap一样。 button样式定义都知道双花括号的定义,你只要在最外面将你需要的样式名传进来就可以啦.2.代码修改样式ElementRef ，Renderer2 有多少人知道这两个属性的。 代码修改样式这种都是可以在外部修改样式的,你的基组件不需要改动。 可能看起来费劲,但用起来好处很多，不用copy,copy了,而且你的思想也会到一个新的境界。其实，我用Angular有一段时间了,如果你也是,欢迎来交流。]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>自定义</tag>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flexible Box布局基础知识详解]]></title>
    <url>%2Fcss%2Ffb-120170908%2F</url>
    <content type="text"><![CDATA[1.基本概念，借用阮一峰老师的一张图：容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 2.容器的基本属性flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 2.1 flex-direction 属性决定主轴的方向 (及行排列) 默认值：row123.box&#123; flex-direction：row | row-reverse | column |column-reverse /*有四个值 分别的显示效果*/ &#125; html5实现代码： 123456&lt;div class="box"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css3部分实现代码： 12345678910111213141516171819body&#123; margin: 0 auto; width: 1000px; &#125; .box&#123; background: gold; margin: 1px; display: flex; /*必须设置这个*/ flex-direction: row; /*一排的方式排列*/ &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 实现效果：如果css3改成 flex-direction: row-reverse;其他两个属性类推； 2.2 flex-wrap 定义如果一条轴线排不下，如何换行 默认：nowrap123.box&#123; flex-wrap：nowrap | wrap | wrap-reverse; &#125; html部分代码：1234567891011121314&lt;div class="box1"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css 部分代码： 123456789101112131415.box1&#123; background: gold; margin: 1px; display: flex; flex-flow: wrap; &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 效果：这是换行的效果，其他效果可以尝试； 2.3 flex-flow 是flex-direction 和 flex-wrap的缩写；所以当独写上面的要写两个默认值为row norap 123.box&#123; flex-flow: flex-direction || flex-wrap &#125; 2.4 justify-content 属性定义了项目在主轴上的对齐方式123.box&#123; justify-content:flex-start | flex-end | center | space-between | space-around; &#125; flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。html5代码： 12345678910&lt;div class="box2"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css3代码：123456789101112131415.box2&#123; background: gold; margin: 1px; display: flex; justify-content: center; /**可以换换其他的属性值*/ &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 效果图：其他的可以自己试试：flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2.5 align-items 定义项目在交叉轴上如何对齐（纵轴）123.box&#123; align-items:flex-start | flex-end |center | baseline |stretch &#125; html5代码： 1234567891011121314&lt;div class="box3"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css3代码： 1234567891011121314151617181920.box3&#123; background: gold; margin: 1px; display: flex; align-items:flex-end; /*可以换其他值看看*/ flex-wrap: wrap; &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; .item-tall&#123; height: 200px; /*交叉轴，高度不一*/ line-height: 200px; &#125; 效果：其他的可以自己试试：flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 2.6 align-content 属性定义了多根轴线(多行)的对齐方式，如果项目只有一根轴线，该属性起不来作用123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; &#125; html代码： 1234567891011121314&lt;div class="box3 box3-tall"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css代码： 12345678910111213141516171819.box3&#123; background: gold; margin: 1px; display: flex; flex-wrap: wrap; align-content: space-around; &#125; .box-tall &#123; height: 300px; &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 效果：其他的可以自己试试：flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 3.容器里子元素的属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch通常我们定义flex:1;表示的就是这三个； 3.1 order 属性html代码：1234&lt;div class="box4"&gt; &lt;div class="box-item1 "&gt;1&lt;/div&gt; &lt;div class="box-item1 order"&gt;2&lt;/div&gt; /*注意是第二个元素有Order类*/ &lt;/div&gt; css代码：123456789101112131415161718.box4&#123; background: gold; margin: 1px; display: flex; &#125; .box-item1&#123; flex: 1; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; .order&#123; background: blue; order: -1; &#125; 效果图：如果我这样设置： 12345.order&#123; background: blue; order: -1; flex-grow:2; /*多了这个*/ &#125; 其他的去试一试，大概就是这样]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>弹性布局</tag>
        <tag>Flexible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 4+ HttpClient]]></title>
    <url>%2Fangular%2Fhttp%2Fhttp-220170908%2F</url>
    <content type="text"><![CDATA[Angular 4.3.0-rc.0 版本已经发布🐦。在这个版本中，我们等到了一个令人兴奋的新功能 - HTTPClient API 的改进版本；HttpClient 是已有 Angular HTTP API 的演进，它在一个单独的 @angular/common/http 包中。这是为了确保现有的代码库可以缓慢迁移到新的 API；大多数前端应用都需要通过 HTTP 协议与后端服务器通讯。现代浏览器支持使用两种不同的 API 发起 HTTP 请求：XMLHttpRequest 接口和 fetch() API；@angular/common/http中的HttpClient类，Angular 为应用程序提供了一个简化的 API 来实现 HTTP 功能。它基于浏览器提供的XMLHttpRequest接口。 HttpClient带来的其它优点包括：可测试性、强类型的请求和响应对象、发起请求与接收响应时的拦截器支持，以及更好的、基于可观察（Observable）对象的错误处理机制；1.如何使用httpClient; 123456789101112import &#123;NgModule&#125; from '@angular/core';import &#123;BrowserModule&#125; from '@angular/platform-browser';import &#123;HttpClientModule&#125; from '@angular/common/http';@NgModule(&#123; imports: [ BrowserModule, // Include it under 'imports' in your application module // after BrowserModule. HttpClientModule, ],&#125;)export class MyAppModule &#123;&#125; 注意：导入方式和HttpModule一样的，记得要在BrowserModule后面导入；区别是：在@angular/common/http 模块里面，而不是@angular/http中这样我们可以使用这些啦： 1234567891011class HttpClient &#123; request(first: string|HttpRequest&lt;any&gt;, url?: string, options: &#123;...&#125;): Observable&lt;any&gt; delete(url: string, options: &#123;...&#125;): Observable&lt;any&gt; get(url: string, options: &#123;...&#125;): Observable&lt;any&gt; head(url: string, options: &#123;...&#125;): Observable&lt;any&gt; jsonp&lt;T&gt;(url: string, callbackParam: string): Observable&lt;T&gt; options(url: string, options: &#123;...&#125;): Observable&lt;any&gt; patch(url: string, body: any|null, options: &#123;...&#125;): Observable&lt;any&gt; post(url: string, body: any|null, options: &#123;...&#125;): Observable&lt;any&gt; put(url: string, body: any|null, options: &#123;...&#125;): Observable&lt;any&gt;&#125; 2.发起一个请求来获取Json数据；首先创建一个json文件，其实就是上一篇的同一个json文件：{ “data”: [ { “id”: 1, “name”: “Windstorm” }, { “id”: 2, “name”: “Bombasto” }, { “id”: 3, “name”: “Magneta” }, { “id”: 4, “name”: “Tornado” } ]} 怎么调用Http请求呢？2.1 app.componment.ts; 1234567891011121314151617import &#123; Component,OnInit &#125; from '@angular/core';import &#123;HttpClient&#125; from '@angular/common/http'; /*注释1*/@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent implements OnInit &#123;constructor(private http:HttpClient)&#123;&#125; datas:string[]; ngOnInit()&#123; this.http.get('./assets/heroes.json').subscribe(data=&gt;&#123; /*注释2*/ this.datas=data['data']; console.log(this.datas) &#125;) &#125;&#125; 注意：注释1：组件中引入的是HttpClient,也是在单独的库，@angular/common/http中;之前的项目里面引入的一直都是http，这就是改版后的区别；注释2：现在 JSON 是默认的数据格式，我们不需要再进行显式的解析；this.http.get(‘xx’).subscribe();之前的还需要res.json()去手动转；还有一点要注意：我并没有去hero.service.ts里面去操作了，而是直接在组件中发请求获取数据，这样更加简单明了；12345&lt;div&gt; &lt;ul *ngFor="let data of datas"&gt; &lt;li&gt;&#123;&#123;data.id&#125;&#125; &#123;&#123;data.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; html代码还是一样简单，并没有改变；这是相比较之前的Http简单的方式； 12345678get(url: string, options: &#123; headers?: HttpHeaders, observe?: HttpObserve, params?: HttpParams, reportProgress?: boolean, responseType?: 'arraybuffer'|'blob'|'json'|'text', withCredentials?: boolean,&#125;): Observable&lt;any&gt; 这是get方法详解，请注意，返回的都是observable对象，而不是使用promise了；3.响应体的检查3.1上面的代码中： 12 datas:string[]; //定义一个接口来描述这个类型的正确形态this.datas=data['data']; /*注释1*/ 注释1：我们取json对象data值时要data[‘data’]，而不是之前的data.data了；如果改成： this.datas=data.data;会报错：does not exist on type &#39;Object那是因为HttpClient把 JSON 格式的响应体解析成了一个Object，它并不知道这个对象的形态应该是什么。所以我们应该告诉你需要取得data是个什么类型；这也是更符合typescript语法的做法；4.如果将要获取的不是JSON文件如何？123 this.http.get('/assets/1.txt',&#123;responseType:'text'&#125;).subscribe( data=&gt;console.log(data)) 注意：这样我们就要指定需要获取的文本格式；控制台将会打印我的1.txt中的内容：www.sulishibaobei.com 5.如何带参查询数据 1234567const params = new HttpParams() .set('id', '1').set('name','Windstorm') this.cus=this.http.get('assets/heroes.json',&#123;params&#125;) .do(console.log) .map(data=&gt; console.log( _.values(data)) ); 引入：httpParams参数：import {HttpClient, HttpParams} from &#39;@angular/common/http&#39;;我们通过链式语法调用set()方法，构建了params对象；每当set()方法被调用时，都会包含新的值进来，并且防止之前对象不被修改；http://localhost:4200/assets/heroes.json?id=1&amp;name=Windstorm请求的链接地址将会是这样的形式；这个有点像http里添加url参数；还可以设置Headers；const headers = new HttpHeaders().set(&quot;X-CustomHeader&quot;, &quot;custom header value&quot;);还有其他的请求，之后会逐一分析；另外还有几点比较重要的：多行并发发送请求和顺序发送请求，避免发送重复请求； 12345import 'rxjs/add/operator/shareReplay';const httpGet = this.http .get("assets/heroes.json") .map(data =&gt; _.values(data)) .shareReplay(); 这样即使你将 httpGet再赋值给另一个变量，或重复调用也不会再次请求了并行发送 HTTP 请求的一种方法是使用 RxJs 中的 forkjoin 操作符： 12345678910111213import 'rxjs/add/observable/forkJoin';Requests() &#123; const result = Observable.forkJoin( this.http.get('/assets/heroes.json'), this.http.get('/assets/heroes.json') ); result.subscribe( values =&gt; &#123; console.log("all values", values) &#125; );&#125; 顺序发送请求 123456789sequentialRequests() &#123; const sequence$ = this.http.get&lt;Hero&gt;('/assets/heroes.json') .switchMap(hero =&gt; &#123; hero.id+= ' - TEST '; return this.http.put('/assets/heroes.json', hero) &#125;); sequence$.subscribe();&#125; 6.拦截器 （拦截所有的请求和响应这也是@angular/common/http的核心特性之一）它能声明一些拦截器，拦在应用和后端之间。当应用程序发起一个请求时，拦截器可以在请求被发往服务器之前先转换这个请求。并且在应用看到服务器发回来的响应之前，转换这个响应。这对于处理包括认证和记录日志在内的一系列工作都非常有用。6.1 如何写一个拦截器 1234567891011121314151617import &#123;Injectable&#125; from '@angular/core';import &#123;HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse&#125; from '@angular/common/http';import &#123;Observable&#125; from 'Rxjs/Observable';@Injectable()export class NoopInterceptor implements HttpInterceptor &#123; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; return next.handle(req).map(event =&gt; &#123; if (event instanceof HttpResponse) &#123; if (event.status === 401) &#123; // JWT expired, go to login &#125; &#125; return event; &#125; &#125; &#125; 1.intercept是一个方法，它把一个请求对象转换成一个返回这个响应的可观察对象（Observable）。从这个意义上说，每个拦截器都要完全自己处理这个请求；2.响应拦截器可以通过在 next.handle(req) 返回的流对象 (即 Observable 对象) 上应用附加的 Rx 操作符来转换响应事件流对象；内部可以做自己的处理操作；但是此时拦截器还未使用在组件上； 12345678910import &#123;NgModule&#125; from '@angular/core';import &#123;HTTP_INTERCEPTORS&#125; from '@angular/common/http';@NgModule(&#123; providers: [&#123; provide: HTTP_INTERCEPTORS, useClass: NoopInterceptor, multi: true, &#125;],&#125;)export class AppModule &#123;&#125; providers里面配置我们的信息；注意multi: true选项。这是必须的，因为它会告诉 Angular 这个 HTTP_INTERCEPTORS 表示的是一个数组，而不是单个的值；]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>httpClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap简单图文环绕效果]]></title>
    <url>%2Fbootstrap%2Fbt-120170908%2F</url>
    <content type="text"><![CDATA[一.下载bootstrap-3.3.7二.在html页面引入css,js;eg:123&lt;link src="bootstrap-3.3.7-dist/css/bootstrap.min.css"&gt;&lt;script type="text/javascript" src="jquery.min.js"&gt;&lt;/ script&gt; &lt;script type="text/javascript" src="bootstrap-3.3.7-dist/js/bootstrap.min.js"&gt;&lt;/ script&gt; 注意：因为会用到jquery，所以引入了jquery .js;三.body部分的代码是这样的：123456&lt;body style="margin: 10px;padding: 0px"&gt; &lt;div class="left"&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;/div&gt;&lt;body/&gt; 简单解析下： body里包含两个div ,一个在左边排列(用于放图片)，一个在右边排列(用于放文字);都用class名进行区分啦，left和right;简单的给两个div添加点样式： .left { float : left ; max-width : 43% ; padding-left : 5px ; } .right{ margin-left : 5px ; } 现在还看不出什么效果;给第一个div里添加图片;&lt; img src=”index.jpg” class=”img-responsive” alt=”图像”&gt; 给第二个div添加文字，里面的文字是采用Boostrap的样式; &lt;div class="container"&gt; &lt;h1&gt;图文环绕&lt;/h1&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-offset-3" style=" box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;div class="row"&gt; &lt;div class="col-md-6" style=" box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;风雨中走过却不安世事的心&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;我还是很喜欢你，像风走了三千米不问归期 我希望有个如你一般的人如山间清爽的风如古城温暖的光从清晨到夜晚由山野到书房只要最后是你就好 &lt;/p&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-sm-offset-3" style="box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;我觉得这个世界美好无比。晴时满树花开，雨天一湖涟漪，阳光席卷城市，微风穿越指间，入夜每个电台播放的情歌，沿途每条山路铺开的影子，全部是你不经意写的一字一句，留我年复一年朗读。这世界是你的遗嘱，而我是你唯一的遗物。 &lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;一个人的记忆就是座城市，时间腐蚀着一切建筑，把高楼和道路全部沙化。如果你不往前走，就会被沙子掩埋。所以我们泪流满面，步步回头，可是只能往前走 &lt;/p&gt; &lt;/div&gt; &lt;div class="clearfix visible-xs"&gt;&lt;/div&gt; &lt;div class="col-xs-6 col-md-offset-3" style=" box-shadow:inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;你燃烧，我陪你焚成灰烬。你熄灭，我陪你低落尘埃。你出生，我陪你徒步人海。你沉默，我陪你一言不发，你欢笑，我陪你山呼海啸。你衰老，我陪你满目疮痍。你逃避，我陪你隐入夜晚。你离开，我只能等待。 &lt;/p&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-sm-offset-3" style="box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;p&gt;我希望买的鞋子是你渴望的颜色。我希望拨通电话时你恰好在想我。我希望说早安你也刚起床。我希望写的书是你欣赏的故事。我希望关灯的刹那你正泛起困意。我希望买的水果你永远觉得是甜的。我希望点的歌都是你喜欢唱的。我希望我希望的是你希望的。 &lt;/p&gt; &lt;/div&gt; &lt;div class="clearfix visible-xs"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 采用的是bootstrap的架构： container&gt; row&gt; column&nbsp;将css样式也写在标签上，所以有点看起来复杂，其实很简单，这几段文字的结构都一样。看看运行效果：拖动页面试试你可以通过控制台随意拖动页面的宽度，看看文字的适配程度。源码另外有两个免费网站模板也可以看看，在同一个github路径下]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
        <tag>图文环绕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 4+ Http]]></title>
    <url>%2Fangular%2Fhttp%2Fhttp-120170908%2F</url>
    <content type="text"><![CDATA[HTTP: 使应用能够对远端服务器发起相应的Http调用；你要知道：HttpModule并不是Angular的核心模块，它是Angualr用来进行Web访问的一种可选方式，并位于一个名叫@angual/http的独立附属模块中；也就是说：使用http之前要引入此模块; 1.基本使用：12345678910111213141516import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123;HttpModule&#125; from '@angular/http'; /*引入它*/import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, HttpModule /*导入*/ ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 注意，现在HttpModule已经是根模块AppModule的imports数组的一部分了; 2.介绍模拟web api 发送请求注意：是在你没有真实的远程服务请求地址时，自己模拟一个web服务，用于测试代码；倘若有真实的远程服务器，则不需要这个； 2.1 引入InMemoryWebApiModule，这是Angular提供的一个辅助服务，负责与远程服务器对话 — 替换成了内存 Web API服务，类似于后端服务；import { InMemoryWebApiModule } from ‘angular-in-memory-web-api’;注意：导入这个，如果出现错误，可能是你的node-module 文件库里面没有此库，这时候打开你的package.json文件：“dependencies”里面配置这样一句：“angular-in-memory-web-api”: “^0.3.2” 重新运行npm install; 2.2 向内存服务中注入数据，如果没有数据是不能运行的；import { InMemoryDataService } from ‘./in-memory-data.service’;注意几点： 1234567891011121314in-memory-data.service.ts 文件是你自己创建的，用来存放实例数据的；in-memory-data.service.ts 这样写：import &#123; InMemoryDbService &#125; from 'angular-in-memory-web-api';export class InMemoryDataService implements InMemoryDbService&#123; createDb() &#123; const heroes = [ &#123; id: 0, name: 'Zero' &#125;, &#123; id: 1, name: 'Mr. Nice' &#125;, &#123; id: 2, name: 'Narco' &#125;, &#123; id: 3, name: 'Bombasto' &#125;, ]; return &#123;heroes&#125;; &#125;&#125; 这里相当于自己创建了一个内部数据库； 2.3导入的文件如何在app.module.ts中注入：12345678910111213141516171819import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123;HttpModule&#125; from '@angular/http';import &#123; InMemoryWebApiModule &#125; from 'angular-in-memory-web-api';import &#123; InMemoryDataService &#125; from './in-memory-data.service';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, HttpModule, InMemoryWebApiModule.forRoot(InMemoryDataService), /*这样注入*/ ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 这里现在就是全部代码； 3.如何发起http请求；3.1创建一个服务；1234import &#123;Injectable&#125; from '@angular/core';@Injectable()export class HeroService&#123;&#125; angular 中所有创建服务的模式都是这样，我们创建了一个HeroService的文件，下载要在app.module.ts中注入它； 123import &#123;HeroService&#125; from './hero.service'; providers: [HeroService], bootstrap: [AppComponent] 注意：1.providers 是专门用来注入服务的； 可以在app.module.ts里的providers中注入服务，也可以在你的子模块和组件中注入，前者是共享的服务，一次注入，整个项目都有效，如果在子模块中或者子组件中注入，这只是你属于当前模块或当前组件下有效，其他的组件需要使用，都得自己重新注入；一般情况下：返回的是一个能解析的promise(承诺)3.2 引入http ; 12import &#123;Http&#125; from '@angular/http';constructor(private http:Http)&#123; &#125; 一定要在构造里创建它； 3.3 尝试获取内存数据库里面的信息；123456789101112131415import &#123;Injectable&#125; from '@angular/core';import &#123;Http&#125; from '@angular/http';import 'rxjs/add/operator/toPromise';import &#123;Hero&#125; from './hero';@Injectable()export class HeroService&#123; constructor(private http:Http)&#123; /*注释1*/ private heroUrl='api/heroes'; /*注释2*/ getHeroes(): Promise&lt;Hero[]&gt;&#123; return this.http.get(this.heroUrl) /*注释3*/ .toPromise() /*注释4*/ .then(response =&gt;response.json().data as Hero[])/*注释5*/ .catch((error: any) =&gt; Promise.reject(error || "Server error")); &#125; &#125; 现在我写了一个getHeroes()的方法：解析几点：注释1：http请求肯定需要Url地址，这里需要导入数据库里面的名；api/heroes 其实就是你内存数据库 web api里面return {heroes};根据你返回的值，调用相应的api地址；注释2：使用的是http承诺（promise），一定要有返回值，返回的是一个可以解析成英雄列表的Observable对象 ,也就是我们的Hero；也就是需要导入这个import {Hero} from &#39;./hero&#39;;hero.ts文件包含： 1234export class Hero&#123; id:number; name:string;&#125; Observable（可观察对象）是一个管理异步数据流的强力方式，后续会学习；注释3：.toPromise会将我们得到的Observable对象转化成promise对象；但是Angular中的observable对象并没有一个topromise操作符，这里就需要借助其他工具，import &#39;rxjs/add/operator/toPromise&#39;;更多详细的可以看rxjs库操作符；注释4：在 then 回调中提取出数据，这也是angular中一大特点，默认 JSON 解析,这个由json方法返回的对象只有一个data属性。这个data属性保存了英雄数组，这个数组才是调用者真正想要的。 所以我们取得这个数组，并且把它作为承诺的值进行解析注意：web api 返回的是带有data属性的对象，而你真是的api可以返回其他值的；注释5：错误处理,有异常很正常，我们可以将他们传给错误处理器；现在我们只是将错误记录到控制台，真实案例中，可以将错误进行处理； 4.如何将获得的数据显示在界面；4.1 组件中调用Hero.service.ts；12345678910111213141516171819202122import &#123; Component &#125; from '@angular/core';import &#123;HeroService&#125; from './hero.service';import &#123;Hero&#125; from './hero';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; /*注释1*/ hero:Hero[]; /*注释2*/ constructor(private service:HeroService)&#123; this.getHeroes(); &#125; getHeroes()&#123;/*注释3*/ this.service.getHeroes().then( hero=&gt;&#123; this.hero=hero; console.log(this.hero); &#125;/*注释4*/ ).catch((error: any) =&gt; Promise.reject(error || 'client error')) &#125;&#125; 注释1： 用来接收返回的对象；注释2： 对引入的hero.service.ts服务初始化；注释3： 返回的是promise对象，用then方法去解析得到的值；注释4： 预期会犯错，抛出异常；现在可以看看控制台打印的hero对象：如何显示在我们的html上呢？123&lt;ul *ngFor="let a of hero"&gt; &lt;li&gt;&#123;&#123;a.id&#125;&#125; : &#123;&#123;a.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 简单的写了这样一段：这里注意：多对数组或对象形式用*ngFor遍历；运行localhost:4200,这样就可以让数据正常显示啦；这里介绍的是采用promise的形式调用http的方法，原理就是：hero.service中，http.get()返回的Observable后面串联了一个toPromise操作符。 该操作符把Observable转换成了Promise，并且我们把那个承诺返回给了调用者； 5.http promise还能做什么？5.1 尝试通过id获取英雄；hero.service.ts中添加这段代码： 123456789getHero(id:number):Promise&lt;Hero&gt;&#123; const url = `$&#123;this.heroUrl&#125;/$&#123;id&#125;`; return this.http.get(url) .toPromise() .then(response =&gt; response.json().data as Hero, ) .catch((error: any) =&gt; Promise.reject(error || 'Server error')); &#125; 和获取所有英雄的方法类似，这个的步骤是先获取所有的英雄，并从中过滤出与id匹配的那一个；匹配api/hero/:id 模式，有点像路由； 5.2 组件中如何调用；123456789detailhero:Hero;getHero(id:number)&#123; this.service.getHero(id).then( hero=&gt;&#123; this.detailhero=hero; console.log(this.detailhero); &#125; ).catch((error: any) =&gt; Promise.reject(error || 'client error')) &#125; 方法都类似，只是你需要传入想查询的id;constructor中运行此方法，比如我想知道第二个英雄的详情：this.getHero(2);看看控制台输出：看看html代码：注意：单个对象用*ngIf ； 6.http promise还有什么请求方式？1234567891011121314151617181920212223242526272829request(url: string | Request, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `get` http method. */ get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `post` http method */ post(url: string, body: any, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `put` http method. */ put(url: string, body: any, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `delete` http method. */ delete(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `patch` http method. */ patch(url: string, body: any, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `head` http method. */ head(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `options` http method. */ options(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;; 6.1 我们来添加一个英雄；hero.service.ts中加入这一段： 12345678910/*注释1*/ private headers = new Headers(&#123;'Content-Type': 'application/json'&#125;); addHero(name:string):Promise&lt;Hero&gt;&#123; return this.http.post(this.heroUrl,JSON.stringify(&#123;name:name&#125;),&#123;headers:this.headers&#125;) .toPromise() .then( res=&gt; res.json().data as Hero ) .catch((error: any) =&gt; Promise.reject(error || 'Server error')); &#125; 注释1： 1import &#123;Http,Headers&#125; from '@angular/http'; 需要引入Headers，然后new 一个实例；但是这个参数是可选的；组件中怎么接收： 12345678910addhero:Hero; addHero(name:string)&#123; this.service.addHero(name).then( hero=&gt;&#123; this.addhero=hero; console.log(this.addhero); this.hero.push(this.addhero); /*将添加的数据Push进hero数组*/ &#125; ).catch((error: any) =&gt; Promise.reject(error || 'client error')) &#125; 一样的代码，就不过多解释；我们的英雄在哪里添加呢？肯定是要有一个input输入框的： 1234&lt;div&gt; add:&lt;input #heroName/&gt; &lt;button (click)="addHero(heroName.value);heroName.value=''"&gt;add&lt;/button&gt;&lt;/div&gt; 添加之后，可以看到控制台会有输出：但是界面显示的还是这些：Angular会自动检测数据的变换，当有数据变换时，会实时更新还有一些其他方法，自己去尝试下；hero.service.ts: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; Injectable &#125; from '@angular/core';import &#123; Http, Headers,Response&#125; from '@angular/http';import 'rxjs/add/operator/toPromise';import &#123; Hero &#125; from './hero';@Injectable()export class HeroService &#123; constructor(private http: Http) &#123; &#125; private heroUrl = 'api/heroes'; getHeroes(): Promise&lt;Hero[]&gt; &#123; return this.http.get(this.heroUrl) .toPromise() .then( this.extractData ) /*注释1*/ .catch((error: any) =&gt; Promise.reject(error || 'Server error'));/*注释2*/ &#125; getHero(id: number): Promise&lt;Hero&gt; &#123; const url = `$&#123;this.heroUrl&#125;/$&#123;id&#125;`; return this.http.get(url) .toPromise() .then(this.extractData) .catch(this.handleError); &#125; private headers = new Headers(&#123; 'Content-Type': 'application/json' &#125;); addHero(name: string): Promise&lt;Hero&gt; &#123; return this.http.post(this.heroUrl, JSON.stringify(&#123; name: name &#125;), &#123; headers: this.headers &#125;) .toPromise() .then(this.extractData) .catch(this.handleError); &#125; /** * * @param res 接收数据的方法 */ private extractData(res: Response) &#123; /*注释2*/ let body = res.json(); return body.data|| &#123;&#125;; /*注释3*/ &#125; /** * * @param error 处理错误的方法 */ private handleError(error: Response | any) &#123; return Promise.reject(error || 'Server error'); &#125;&#125; 注释1：将then()和catch()里面的部分提取出来，每次使用只需要调用方法即可；注释2：接收的Response记得将Response在Http对象中引入；注释3：这里接收的data其实是一个any型; 7. Observable对象Http服务中的每个方法都返回一个 HTTP Response对象的Observable实例；Observable 就是一个拥有以下特性的函数： 它接收一个 observer 对象作为参数，该对象中包含 next、error 和 complete 方法 它返回一个函数，用于在销毁 Observable 时，执行清理操作在 RxJS 中，返回的是 Subcription 对象，该对象中包含一个 unsubscribe 方法。一个 Observable 对象设置观察者 (observer)，并将它与生产者关联起来。该生产者可能是 DOM 元素产生的 click 或 input 事件，也可能是更复杂的事件，如 HTTP。当 Observable 对象产生新值的时候，我们可以通过调用 next() 方法来通知对应的观察者。若出现异常，则会调用观察者的 error() 方法。当我们订阅 Observable 对象后，只要有新的值，都会通知对应的观察者。但在以下两种情况下，新的值不会再通知对应的观察者：已调用 observer 对象的 complete() 方法消费者对数据不再感兴趣，执行取消订阅操作此外在执行最终的 subscribe() 订阅操作前，我们传递的值可以经过一系列的链式处理操作。执行对应操作的东西叫操作符，每个操作符执行完后会返回一个新的 Observable 对象，然后继续我们的处理流程。那么我们可以直接返回Observable给组件吗？我们可以看看，之前getHero()那一段如果直接改成返回Observable对象会如何；1234getHeroes():Observable&lt;Hero[]&gt;&#123; /*注释1*/ return this.http.get(this.heroUrl) .map(this.extractData); &#125; 注释1：不用调用toPromise()方法，自然也不用then()去取数据，而是直接返回Observable对象之后调用RXJS中的map操作符来从返回的数据中提取数据；所以你要引入：12import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/add/operator/map'; 操作符之后会讲到，注意和之前的promise方法对比；组件中怎么接收数据Observable对象呢？12345678getHeroes()&#123; this.service.getHeroes().subscribe( /*注释1*/ hero=&gt;&#123; this.hero=hero; console.log(this.hero); &#125; ) &#125; 这样显示的效果也是一样的；注释1：调用 subscribe() 方法，来获取最终的值，采取订阅的方式，而不是用then(); 8. Observabel和Promise 有什么不同8.1 两个都可以用于web API http的调用，但Observable是可以中途取消的，而Promise一旦触发就不能被取消；123setTimeout(() =&gt; &#123; this.service.getHero().unsubscribe(); &#125;, 1000); 8.2 因为Promise只能发起一次请求，只要接收到数据，就会算完成，所以Promise只能发射一个值就算结束，Observable可以连续发送好几个值，在服务器对第一个请求作出回应之前，再开始另一个不同的请求；1234567891011this.heroes = this.searchTerms .debounceTime(300) .distinctUntilChanged() .switchMap(term =&gt; term ? this.service.search(term) : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;);this.heroes.subscribe(value =&gt; console.log(value)); 这个后面代码操作符这块有详解； 8.3 Observable提供了很多的工具函数，最最最常用的filter和map；详细看看这两个map和filter； map() 操作符返回一个新的 Observable 对象 filter() 操作符执行过滤操作，然后又返回一个新的 Observable 对象最后我们通过调用 subscribe() 方法，来获取最终的值Filter:过滤器12345678getHeroes()&#123; this.service.getHeroes().filter(hero =&gt; hero.length &gt;= 2) .subscribe( hero=&gt;&#123; this.hero=hero; &#125; ) &#125; Map的用法上面有介绍；但是，使用承诺的方式能让调用方法更容易写，并且承诺已经在 JavaScript 程序员中被广泛接受了。再来看看Observable操作符：根据名字搜索用户：12345search(term: string): Observable&lt;Hero[]&gt; &#123; return this.http .get(`api/heroes/?name=$&#123;term&#125;`) .map(response =&gt; response.json().data as Hero[]); &#125; 看看组件代码：123456789 import &#123; Observable &#125; from 'rxjs/Observable'; /*注释1*/import &#123; Subject &#125; from 'rxjs/Subject'; /*注释2*/// Observable class extensionsimport 'rxjs/add/observable/of'; /*注释3*/// Observable operatorsimport 'rxjs/add/operator/catch'; /*注释4*/import 'rxjs/add/operator/debounceTime'; /*注释5*/import 'rxjs/add/operator/distinctUntilChanged'; /*注释6*/import 'rxjs/add/operator/switchMap'; /*注释6*/ 引入这些操作符：注释1：引入RXJS的可观察对象；注释2：Suject是一个可观察事件流中的生产者，通过调用Next()对象，可以将新观察的对象放入可观察流中；注释3：是Rxjs为Observable对象提供的扩展，注释4：异常操作符，拦截失败的可观察对象。注释5：相当于settimeout(),延迟；注释6：distinctUntilChanged确保只在过滤条件变化时才发送请求， 这样就不会重复请求同一个搜索词了；注释7：switchMap()会为每个从debounce和distinctUntilChanged中通过的搜索词调用搜索服务。 它会取消并丢弃以前的搜索可观察对象，只保留最近的；使用这个每触发一次事件都会引起一次Http()的调用，即使你使用延迟，但同一时间还是会有多个Http请求，并且返回的顺序不一定是请求发起的顺序；看看Http()方法调用：123456789101112131415161718 heroes: Observable&lt;Hero[]&gt;; private searchTerms=new Subject&lt;string&gt;(); // searchTerms生成一个产生字符串的Observable /*每当调用search()时都会调用next()来把新的字符串放进该主题的可观察流中*/ search(term:string):void&#123; this.searchTerms.next(term); &#125; ngOnInit(): void &#123; this.heroes = this.searchTerms .debounceTime(300) .distinctUntilChanged() .switchMap(term =&gt; term ? this.service.search(term) : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;);&#125; 看看代码：123456 &lt;div&gt; search :&lt;input #searchBox (keyup)="search(searchBox.value)"/&gt; &lt;div *ngFor="let b of heroes | async"&gt; &#123;&#123;b.name&#125;&#125; &lt;/div&gt;&lt;/div&gt; 为什么使用一个async管道呢？因为得到的是Observable对象，不是数组，*ngFor不能遍历可观察对象；效果：看完这个，大概知道：Observable（可观察对象）是基于推送（Push）运行时执行（lazy）的多值集合；关于操作符，我有话要说：大部分RxJS操作符都不包括在Angular的Observable基本实现中，基本实现只包括Angular本身所需的功能，也就是，你需要的大多操作符都需要从rxjs中引入； 9.上述的例子，其实说的都是关于web api,内存服务器的，占用内存的东西，速率都有点慢，如果你要从本地获取文件记住不要用这个；可以换用json文件获取： 创建一个heroes.json，记得放在assets文件下：{ “data”: [ { “id”: 1, “name”: “Windstorm” }, { “id”: 2, “name”: “Bombasto” }, { “id”: 3, “name”: “Magneta” }, { “id”: 4, “name”: “Tornado” } ]}我们app.module.ts里面的： InMemoryWebApiModule.forRoot(InMemoryDataService),不用引入，引入之后会默认使用web api；然后hero.service.ts中这样private heroesUrl = ‘assets/heroes.json’;其他的都是一样的；这种方式对于请求静态的本地数据是比较有用的；如果是请求真是的远程服务器地址，url换成远程地址就可以；]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular4 中自定义pagination组件]]></title>
    <url>%2Fangular%2Fpg-120170908%2F</url>
    <content type="text"><![CDATA[你用Angular 吗?一.介绍一个基于angular4 开发的可以分页的组件。组件的好处就是可以复用，复用…..作为一个前端码农，开始的分页功能实现是我用jquery写的，其他同事用的时候都要将我的代码拷贝过去，于是我被鄙视了。为了不继续被鄙视就开始了尝试。二.基本功能1.根据规定的每页数据条数，分页显示数据2.上下页操作数据直接上界面图可能清晰点： 项目截图根据图片进行讲解下：根据你总数据条数:totalNum; 每页显示条数:pageSize,通过组件会自动给你分页显示。eg：总数41 条数据,每页显示10条数据，则是分成5页。如果想每页显示7条，则会分成6页。三.简要代码架构目录图： 项目目录有两个组件：pagination和page;&nbsp; pagination是用来显示前面数据的，page是用来下面分页的。pagination.html示例代码： 数据显示部分代码ngb-xxx不用在意，是用的ng-bootstrap，只是为了让界面好看点。其实就是一个简单的table用来显示数据。*ngFor用来取数据，懂Angular 的人应该都会，这不是重点就不介绍了。&lt;page&gt;&lt;/page&gt;&nbsp;这里是引入page组件。但是传入了一些属性值；关于模板语法，依赖注入，自定义事件就不介绍了。只要知道这里是：pagination组件向page组件传入了几个值：pageSize(页面显示数据条数)，totalNum(总数据条数),curPage(当前页码 ），totalPage(总页码),pageData(每页显示数据)其中pageSize和pageData是一样的，只是后面为了操作，多传了一个值；那么：pageSize等值都是哪里来的呢，当然是pagination.ts里定义的： pagination.ts代码代码中的page就是你获得到得数据，自然totalNum就会等于数据的长度。依次算出来就好了。 pagination组件算是完成了，现在就来看看page是怎么接收到数据并进行操作的。page.html页面的代码： page.ts 分页数据的html其实很简单：就一个a标签显示条数，页数的，三个button,一个显示上一页，一个页数，一个下一页。每个按钮都绑定了一个changePage事件；看一下实现部分的代码： page.ts分页实现部分代码@Input是接收pagination.html组件传过来的数据。@Output是定义pagination.html页面定义的changeCurPage事件。通过三个if else判断，对传多来的数据进行处理。其实就分为：数据只够显示一页；数据显示到最后一页；数据刷新到中间页码；这三种情况下的操作。好了，基本就完成了。有些东西也是借助网友的想法，但是思路大致都是这样。现在我改变条数和数据量看看： &nbsp; 项目截图详情代码及效果：https://github.com/sulishibaobei/pagination]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular2+</tag>
        <tag>分页组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack初略学习]]></title>
    <url>%2Fwebpack%2Fwp-120170907%2F</url>
    <content type="text"><![CDATA[熟话说浓缩就是精华，哈哈，所以就这么简单粗暴的介绍下吧，写下的都是精华。 已经不是第一次听说webpack，但是我的起步有点晚，现在才看。开门见山~~ 1. 什么是webpack？webpack是当下最热门的前端资源模块化管理和打包工具（就是一个打包器），可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源，还可以将需要加载的模块进行代码分离，等到实际需要的时候再进行异步加载。通过loader的转换，任何资源都可以视作模块，如COMMONJS模块 ,AMD模块，JS CSS ,JSON 等 ，它会根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 2.为什么要有webpack等打包器？1.平常的模块加载方式都是在&lt;script&gt;标签里引入，这种情况是在全局作用模式window下的，这样做的弊端就是只能按&lt;script&gt;的书写顺序进行加载，而且全局作用域下容易产生冲突，引入数量比较多的文件情况下难以管理。2.而且，如果单独请求每个模块会造成请求次数过多，导致应用启动缓慢，但是，将所有文件压缩成一个文件，一次请求加载所有模块会导致流量的浪费，初始化过程缓慢。3.所以编译的时候对所有的代码进行静态分析，分析出各个模块的类型及依赖关系，然后将他们提交给适配的加载器处理，所以webpack就应运而生。 3.COMMONJS模块，AMD模块，CMD模块，UMD模块几种常用模块？Commonjs：允许模块通过require方法同步加载所需依赖的其他模式，然后通过exports或module.exports来导出需要暴露的接口。 1234eg： require("module"); require("./script.js"); export.doStuff= function ()&#123;&#125;; module.exports=someValue; 优点：各个模块可以进行重用，npm中已经有许多可供使用的包。缺点：只能是同步加载的，同步就意味着阻塞加载，所以不适合在浏览器环境中，因为浏览器的资源是同步加载的，不能非阻塞的并行加载多个模块。应用实例：nodejsAmd模块：它是在声明模块的时候就指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行依赖前置。 123eg: define("module", ["dep1", "dep2"], function (d1, d2)&#123; return someExportedValue; &#125;); require([ "module", "../file"], function (module, file) &#123; /* ... */ &#125;); 优点：适合异步加载模块，在浏览器环境中，并且可以并行运行多个模块。和commonjs相反。缺点：提前加好所有依赖，代码要复杂很多。应用实例：requirejs，curlCmd模块：和AMD类似，并和Commonjs也有很大的兼容性。 1234eg: define( function (require, exports, module)&#123; var $ = require('jquery'); var Spinning = require('./spinning'); exports.doSomething = ... module.exports = ... &#125;) 优点：容易在nodejs中运行你的代码缺点：依赖spm打包，模块的加载逻辑比较重、应用实例：Sea.jsUmd模块：主要解决模块定义的跨平台问题 123eg: import "jquery"; export function doStuff() &#123;&#125; module "localModule" &#123;&#125; 优点：容易进行静态分析，面向未来的ES标准；缺点：原生浏览器不支持。 4.如何使用webpack？假装你的电脑里面已经安装了Node.js, 然后输入：npm install webpack -g ,可以通过webpack -h来查看安装信息。(1)假装创建一个项目test,进入项目路径，创建一个index.html页面，代码如下图：(2)然后再创建一个名为：bundle.js的文件，在上图的index.html中引入它。此文件里面什么代码都不需要写。(3)在创建一个名为entry.js的文件，不需要在index.html页面引入哟，此文件里面用来写内容。document.write( “hello world”); (4)然后将entry.js打包进bundle.js文件中，webpack会分析入口文件，解析包含依赖关系的各个文件，然后打包到bundle.js中 webpack entry.js bundle.js webpack打包的原理就是给每一个模块都分配一个唯一的id并通过这个id索引和访问模块，启动时，会先执行entry.js里面的代码，其他模块会在运行require的时候执行。(5)此时打开bundle.js文件查看，你就可以发现里面已经 有代码了:(6)运行inde.html页面，在浏览器中就可以看到Hello world.但是webpack本身是只能处理javascript模块的，如果碰到css,json等其他模块文件，就需要使用loader转换。 loader就是一个装换器，一个可以输入任何资源但是最终都会帮你转成js模块的工具。总的来说loader有以下几点：1.管道方式链式调用（允许多个文件转换，最后必定输出js文件）。2.loader可以同步或异步执行3.倘若在nodejs环境下，可以做任何事情4.loader加载时可以接受传参。5.可以通过文件扩展名来绑定不同类型的文件。6.loader是通过Npm发布和安装。7.通过定义package.json来指定，同样也可以导出一个loader来使用，命名规则是：xxx-loader。一般是什么功能就命名什么。 下面就直接来试试：(1)在项目里面在新建一个名为：style.css的文件：输入body{ background:green}(2)修改entry.js;加入这一句require(“!style-loader!css-loader!./style.css”)(3)安装Loader.npm install css-loader style-loader先用css-loader读取它，再用style-loader将它插入页面中。(4)重新打包:webpack entry.js bundle.js(5)刷新index.html页面可以看到效果。如果有错误，cmd打包时就会显示，index.html运行时，fireug也会显示的。loader转换器还可以通过配置文件来执行哟(1)通过往package.json里面新增配置项来完成。deDependencies(2)在新配置个webpack.config.js文件 12345678910111213141516171819var webpack = require('webpack')module.exports = &#123; resolve: &#123; fallback: path.join(__dirname, "node_modules") &#125;, resolveLoader: &#123; fallback: path.join(__dirname, "node_modules") &#125;, entry: './entry.js', output: &#123; path: __dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\.css$/, loader: 'style!css'&#125; ] &#125;, plugins:[ new webpack.BannerPlugin('This file is created by yu') ]&#125; (3)直接运行webpack ，刷新index.html 就可以查看效果]]></content>
      <categories>
        <category>前端那些打包工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>CMD,COMMONJS</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑稽的下午--Angular 2+管道的使用]]></title>
    <url>%2Fangular%2Fpipe%2Fpipe-120170907%2F</url>
    <content type="text"><![CDATA[注:所有的angular 2+ 其实就包含了4,是向上兼容的； 让一个component组件里的时间显示当前时间并自动刷新。过程:1.首先获取当前时间 new Date();2.弄个定时器隔一秒刷新呀； app.component.ts中这样写到： 123456789101112131415161718InitialTime= new Date(); // 获取当前时间 data:string; getTime(m)&#123; // 判断获取的分钟数是否小于10，小于10只会显示一位数，前面自动补0 if (m&amp;lt;10 )&#123; m ="0"+ m; this .data= this .InitialTime.getHours()+":"+m; // 显示时间(小时+分钟) eg 17:15 &#125; else &#123; this .data= this .InitialTime.getHours()+":"+ this .InitialTime.getMinutes(); // 显示时间(小时+分钟) eg 17:15 &#125; &#125; constructor()&#123; this .getTime( this .InitialTime.getMinutes()); // 运行上面方法让时间显示 setInterval(()=&amp;gt;&#123; // 设置定时器，隔1秒刷新一次，好实时监控时间 this .InitialTime= new Date(); this .getTime( this .InitialTime.getMinutes()); &#125;, 1000 ); &#125; app.component.html中这样写： 1&amp;lt;span class="time"&amp;gt; &#123;&#123; date &#125;&#125;&amp;lt;/span&amp;gt; 然后变成我想要的效果了，可是代码我自己都嫌长，而且还是用传统js方法写的。后来就想不是angular里面有Pipe管道吗，是不是可以试试。app.component.ts是这样写的。 1234567time:any=Date.now(); // 获取当前时间 constructor()&#123; setInterval(() =&amp;gt;&#123; // 设置定时器，隔1秒刷新一次，好实时监控时间 // this.birthday = new Date(); this .time=Date.now(); // Date里面自带方法 &#125;,1000 ); &#125; app.component.html是这样写的： 1&amp;lt;span class="time"&amp;gt; &#123;&#123;time | date:"HH:mm" &#125;&#125;&amp;lt;/span&amp;gt; 注：|是管道标示符。angular里面提供了内置的datePipe管道可以供我们使用 HH：mm 表示输出小时和分钟；yy:MM:dd&nbsp; 表示输出年月日 详情可以看看官网的管道介绍里面关于DatePipe Api的介绍。 同样的效果，代码量就大大减少，所以学习还是在完成的基础上多尝试。耶~~~ 后续会有详细的关于管道学习的更多文章]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>pipe</tag>
        <tag>管道</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs+websocket实时聊天系统]]></title>
    <url>%2Fwb%2Fwb-120170907%2F</url>
    <content type="text"><![CDATA[介绍下websocket： webSocket协议本质上是一个基于tcp的协议; 建立一个websocket连接，大体的过程： 1.客户端浏览器首先向服务器发起一个http请求，这个请求和平常的请求有什么不同呢？ 多了一点附加头信息：”upgrade:web Socket” 表明我这申请的是一个websocket的http请求； 2.服务器收到请求后，解析这些附加的头信息，然后产生应答信息返回给客户端，这样，连接就建立了； 3.双方就可以通过这个连接通道自由的信息传递，这个连接会一直存在，直到一方自动关闭连接； 客户端到服务端：12345678GET /demo HTTP/1.1Host: example.comConnection: UpgradeSec-WebSocket-Key2: 12998 5 Y3 1 .P00Upgrade: WebSocketSec-WebSocket-Key1: 4@1 46546xW%0l 1 5Origin: http://example.com[8-byte security key] 服务端到客户端：123456HTTP/1.1 101 WebSocket Protocol HandshakeUpgrade: WebSocketConnection: UpgradeWebSocket-Origin: http://example.comWebSocket-Location: ws://example.com/demo[16-byte hash response] 从客户端到服务端请求的信息里面包含：‘Sec-webSocket-key1”,”Sec-WebSocket-key2”和“[8-byte security key]”这样的信息；这是客户端浏览器需要向服务端提供的握手信息，服务端解析这些头信息，并且在握手的过程中依据这些信息生成一个16位的安全密钥并返回给客户端，以表明服务器端获取了客户端的请求；大致步骤： 逐个字符读取 Sec-WebSocket-Key1 头信息中的值，将数值型字符连接到一起放到一个临时字符串里，同时统计所有空格的数量； 将在第 1 步里生成的数字字符串转换成一个整型数字，然后除以第 1 步里统计出来的空格数量，将得到的浮点数转换成整数型； 将第 2 步里生成的整型值转换为符合网络传输的网络字节数组； 对 Sec-WebSocket-Key2 头信息同样进行第 1 到第 3 步的操作，得到另外一个网络字节数组； 将 [8-byte security key] 和在第 3，第 4 步里生成的网络字节数组合并成一个 16 字节的数组； 对第 5 步生成的字节数组使用 MD5 算法生成一个哈希值，这个哈希值就作为安全密钥返回给客户端，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接 123456789101112131415161718var wsServer = 'ws://localhost:8888/Demo'; //连接地址var websocket = new WebSocket(wsServer); //建立连接websocket.onopen = function (evt) &#123; onOpen(evt) &#125;; //4个事件websocket.onclose = function (evt) &#123; onClose(evt) &#125;; websocket.onmessage = function (evt) &#123; onMessage(evt) &#125;; websocket.onerror = function (evt) &#123; onError(evt) &#125;; function onOpen(evt) &#123; console.log("Connected to WebSocket server."); &#125; function onClose(evt) &#123; console.log("Disconnected"); &#125; function onMessage(evt) &#123; console.log('Retrieved data from server: ' + evt.data); &#125; function onError(evt) &#123; console.log('Error occured: ' + evt.data); &#125; 浏览器的支持情况： 浏览器 支持情况 Chrome Supported in version 4+ Firefox Supported in version 4+ Internet Explorer Supported in version 10+ Opera Supported in version 10+ Safari Supported in version 5+ 正文来了：基于websocket制作的简单聊天系统；简单的界面，大致效果就是这样的： 实现逻辑代码：1234567891011121314151617181920212223242526var ws = new WebSocket('ws://127.0.0.1:8082'); ws.onopen = function (e) &#123; console.log("连接服务器成功"); &#125; ws.onmessage = function (e) &#123; value1.removeAttribute("readOnly"); var time = new Date(); mess.innerHTML += time.toUTCString() + ":" + e.data + "&amp;lt;br&amp;gt;"; document.getElementById("send").onclick = function (e) &#123; ws.send(input.value + "说:" + value1.value); value1.value = " "; &#125; document.onkeydown = function (e) &#123; e = e || window.event; if (e.keyCode == 13) &#123; document.getElementById("send").onclick(); return false; &#125; &#125; &#125; ws.onclose = function (e) &#123; console.log("服务器关闭"); &#125; ws.onerror = function () &#123; console.log("连接出错"); &#125; 连接地址：ws://127.0.0.1:8082&nbsp; 那是哪里来的呢？（注意http请求则是写成http://xxx,https请求则是https://xxx；ws当然是ws://xxx);wbsocket只是客服端，地址当然是从我们的服务端给的呀；服务端的搭建采用了一个这样的库： nodejs-websocket npm isntall -g nodejs-websocket 在js页面引入它 1234567891011121314151617 var ws = require("nodejs-websocket" ); ``` 3. 创建一个服务 ```javascript var server = ws.createServer(function (conn) &#123; conn.on('text', function (str) &#123; &#125;) conn.on("close", function (code, reason) &#123; console.log("关闭连接"); &#125;) conn.on("error", function (code, reason) &#123; console.log("异常关闭"); &#125;);&#125;).listen(8082);console.log("websocket连接完毕") websocket连接算是建立啦！下面展示下具体代码：client.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="bootstrap-3.3.7-dist/css/bootstrap.min.css" /&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script src="bootstrap-3.3.7-dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;style&gt; .kuang &#123; width: 600px; min-height: 50px; max-height: 296px; border: 1px solid; float: left; display: block; position: relative; overflow-y: scroll; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="jumbotron bg-dark"&gt; &lt;h1 class="jumbotron-heading"&gt;WebSocket chat,欢迎使用:&lt;/h1&gt; &lt;/div&gt; &lt;div class="input-group text-left"&gt; &lt;label&gt;输入用户名：&lt;/label&gt; &lt;input type="text" id="name" /&gt; &lt;button id="conn"&gt;连接&lt;/button&gt; &lt;button id="close"&gt;断开&lt;/button&gt; &lt;/div&gt; &lt;div class="input-group text-muted"&gt; &lt;div class="kuang" id="mess"&gt;&lt;/div&gt; &lt;/div&gt; &lt;hr class="featurette-divider"&gt; &lt;div class="input-group text-left"&gt; &lt;input type="text" class="value" id="value1" /&gt; &lt;button id="send"&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var input = document.getElementById("name"); var conn = document.getElementById("conn"); var close = document.getElementById("close"); var mess = document.getElementById("mess"); var value1 = document.getElementById("value1"); var pattern = /^[\u4e00-\u9fa5]&#123;2,10&#125;$/; close.disabled = true; if (window.WebSocket) &#123; conn.onclick = function () &#123; if (!pattern.test(input.value)) &#123; alert("名称不能为空且必须为中文"); return; &#125; var ws = new WebSocket('ws://127.0.0.1:8082'); conn.disabled = true; close.disabled = false; ws.onopen = function (e) &#123; console.log("连接服务器成功"); ws.send(input.value); input.setAttribute("readOnly", 'true'); value1.setAttribute("readOnly", 'true'); &#125; ws.onmessage = function (e) &#123; value1.removeAttribute("readOnly"); var time = new Date(); mess.innerHTML += time.toUTCString() + ":" + e.data + "&lt;br&gt;"; document.getElementById("send").onclick = function (e) &#123; ws.send(input.value + "说:" + value1.value); value1.value = " "; &#125; document.onkeydown = function (e) &#123; e = e || window.event; if (e.keyCode == 13) &#123; document.getElementById("send").onclick(); return false; &#125; &#125; &#125; ws.onclose = function (e) &#123; console.log("服务器关闭"); &#125; ws.onerror = function () &#123; console.log("连接出错"); &#125; close.onclick = function () &#123; ws.onclose(); ws.send(input.value + 'close' + "了连接"); input.removeAttribute("readOnly"); conn.disabled = false; close.disabled = true; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var ws = require("nodejs-websocket");console.log("开始建立连接...");var str1 = null, str2 = null, clientReady = false, serverReady = false;var a = [];var server = ws.createServer(function (conn) &#123; conn.on('text', function (str) &#123; a.push(str); if (!clientReady) &#123; if (a[0] === str) &#123; str1 = conn; clientReady = true; str1.sendText("欢迎你" + str); &#125; &#125; else if (!serverReady) &#123; if (str.indexOf('close') &amp;gt;= 0) &#123; a.splice(2,1); clientReady = false; str1=null; return; &#125; if (a[1] === str) &#123; str2 = conn; serverReady = true; str2.sendText("欢迎你" + str); str1.sendText(str + "在线啦，你们可以聊天啦"); return; &#125; &#125; else if (clientReady &amp;amp;&amp;amp; serverReady) &#123; str2.sendText(str); str1.sendText(str); if (str.indexOf('close') &amp;gt;= 0) &#123; a.splice(2, a.length); var len = a.length; for (var i = 0; i &amp;lt; len; i++) &#123; // 定位该元素位置 if (str.indexOf(a[i])&amp;gt;=0) &#123; a.splice(i,1); if(i==0)&#123; str1=str2; &#125; serverReady = false; str2=null; return; &#125; &#125; &#125; &#125; &#125;) conn.on("close", function (code, reason) &#123; console.log("关闭连接"); clientReady = false; serverReady = false; &#125;) conn.on("error", function (code, reason) &#123; console.log("异常关闭"); &#125;);&#125;).listen(8082);console.log("websocket连接完毕") 实现双人聊天，client.html开启两个窗口就行！详细代码在github]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 打卡的第一天]]></title>
    <url>%2Fgit%2Fgit-120170907%2F</url>
    <content type="text"><![CDATA[因为某种原因，所以不得不重新巩固下前端的基础知识，从最基本的学习还得额外的学习新知识，倍感压力之大。 昨天初略学习下git，算是自己学习的一个新知识。简单记录下，希望四海八荒的大神看过来，有错的请指导。 git下载安装git下载安装地址下载好之后记得配置环境变量。git的作用主要是将项目保存到git目录中 git介绍主要分为三个块：[1] working directory(工作目录） 本地上存放项目的目录。[2] staging area 暂存放区域 更新暂未提交的项目。[3] git directory git上存放项目的地方。1.一般我们使用git都会将一些修改的文件保存在暂存区域，然后一并提交更新到git目录中。2.安装好git之后，网页打开github，注册信息。登陆进去，接下来配置信息。3.打开右上角，如下图点击settings。然后点击SSH and GPG keys ,配置SSH。打开cmd或者git bash。找不到git.bash的就在开始那里搜索或者在你安装的git文件里面打开git.bash.exe就一样。4.在命令行输入：ssh-keygen -t rsa -C “你注册github时的邮箱名” 然后会提示你生产的key在id_rsa.pub文件中找。5.在电脑中一个叫.ssh的文件里，然后复制黏贴在右边的key框里面，title就随便打。 此时git的安装目录就为你的根目录。 配置用户信息：git config --global user.name &quot;你注册时的用户名&quot;;git config --global user.email &quot;你的邮箱&quot;;git里面提供了一个git config的命令专门用来配置或者读取相应的工作环境变量。这些变量可以存放在三个地方：etc/gitconfig文件， git config –system读写的就是此文件；~/.gitconfig文件，git config –global 读写的就是此文件；配置好信息后，可以通过git config –list 命令查看&nbsp;&nbsp; 如果git config user.name就是具体的查看某个环境变量的设定。若不知道如何使用git命令，可以git help看看。 git使用。 新建一个git 仓库，也可以导入一个本地项目。进入仓库 复制这个地址 然后打开cmd或者git.bash.exe， 输入git clone git@github.com:sulishibaobei/a.github.io.git （上面复制的这串地址) 就会在你的本地建立一个名为a.github.io的仓库，进入仓库，将你需要上传的代码拷贝进去 123git add *（*是上传所有的本件，若是想具体的就写文件名）git commit -m "version" 提交文件git push 这三步就完成git项目的提交。 可以用git status命令查看当前文件的状态。 所有的文件都可以先add到暂存区域，然后最后再一起commit。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>环境变量配置</tag>
        <tag>基本git操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css3雪碧图]]></title>
    <url>%2Fcss%2Fsp-120170907%2F</url>
    <content type="text"><![CDATA[Css雪碧图： CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。原理：CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。如何生成雪碧图？安装gulp插件： npm install –g gulp安装制作雪碧图需要的插件 npm install –g gulp.spritesmith最好全局和本地各装一遍； 新建一个Gulpfile.js文件，将下列代码放进去： 12345678910111213var gulp=require('gulp'); //引入这两个gulp gulp.spritesmith spritesmith=require('gulp.spritesmith'); gulp.task('default',function()&#123; //新建名为sprite的任务 gulp.src('images/*.png') //需要合成的图片路径 *为通配符 表示这个文件夹下面所有后缀为.png的文件都会被应用 .pipe(spritesmith(&#123; imgName:'sprite.png',//合成后需要保存图片的路径 cssName:'sprite.css', //合成后需要保存的css的路径 padding:5, //表示两个图片间的空隙 algorithm:'binary-tree', // Algorithm 有四个可选值分别为top-down、left-right、diagonal、alt-diagonal、binary-tree // cssTemplate:'dist/handlebarsStr.css' //生成的css模板文件，可以是函数也可以是字符串 &#125;)) .pipe(gulp.dest('dist/')) //将生成的文件放到dist文件夹下 &#125;) 或者:进入项目 npm init 输入需要的信息,创建一个package.json文件: 12345678910111213141516 &#123; "name": "package.json", "version": "1.0.0", "description": "", "main": "Gulpfile.js", "dependencies": &#123; "gulp": "^3.9.1", "gulp.spritesmith": "^6.5.1" &#125;, "devDependencies": &#123;&#125;, "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;amp;&amp;amp; exit 1" &#125;, "author": "", "license": "ISC"&#125; 这里提几点需要注意的：需要一个Gulpfile.js（首字母小写也可以） ，运行时执行 gulp default（defaullt是你新建的任务名，不是固定的，你写成其他也行）imgName:’sprite.png’//合成后需要保存图片的路径cssName:’sprite.css’这两个文件需要你先创建，里面的文件都要预先创建;我这里是放在dist下面就要在dis下面创建这两个文件合成的雪碧图；css样式： 123456789101112131415161718192021222324252627282930313233343536373839404142.icon-1 &#123; background-image: url(sprite.png); background-position: 0px 0px; width: 33px; height: 33px;&#125;.icon-2 &#123; background-image: url(sprite.png); background-position: -38px 0px; width: 33px; height: 33px;&#125;.icon-3 &#123; background-image: url(sprite.png); background-position: 0px -38px; width: 33px; height: 33px;&#125;.icon-4 &#123; background-image: url(sprite.png); background-position: -38px -38px; width: 33px; height: 33px;&#125;.icon-5 &#123; background-image: url(sprite.png); background-position: -76px 0px; width: 33px; height: 33px;&#125;.icon-6 &#123; background-image: url(sprite.png); background-position: -76px -38px; width: 33px; height: 33px;&#125;.icon-7 &#123; background-image: url(sprite.png); background-position: 0px -76px; width: 33px; height: 33px;&#125; algorithm：四个参数只是决定图片的排列顺序；top-down：具体的参数可以看这里：好了,雪碧图就合成啦；下面会讲讲如何使用雪碧图；创建一个文件：index.html引入生成的css1&lt;link rel=”stylesheet” type=”text/css” href=”./dist/sprite.css” /&gt; 写基本架构：class=”icon-1” 这里是css里生成的样式名；按顺序写好就行; 123456789101112131415161718192021222324252627282930&lt;ul class="sprite"&gt; &lt;li&gt; &lt;s class="icon-1"&gt;&lt;/s&gt; &lt;a href=""&gt;衣服&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-2"&gt;&lt;/s&gt; &lt;a href=""&gt;鞋子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-3"&gt;&lt;/s&gt; &lt;a href=""&gt;背包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-4"&gt;&lt;/s&gt; &lt;a href=""&gt;双肩包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-5"&gt;&lt;/s&gt; &lt;a href=""&gt;裤子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-6"&gt;&lt;/s&gt; &lt;a href=""&gt;羽绒服&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-7"&gt;&lt;/s&gt; &lt;a href=""&gt;外套&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; 给他们新增加一些样式： 1234567891011121314151617181920212223242526ul &#123; list-style: none; margin: 0; padding: 0;&#125;.sprite &#123; margin: 10px auto; width: 206px; border: 1px solid #b51600;&#125;.sprite li &#123; cursor: pointer; height: 42px; width: 206px; background-color: #b51600; border-bottom: 1px solid #911001; border-top: 1px solid #c11e08;&#125;.sprite li a &#123; color: #fff; line-height: 42px; font-size: 14px;&#125; 效果就是这样：引入了css文件，class也改动了，怎么没有图标呢？生成的css文件里面就告诉你了，让标签dispay:block; 12345.sprite li s&#123; display: inline-block; margin-left: 10px; margin-right: 8px; &#125; 看看效果：]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>雪碧图</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于个人博客的搭建]]></title>
    <url>%2Findex20170906%2F</url>
    <content type="text"><![CDATA[博客前生[博客基本搭建]http://www.cnblogs.com/sulishibaobei/p/6428241.html, 这是用的yilia主题之前是将博客托管在github上，运行http://sulishibaobei.github.io 即可以访问，如果你只是初步尝试，建议看这个，教你10分钟搭建一个属于自己的博客 博客今世1.在阿里云上购买了一个域名：www.sulishibaobei.com ,将域名解析到sulishibaobei.github.io上，现在我的博客访问地址就是www.sulishibaobei.com;这样访问http://sulishibaobei.github.io 将会重定向到http://www.sulishibaobei.com 上;2.给博客重新更换了主题：next;方法还是和之前更换yilia主题一样，github上将想要的主题下载好，放置在Themes文件夹下面,更换站点根目录的_config.yml文件下的theme: next3.hexo clean ,hexo g,hexo d ;这三步重新编译，这样你的博客就焕然一新了;不一定要是这两个主题，因为配置都是大同小异,只是因为Next里面继承了许多的功能比较全，像我这么懒惰的人就用它了; 博客最基本配置主题更换好以后，怎么让主题的功能更突出就需要操作主题里面的_config.yml文件了,是主题下的文件; 1.菜单栏menu的配置找到主题配置文件_config.yml中的的menu,大概是这样一段代码：123456789101112menu: 主页: / || home 关于: /about/ || user 标签: /tags/ || tags 归档: /archives/ || archive 展示: /site/ || th 日程: /schedule/ || calendar 有料 : /something 公益404: /404.html || heartbeatmenu_icons: enable: true blog:/images/1.jpg 注：你下载下来的是英文的,根据你的习惯,喜欢中文就切换成中文的;本来主题就提供了配置语言的,在next主题的languages里面,我们只需要配置即可；在根站点的_config.yml文件中配置language: zh-Hans表示你要使用的是中文,配置了这一句就不用像我这样手动修改;有可能你并不需要像我这么多项，根据自己的需求进行配置，其实就是将它#注释的地方去掉注释就行关于图标前面的图标,你不写的话，就会采用主题默认的,例如：有料;主题里为我们提供的几种图标，例如：home,tags等;还有一类是你自己想自定义图标，menu_icons就是配置图标的,例如blog,在需要使用图标的||后面写上blog;但是关出现这些标签，怎么让标签点击到对于的页面这就需要我们去创建应的文件夹hexo new page tags 创建的文件夹名和配置的名字标签: /tags是一样的;新创建的文件夹会出现在source文件下，和_post文件夹同级,默认的文件是index.md,其中会只有这两行代码：1234---title: tagsdate: 2017-09-05 14:45:27--- 按照所需的数量，依次创建完成好，最基本的菜单栏就完成了; 2.header和个人内容介绍的配置 这个是在站点根目录_config.yml配置的，在这个文件里面配置的内容即便更换主题，这些内容也不会改变，只是显示位置不一样；找到site 12345678# Site 网站title: 少女雨的博客subtitle: 爱生活爱远方爱自由更爱你description: 12级毕业生，南方姑娘，前端程序媛，前途堪忧的代码洁癖者;author: 少女雨email: 380571249@qq.comkeywords: "前端,js,jquery,javascript,html5,开发者,程序媛，typescript,angular，校园java醋虐者"language: zh-Hans 填上你的个人信息，这块就算完成了 3.标签页的配置Category &amp; Tag这块的配置也是在站点根目录_config.yml下的；1234#default_category: uncategorizedcategory_map: 分类tag_map: 标签archives_map: 日志 找到这一部分,配置就行,但是怎么和你博客的内容关联起来这需要这样配置：例如：想让标签和博客文章关联起来，找到source文件下的tags文件index.md文件，添加这一句：12345---title: date: 2017-09-01 11:07:25type: "tags"--- 告诉主题，你想关联tags其他的关于category_map等也是这样配置的;关于这一部分标签如何配置，建议参看这篇文章，戳这里 4. 社交连接,Rss,友链配置这一部分是在主题文件下的_config.yml里面配置：找到这一块rss:false：禁用 RSS，不在页面上显示 RSS 连接。留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。具体的链接地址：适用于已经烧制过 Feed 的情形。社交链接，找到这个social12345678910111213141516171819social: GitHub : https://github.com/sulishibaobei/ || github E-Mail : 380571249@qq.com || envelope weibo : http://weibo.com/xiaoyu051027/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo/ || weibo CSDN : http://blog.csdn.net/sulishibaobei/ CSDN 博客园 : http://www.cnblogs.com/sulishibaobei/ 简书 : http://www.jianshu.com/u/e6c53e37e95b/ #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false 根据你自己的想法，换上自己链接配置就行，图标和上面介绍的Menu是一样的；友链，找到这个links_title123456# Blog rolls 友情链接links_title: 友情链接#links_layout: block#links_layout: inlinelinks: Angular 4.x 修仙之路 : https://segmentfault.com/blog/angular4 填上自己的就行，配置多个在链接那里添加就行；基本上博客雏形就配置完成了; 5.基本配置还有一些关于主题选择，字体配置的小细节，请看 博客内容完善阅读量统计这部分是采用leanCloud实现的，推荐一篇写的好的文章,戳这里 访客量统计这部分采用不蒜子统计统计找到这一部分：123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt;本站访客数 site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 本站总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 本文总阅读量 page_pv_footer: 次 评论系统我才用的是有言评论，localhost时候会失败，但是采用http页面评论时会成功;配置看这里next如果你是Next主题5.1以上的版本，只需要注册，然后将Uid号填在主题文件下的_config.yml从多说不能用的时候，facebook也不能用，DISQUS，HyperComments是国外的，请求不一定会成功；使用畅言需要备案，除非你的网站备案了，否则也不行；来必力尝试过也不行，选择友言是比较合理的； 搜索服务和百度统计搜索采用的是：Local Search ;配置可以看这里 博客收录如何将让自己的博客在搜索引擎被搜索到：看这里 博客小功能如何点击的时候出现桃心，如何更换链接颜色等看这里 关于后续有一些基本的配置,很难一个一个写出来;如果看到其他的功能,而我没有写出来的，欢迎给我私信;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2+ 关于新版angular-cli的应用]]></title>
    <url>%2Fangular%2Fangular-cli%2Fangular-120170906%2F</url>
    <content type="text"><![CDATA[以前写过一个webstorm借助angular-cli搭建angular2.0项目的博客。 后来许久没有接触过angular，现在拾起来的时候发现已经更新，用法变了。所以来记录下，以免其他友看到照成误区。这也是说明一个道理，别人写下的东西你不一定适用，因为技术的东西说变就变，谁知道的。 [1]基于Node环境，安装angular-cli。&nbsp; 新版的已经变成安装@angular/cli。所以安装时：npm install -d @angular/cli 那么问题来了，一大堆错误，说缺少pathon和visual studio。还有说版本不兼容的，所以建议node的版本不要太高，也不用太低。第一次我用的7以上的版本说不支持。然后换成6.0以上也是不支持。最后换成6.9几用的好好的。并不是所有人的电脑安装都会出问题的。 既然说缺少pathon那就安装吧。推荐一个网友的解决办法，我也是参照这个解决的，就不重复啰嗦看这里;说到底会出错的原因都是因为npm是国外的，需要FQ，会有那么一丝丝不稳定。不过建议大家先安装cnpm在装，就什么问题都，没有了。npm install -g cnpmcnpm install -g @angular/cli ng命令安装好angular/cli之后，就可以用ng命令啦。例如：ng –version 查看版本号ng help 帮助 当然最重要的还是用它创建工程。ng new 工程名;然后会自动帮你创建所有的依赖，搭建成一个简单的模板，大概这样node-modules会自动帮你创建，只是耗时比较长，建议一次下载多次copy。运行项目试试，进入你的工程目录下，然后ng serve; 默认是开启localhost:4200的。所以浏览器里打开localhost:4200就可以啦。 这是最简单的项目啦，当然你可以继续创建命令 例如运行ng g c user 它是四个四个创建的，配套吗！！ 后续介绍一篇文章专门讲angular-cli的这些文件工程太大了，运行时可以打压，ng serve --prod --aot 也是可以的。好了就介绍这些基础的，其实后面的使用并没有改变太多啦之前在博客园中也介绍过关于在webstorm中如何开发angular项目，如果想在webstorm中使用，可以去看看目前我使用VScode ，觉得挺好的！！]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>Angular-cli</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试中遇见的那些纯js题]]></title>
    <url>%2Fjs%2Fjs120170905%2F</url>
    <content type="text"><![CDATA[js 定义类有哪些常用的方法？1.工厂方式12345678910111213function Car()&#123; var ocar=new Obejct; //不用括号 ocar.color='blue'; ocar.doors=4; ocar.showColor=function()&#123; this.color; &#125; return ocar;&#125;var car1=Car();var car2=Car();console.log(car1); //&#123;color: "blue", doors: 4, snowColor: ƒ&#125; f指的是function()console.log(car2); //&#123;color: "blue", doors: 4, snowColor: ƒ&#125; 注：1.调用此方法时，将创建新的对象，并赋予它所有的属性和方法。使用此函数可以创建两个属性完全相同的对象；2.我们可以通过给函数传递不同的参数来得到具有不同值得对象 12345678910111213function Car(color,door)&#123; var ocar=new Object; ocar.color=color; ocar.doos=door; ocar.showColor=function()&#123; console.log(this.color); &#125; return ocar;&#125;var car1=Car("red",5);var car2=car("blue",4);car1.showColor(); //red；car2.showColor(); //blue 在上面的两个例子中，每次创建一个Car()对象都会创建一个showColor()，意味着每个对象都有自己的showcolor()方法，但是实际上每个对象可以共享同一个函数，最后通过将函数的属性指向该方法* 123456789101112function showColor()&#123; console.log(this.color); &#125; function Car(color,door)&#123; var ocar=new Object(); ocar.color=color; ocar.doors=door; ocar.showColor=showColor; return ocar; &#125; var car1=new Car('red',4); car1.showColor(); 当然这里扯远了 2.构造函数方法这个和工厂方式差不多 1234567891011function Car(color,door)&#123; this.color=color; this.doors=door; this.showColor=function()&#123; console.log(this.color); &#125; &#125; var car1=new Car("red",4); var car2=new Car("blue",5); car1.showColor();//red car2.showColor();//blue 注：这种模式和工厂的方式区别在于，不用通过自己去New一个对象，而是使用this关键字；因为在调用构造函数时就已经创建了对象，而在函数内部只能通过this来访问此对象但是，它和工厂方式一样，每次调用对象都会创建自己的方法 3.原型方式该方式利用了对象的prototype属性，首先用空函数创建类名，然后所有的属性和方法都被赋予prototype属性； 12345678910function Car()&#123;&#125;Car.prototype.color="red";Car.prototype.doors=4;Car.prototype.showColor=function()&#123; console.log(this.color);&#125;var car1=new Car();var car2=new Car(); console.log(car1); 看看最后输出的是什么注：1.首先定义一个空函数，然后通过prototype属性来定义对象的属性；调用该函数时，原型的所有属性都会立即赋予要创建的对象，所有该函数的对象存放的对是指向showColor()的指针，语法上看起来都属于同一个对象；2.但是这个函数没有参数，不能通过传参来初始化属性，必须要在对象创建后才能改变属性的默认值；3.原型方式还有个很大的弊端；如果属性指向的是对象时： 12345678910111213function Car()&#123;&#125;Car.prototype.color="red";Car.prototype.doors=4;Car.prototype.arr=new Array('a',"b");Car.prototype.showColor=function()&#123; console.log(this.color);&#125;var car1=new Car();var car2=new Car();car1.arr.push('cc');console.log(car1.arr); //(3) ["a", "b", "cc"]console.log(car2.arr); //(3) ["a", "b", "cc"] 注：arr对象指向的是一个数组，这里用的是数组的引用值，Car的两个对象指向的都是同一个数组所以car1添加值以后，在car2中也能看到值；形式是这样的： 4.联合方式（构造函数+原型方式)1234567891011121314function Car(color,door)&#123; this.color=color; this.doors=door; this.arr=new Array("aa","bb"); &#125;; Car.prototype.showColor=function()&#123; console.log(this.color); &#125; var car1=new Car("red",4); var car2=new Car("blue",5); car1.arr.push("cc"); console.log(car1); console.log(car1.arr); // (3) ["aa", "bb", "cc"] console.log(car2.arr); //(2) ["aa", "bb"] 首先来看看car1对象注：1.car1和car2对象都有自己单独的arr属性，所以改变其中一个另一个并不会受影响2.此方式是用构造函数定义对象的非函数属性，用原型对象定义对象的方法 5.动态原型方式和混合模式相似，区别就是赋予对象方法的位置不一样； 12345678910111213141516function Car(color,door)&#123; this.color=color; this.doors=door; this.arr=new Array("aa","bb"); if(typeof Car._initialized =="undefined")&#123; Car.prototype.showColor=function()&#123; console.log(this.color); &#125;; Car._initialized=true; &#125;;&#125;var car1=new Car('blue',3);var car2=new Car('red',3);car1.showColor();car2.showColor();console.log(car1); 注：此方法是用一个标志来判断是否已经给原型赋予了此方法，这样可以保证该方法只被创建一次 6.混合工厂方式目的是创建假构函数，只返回另一种对象的新实例 123456789101112function Car()&#123; var ocar=new Object();//带括号 ocar.color="red"; ocar.doors=4; ocar.showColor=function()&#123; console.log(this.color); &#125; return ocar;&#125;var car1=new Car();var car2=new Car();car1.showColor(); //red 注：和工厂方式很像，不通的就是这是通过New运算符 7.对象直接量采用set get的方式 123456789101112var car1=&#123; color:"", getColor: function()&#123; console.log(this.color); //red return this.color; &#125;, setColor:function(color)&#123; this.color=color; &#125;&#125;car1.setColor('red');car1.getColor(); 8.定义函数对象1234567891011121314var car2=new Function(); //注意大写car2.prototype = &#123; color:"", getColor:function()&#123; console.log(this.color);//blue return this.color; &#125;, setColor:function(color)&#123; this.color=color; &#125;&#125;car2.prototype.setColor('blue');car2.prototype.getColor();console.log(car2.prototype);//&#123;color: "blue", getColor: ƒ, setColor: ƒ&#125; 也是运用上面的原型方式和混合工厂模式 js类继承的方法有哪些既然是继承，首先得有个父类 12345678910111213//定义一个动物类 function Animal(name)&#123; //给一个Name属性 this.name=name || 'Animal'; //实例方法 this.sleep=function()&#123; console.log(this.name+" 在睡觉")； &#125; &#125; //原型方法 Animal.prototype.eat=function(food)&#123; console.log(this.name + '正在吃' +food); &#125; 原型链继承核心： 将父类的实例作为子类的原型 12345678910function Cat()&#123;&#125;Cat.prototype=new Animal();Cat.prototype.name='cat';var cat=new Cat();console.log(cat.name); //catconsole.log(cat.eat('fish')); //cat正在吃fishconsole.log(cat.sleep()); //cat 在睡觉console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 注：使用的的原型方式；特点: 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法和原型属性，子类都能访问 简单，易于实现 缺点: 要想为子类新增方法和属性，必须要在new Animal()这样的语句指向之后，不能放在构造器中； 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 12var cat1=new Cat()console.log(cat1.name) //cat 构造继承 call（）123456789function Cat(name)&#123; Animal.call(this); this.name=name || 'Animal';&#125;var cat=new Cat('cat');console.log(cat.name); //catconsole.log(cat.sleep()); //cat 在睡觉console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 注：这里是调用不到eat原型方法的;特点: 解决了1中，子类实例共享父类引用属性的问题； 创建实例时，可以向父类传参； 可以实现多继承（call 多个父类对象); 缺点: 实例并不是父类的实例 只能继承父类的实例和方法，并不能继承原型属性和方法； 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承 instace核心： 为父类实例添加新特性，作为子类实例返回 12345678910 function Cat(name)&#123; var instace=new Animal(); instace.name=name || 'Animal'; return instace; &#125;var cat=new Cat();console.log(cat.name); //Animalconsole.log(cat.sleep()); //Animal 在睡觉console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点:不限制调用方法，不管是new 子类()还是子类(),返回的对象具有相同的效果；缺点:1.实例是父类的实例，不是子类的实例;2.不支持多继承 拷贝继承123456789101112 function Cat(name)&#123; var animal=new Animal(); for(var p in animal)&#123; Cat.prototype[p]=animal[p]; &#125; Cat.prototype.name=name || 'Tom'; &#125;var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点:支持多继承;缺点: 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 12345678910function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 1.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 2.既是子类的实例，也是父类的实例 3.不存在引用属性共享问题 4.可传参 5.函数可复用缺点：调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 1234567891011121314151617function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点:堪称完美缺点: 实现较为复杂 数组去重给定无序数组，要求去除数组中的重复数组，并且返回新的无重复数组ES6写法： 123var array=[1,2,3,5,2,4,1,9,8];Array.from(new Set(array));console.log(Array.from(new Set(array)));//(7) [1, 2, 3, 5, 4, 9, 8] ES5写法： 12345678910111213console.log(uniqueArray(array));//(7) [1, 2, 3, 5, 4, 9, 8]function uniqueArray(array)&#123; var hashmap=&#123;&#125;; var unique=[]; for(var i=0;i&lt;array.length;i++)&#123; //hasOwnProperty boolean 用于表示一个对象本身是否具有指定名称的属性值 if(!hashmap.hasOwnProperty([array[i]]))&#123; hashmap[array[i]]=1; unique.push(array[i]); &#125; &#125; return unique;&#125; js类多重继承的实现方法是怎么样的其实就是第二部分的代码；1.call/apply 123456789101112131415161718var s1 = function(name)&#123; this.name = name; //专门存放名字的&#125;var s2 = function(sex)&#123; this.sex = sex; //专门存放性别的的&#125;var s3 = function(age)&#123; this.age = age; //专门存放年纪的&#125;var Student = function(name, sex, age, score)&#123; s1.call(this, name); s2.call(this, sex); s3.call(this, age); this.score = score;&#125;Student.prototype.constructor = Student;var s = new Student('jack', 'male', '12', '100');console.log(s.name+" "+s.age+ " " + s.age+" "+ s.score);//jack 12 12 100 1.使用call()实现多重继承，核心就是用Function类的call方法去绑定新的类，使新的类实例化后的对象继承了该属性及方法2.这样我们就可以根据各个不同的功能模块分不同程序员独立开发，最后合并起来，实现了多重继承。3.但它的缺点是基类的方法只能定义在类中，这样在每次实例化的时候都会创建该方法，造成多余内存占用这也是我们上面的构造继承的缺点 2.原型链继承 1234567891011121314151617181920var s1 = function()&#123;&#125;s1.prototype.getName = function()&#123;alert(this.name)&#125;;var s2 = function()&#123;&#125;s2.prototype =new s1();s2.prototype.constructor = s2;s2.prototype.getSex = function()&#123;alert(this.sex)&#125;;var s3 = function()&#123;&#125;s3.prototype = new s2();s3.prototype.constructor = s3;s3.prototype.getAge = function()&#123;alert(this.age)&#125;;var s = new s3();s.name = 'jack';s.sex = 'male';s.age = '22';s.getName();//jacks.getSex();//males.getAge();//22 出现代码冗余，而且无法传递参数 3.混合模式继承就是将上面的两种方式进行结合，扬长避短； 12345678910111213141516171819202122232425var s1 = function(name)&#123;this.name = name;&#125;s1.prototype.getName = function()&#123;alert(this.name)&#125;;var s2 = function(sex)&#123;this.sex = sex;&#125;s2.prototype =new s1();s2.prototype.getSex = function()&#123;alert(this.sex)&#125;;var s3 = function(age)&#123;this.age = age&#125;s3.prototype = new s2();s3.prototype.getAge = function()&#123;alert(this.age)&#125;;var s4 = function(name, sex, age)&#123;s1.call(this, name);s2.call(this, sex);s3.call(this, age);&#125;s4.prototype = new s3();s4.prototype.constructor = s4;var s = new s4('jack', 'male', '25');s.getName();//jacks.getSex();//males.getAge();//25 1.属性用构造的方法，方法采用原型模式；大大提高了效率 js中的作用域是什么样子的变量作用域全局变量的作用域：全局，在代码定义的任何地方都是有定义的；局部变量和函数的参数只有在函数体内才有定义另外，局部变量的优先级要高于同名的全局变量，也就是说当局部变量与全局变量重名时，局部变量会覆盖全局变量； 123456var num = 1; //声明一个全局变量function func() &#123; var num = 2; //声明一个局部变量 return num;&#125;console.log(func()); //输出：2 注：声明局部变量时一定要使用var,否则，解释器会将该变量当做全局对象window的属性。 函数作用域在JavaScript中函数作用域（变量在声明它们的函数体以及这个函数体嵌套的任意函数体都是有定义的） 123456function func() &#123; console.log(num); //输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的 var num = 1; //声明num 在整个函数体func内都有定义 console.log(num); //输出：1 &#125; func(); JavaScript的函数作用域是指在在函数内声明的所有变量在函数体内始终是可见的，也就是说在函数体内变量声明之前就已经可用了作为属性的变量，当声明一个全局变量的时候，实际上是定义了全局对象window的一个属性 12var num = 1; //声明全变量num alert(window.num) //输出：1 声明的全局变量实际上就是声明了一个window对象的属性 js中的this指的是什么1.在全局作用域时：this指向window 1console.log(this === window); //true 因此,我们在全局作用域声明的变量也会指向this 123var x = 1;console.log(this.x);//1console.log(window.x);//1 2.当在函数中时,this指向调用函数的那个对象。 1234567var x = 0;function num()&#123; this.x = 1;&#125;console.log(this.x);//0num();console.log(this.x);//1 这里就是经常容易犯得错误，很多人觉得，当this已经在一个function之中时，其目前所处位置为当前的局部作用域，所以目前指向的应该是此函数 但是，如果你将这个函数实例化（new）之后，此函数将生成一个全新的环境，此时在此实例中的this也会随之发生变化，它将指向所在实例。首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代; 12345678num = "0";function setThis()&#123; this.num = "1";&#125;console.log(this.num);//"0"new setThis();console.log(this.num);//"0"console.log(new setThis().num);//1 另外，在我们写javascript的时候，我们通常还会有一种调用函数的方法，即为元素绑定事件，比如button.addEventListener(‘click’, fn, false)等，如果在fn里面需要使用到this的话，那么此时this指向事件处理元素，也就是button 3.作为对象调用时,this 指代上级对象 1234567function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 总之：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 call,apply,bind的区别是什么一般用来指定的this环境; 123456789var a=&#123; user:'少女雨', fn:function()&#123; console.log(this.user); &#125; &#125; var b=a.fn; b(); //undefined a.fn(); //少女雨 引言：运行b()得到的是undefined，其实和我们的this指向有关系;因为此时this指向的是b;而下面a.fn()为什么能输出来能，因为此时this指向的是我们的a;也就是常说的那句，this始终指向的是调用它的那个对象;虽然a.fn()能打印出我们的数据，但是并不是最科学的方式，这时候可以通过下面的方法：1.call():调用一个对象的一个方法，以另一个对象替换当前对象说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 12345678var a=&#123; user:'少女雨', fn:function()&#123; console.log(this.user); &#125; &#125; var b=a.fn; b.call(a); //少女雨 简单来说：通过在call方法，给定第一个参数；将b添加到哪个环境中，this就会指向那个对象；call方法除了第一个参数以外还能添加多个参数 12345678910111213var a=&#123; user:'少女雨', fn:function(a)&#123; console.log(this.user); console.log(a); //2 &#125; &#125; var b=a.fn; b(); //undefined a.fn(); //少女雨 b.call(a); //少女雨 b.call(a,2);//少女雨 2 这样就可以用作传参2.apply():应用某一对象的一个方法，用另一个对象替换当前对象。说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。apply方法和call方法相似，它也可以改变this指向； 12345678var a=&#123; user:'少女雨', fn:function()&#123; console.log(this.user); &#125; &#125; var b=a.fn; b.apply(a); //少女雨 同样的apply也可以有多个参数，但不同的是，第二个参数必须是一个数组， 123456789var a=&#123; user:'少女雨', fn:function(a)&#123; console.log(this.user); console.log(a); //10 &#125; &#125; var b=a.fn; b.apply(a,[10]); //少女雨 10 注意：如果call和apply的第一个参数是Null,那么this指向的是window对象； 123456789var a=&#123; user:'少女雨', fn:function(a)&#123; console.log(this); &#125; &#125; var b=a.fn; b.apply(null); //Window &#123;stop: function, open: function, alert: function, confirm: function, prompt: function…&#125; 3.bind() 和call,apply方法不同，但是都可以改变this的指向 12345678var a=&#123; user:'少女雨', fn:function(a)&#123; console.log(this.user); &#125; &#125; var b=a.fn; b.bind(a); 这里没有打印出数据；这就是bind和call,apply不同的地方，实际上bind返回的是一个修改过后的函数；你看： 12345var c=b.bind(a); console.log(c); /*function (a)&#123; console.log(this.user); &#125;*/ 若想打印出数据，需要再执行以下c();同样bind()也可以有多个参数，并且参数可以执行的时候再次添加，但注意，参数是按照形参顺序进行的；就是这样 12345678910var a=&#123; user:'少女雨', fn:function(a,b,c)&#123; console.log(this.user); //少女雨 console.log(a,b,c); //1 3 4 &#125; &#125; var b=a.fn; var c=b.bind(a,1); c(3,4); 总结：call和apply都是改变上下文中的this并立即执行这个函数，都可以添加多个参数，但是apply方法添加的参数必须是一个数组;bind方法可以让对应的函数想什么时候调用就什么时候调用，并且参数可以在执行时候添加 caller , callee和arguments分别是什么1.arguments:在函数调用时，会自动在该函数内部生成一个名为arguments的隐藏对象，该对象类似于数组，但又不是数组；可以用[]操作符获取函数调用时传递的实参,并不局限于函数声明的参数列表;表示被这拗口的话混乱了； 123456function obj()&#123; console.log( 'arguments instanceof Array? ' + (arguments instanceof Array) ); // arguments instanceof Array? false console.log( 'arguments instanceof Object? ' + (arguments instanceof Object) ); // arguments instanceof Object? true console.log(arguments); //Arguments(0) &#125; obj(); 我们通过控制台显示的数据还看：从打印的结果看，arguments是一个对象，并且里面还包含了callee，callee中又包含caller等属性；接下来，我们gia百年代码看看，让函数调用时，传递参数，而函数本身没有参数；123456function obj()&#123; console.log( 'arguments instanceof Array? ' + (arguments instanceof Array) ); // arguments instanceof Array? false console.log( 'arguments instanceof Object? ' + (arguments instanceof Object) ); // arguments instanceof Object? true console.log(arguments); //Arguments(0)&#125;obj('xiaonv','LOVE',23); 和上面的代码没有什么区别，只是obj传递了参数；很显然，Arguments包含了3个参数，也就是我们调用obj()时传递的；所以，也就是说为什么arguments是存储的实际传递给函数的参数呢，而不是函数声明的参数；2.callee上面的截图中，我们已经看到了callee的出现，可以看出，callee是arguments对象的一个成员，并且值就是为我们被执行的obj()方法；我们在obj方法中加入这一句： 1console.log(arguments.callee); 从而可知：arguments.callee是指向参数arguments对象的函数，在这里就是obj咯。3.caller又是哪个？记得上图也出现过，caller则是callee里的一个属性对象；该属性保存着调用当前函数的函数；注意：是调用，不仅仅包含闭包，如果没有父函数，则为null;所以上诉代码中，我们这样输出：1console.log(arguments.callee.caller); //null 因为obj方法没有父函数，所以为null；接下来，我们再看： 12345678910//父函数function parent()&#123; //子函数 function child()&#123; console.log(child.caller); &#125; child(); console.log(parent.caller); //null&#125; parent(); 看看输出结果：可以看到caller保存的是parent对象；这是因为child有一个父函数parent，并且在父函数中被执行child(); 而后一个parent没有父函数，所以为null；那这样看看： 12345678 //parent2调用了child2function parent2()&#123; child2();&#125;function child2()&#123; console.log(child2.caller);&#125; parent2(); 结果呢：看见区别了吗？ parent2调用了child2，但child2不是嵌套在parent2里的函数；所以只显示了child2();大概就是这样; 什么是闭包，闭包有什么用处相信很多人都会有这个困惑，闭包到底是什么？ 什么是闭包呢？闭包是有权访问另一个函数作用域的变量的函数简单点来说：javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数体内，而且，这些内部函数可以访问它们所在的内部函数中声明的所有全局变量，参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包； 作用域的作用这是理解闭包的第一步；前面已经介绍过作用域了，无非就是全局和局部；javascript语言的特殊之处，在于函数内部可以直接读取全局变量；其中内部函数中可以访问外部函数的变量，是因为内部函数的作用域链中包含了外部函数的作用域； 12345var n=999; function f1()&#123; console.log(n); //999 &#125; f1(); 而另一方面，函数外部是无法取到函数内部的值； 12345function f1()&#123; var n=999; &#125;f1();console.log(n); //n is not defined 还有一点要注意，函数内部声明变量时，一定要使用var命令，不然等于声明了一个全局变量，变量作用域会提升； 12345function f1()&#123; n=999;&#125;f1();alert(n); // 999 闭包的几种写法简单介绍下，和上面的定义类的几种方法其实就是闭包； 123456789function Circle(r) &#123; this.r = r; &#125; Circle.PI = 3.14159; Circle.prototype.area = function() &#123; return Circle.PI * this.r * this.r; &#125; var c = new Circle(1.0); console.log(c.area()); //3.14159 还有 1234567var Circle=&#123; "PI":3.14159, "area":function(r)&#123; return this.PI * r * r; &#125; &#125;; alert( Circle.area(1.0) );//3.14159 可以结合上面的例子简单理解下； 闭包的作用1.可以读取函数内部的变量，2.让这些变量的值始终保持在内存中；但是究竟怎么使用闭包才能读取到函数内的局部变量呢？ 1234567 function f1()&#123; var n=999; function f2()&#123; console.log(n); // 999 &#125;f2();&#125; 上面的代码，我在函数内部再定义了一个函数；f2被包含在f1内部了，所以可以访问f1内部的所有全局变量；但是f1去不能访问f2内部的局部变量；这就是js的“链式作用域”结构，子对象会一级一级的向上寻找所有父对象的变量，所以父对象的所有变量，对子对象都是可见的，反之则不成立；123456789 function f1()&#123; var n=999; function f2()&#123; console.log(n); &#125; return f2;&#125;var result=f1();result(); // 999 f2可以读取到f1的变量，那么将f2作为返回值，不久可以在f1中读取到它的内部变量了；但是如何将变量的值存在内存中呢？ 1234567891011121314function f1()&#123; var n=99; nAdd=function()&#123; //匿名函数 n+=1; //全局变量 &#125; function f2()&#123; console.log(n); &#125; return f2;&#125;var result=f1();result(); //99nAdd();result(); //100 这段代码中result实际上就是闭包f2函数，它一共运行了两次，第一次值是99，第二次是100；这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 闭包与this在闭包中使用this对象会导致一些问题；因为匿名函数的执行具有全局性，而this对象通常指向window对象；12345678910var name = "The window";var object = &#123; name:"My object", getNameFun:function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFun()); //"The window"（在非严格模式下） 但是，将其阿布作用域中的this对象保存在一个闭包能够访问的变量里，就可以让闭包访问该对象啦；12345getNameFun:function()&#123; var that=this; return function()&#123; return that.name; &#125;; 使用闭包注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 defineProperty,hasOwnProperty,isEnumerable 都是做什么用的?javascript中任何一个构造函数对有其对应的原型，我们可以给原型赋予一些我们想要的属性； 1234567891011121314function Gadget(name,color)&#123; this.name=name; this.color=color; this.whatAreYou=function()&#123; return 'I am a' + this.color + ' ' + this.name; &#125; &#125; Gadget.prototype.price=100; Gadget.prototype.rating=3; Gadget.prototype.getInfo=function()&#123; return 'Rating' +this.rating + ' ,price:' +this.price; &#125;; var newtoy=new Gadget('少女雨','black'); console.log(newtoy); 先看看输出结果：这里定义了一个Gadget类的实例 –newtoy对象，在这个对象中，我们可以访问对象内部以及其原型对象中的属性和方法；如果想要获得某个对象所有的属性列表，可以使用for-in循环；123for (i in newtoy) &#123; console.log(i+ '= ' + newtoy[i]);&#125; 可以得到这样的结果：12345678910name= 少女雨color= blackwhatAreYou= function ()&#123; return 'I am a' + this.color + ' ' + this.name; &#125;price= 100rating= 3getInfo= function ()&#123; return 'Rating' +this.rating + ' ,price:' +this.price; &#125; 这时候，如果我们想把原型中的属性过滤掉，就可以首先使用hasOwnProperty()来判断该属性是否属于原型对象内部的：1234for (i in newtoy) &#123; if(newtoy.hasOwnProperty(i)) console.log(i+ '= ' + newtoy[i]);&#125; 输出结果是这样的：12345name= 少女雨color= blackwhatAreYou= function ()&#123; return 'I am a' + this.color + ' ' + this.name;&#125; 需要注意以下几点： 只有那些可枚举的属性才会被显示出来(一般内建属性都是不可枚举的) 原型中的各个原型属性才会被显示出来，当然前提是它们是可枚举的； propertyIsEnumerable()用于测试该属性是否可枚举，对于所以的原型属性，propertyIsEnumerable()都会返回false，包括那些在for-in循环中可枚举的属性。console.log(newtoy.propertyIsEnumerable()) //false但如果propertyIsEnumerable()的调用是来自原型链上的某个对象，那么该对象中的属性是可枚举的。例如：newtoy.constructor.prototype.propertyIsNumerable(‘price’); //返回: ture 另外还有一个比较常用的isPrototypeOf()方法，这个方法告诉我们当前对象是否是另外一个对象的原型；1234567891011121314151617181920function Gadget(name,color)&#123; this.name=name; this.color=color; this.whatAreYou=function()&#123; return 'I am a' + this.color + ' ' + this.name; &#125; &#125; Gadget.prototype.price=100; Gadget.prototype.rating=3; Gadget.prototype.getInfo=function()&#123; return 'Rating' +this.rating + ' ,price:' +this.price; &#125;;function Human()&#123; this.name=name;&#125;Gadget.prototype=Human;var newtoy=new Gadget('少女雨','black');console.log(Gadget.isPrototypeOf(newtoy)); //falseconsole.log(Human.isPrototypeOf(newtoy)); //true 第一个输出false，因为newtoy是Gadget的一个实例，不是原型；第二个输出true，因为Human是Gadget的原型，所以也就是newtoy的原型； defineProperty是es5新加的给对象属性设置描述符的方法，使用的方式如下：Object.defineProperty(obj,prop,descriptor) //对象，属性，描述符基本的描述符有这三个： writable –是否为可写 configurable – 是否为可配置的 enumerable – 是否为可枚举的顾名思义，writable设置属性是否为可写，如果是false，那属性之后的修改将会无效configurable属性是否可配置，设置为false后，该属性不可被删除，也不可再更改为可配置的，但是可以从可写改为不可写enumerable 属性是否可枚举，如果是false，则属性不可枚举，不可枚举属性对 for … in语句和Ojbect.keys是不可见的123456789101112var o = &#123; name: 'xu'&#125;Object.defineProperty(o, 'name', &#123; writeable:false //不可写&#125;)Object.defineProperty(o, 'name', &#123; configurable:false &#125;)Object.defineProperty(o, 'name', &#123; enumerable: false&#125;) 对value的get/set方法采用的就是此方法； js常用的设计模式的实现思想，单例，工厂，代理，装饰，观察者模式等;什么是设计模式呢？设计模式是一种解决问题的方案，用于解决在软件设计过程中普遍存在的问题；学习设计模式是为了学习如何合理的整理我们的代码； 设计模式六要素单一职责原则：一个类只负责一个功能领域中相应的职责，或者可以定义为：就一个类而言，应该只有一个引起他变化的原因；单一职责原则要求一个类不能承担过多的职责，形成”超级类”。需要根据不同职责分为不同的类，从而降低类的复杂度，提高可阅读性，增加系统的稳定性；开闭原则：一个软件实体应该对扩展开发，对修改关闭，即软件实体应尽量在不修改原有代码的情况下进行扩展；里氏代换原则：所有引用父类的地方都必须能透明的使用起子类的对象；里氏代换原则要求在软件中一个基类能够替换为它的子类而不会因此任何异常。因此要求子类可以扩展父类的功能，但不能修改父类本身的非抽象方法；依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象，换言之，要针对接口编程，而不是针对现实编程；接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。接口隔离原则要求我们设计接口不应太大，接口应仅仅提供客户端需要的行为，在使用此原则时应注意接口的粒度，接口太小会导致接口泛滥，不利于维护，接口太大灵活性较差，使用不便；迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用；迪米特法则要求我们应该减少对象之间的交互，如果两个对象之间不必彼此之间直接通信，那么这两个对象就不应该发送任何直接的相互作用，当需要调用另一个对象的某一方法时，可以通过第三者来转发此调用。 几种常用设计模式单例模式作用：用来保证一个类只有一个实例，用来解决一个全局使用的类频繁的创建和销毁，从而节约系统资源； 12345678910111213141516var single = (function()&#123; var unique; function getInstance()&#123; // 如果该实例存在，则直接返回，否则就对其实例化 if( unique === undefined )&#123; unique = new Construct(); &#125; return unique; &#125; function Construct()&#123; // ... 生成单例的构造函数的代码 &#125; return &#123; getInstance : getInstance &#125;&#125;)(); 可以通过 single.getInstance() 来获取到单例，并且每次调用均获取到同一个单例。这就是 单例模式 所实现的效果。应用场景：适用于我们平常将代码封装起来，只暴露一个入口，从而避免全部变量被污染； 工厂模式概念：提供创建对象的接口，根据调用者的参数，生产相对应的产品；分类：简单工厂模式:使用一个类，通常为单体，来生成实例；复杂工厂模式：将其成员对象的实例化推到子类中，子子类可以重写父类接口方法以便创建的时候指定自己的对象类型。父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。简单工厂模式：123456789101112131415var XMLHttpFactory =function()&#123;&#125;; //这是一个简单工厂模式 XMLHttpFactory.createXMLHttp =function()&#123; var XMLHttp = null; if (window.XMLHttpRequest)&#123; XMLHttp = new XMLHttpRequest() &#125;else if (window.ActiveXObject)&#123; XMLHttp = new ActiveXObject("Microsoft.XMLHTTP") &#125; return XMLHttp; &#125; //XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。 var AjaxHander =function()&#123; var XMLHttp = XMLHttpFactory.createXMLHttp(); ... &#125; 复杂工厂模式：12345678910111213141516171819202122var XMLHttpFactory =function()&#123;&#125;; //这是一个抽象工厂模式XMLHttpFactory.prototype = &#123; //如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类 createFactory:function()&#123; throw new Error('This is an abstract class'); &#125;&#125;var XHRHandler =function()&#123;&#125;; //定义一个子类// 子类继承父类原型方法extend( XHRHandler , XMLHttpFactory );XHRHandler.prototype =new XMLHttpFactory(); //把超类原型引用传递给子类,实现继承XHRHandler.prototype.constructor = XHRHandler; //重置子类原型的构造器为子类自身//重新定义createFactory 方法XHRHandler.prototype.createFactory =function()&#123; var XMLHttp =null; if (window.XMLHttpRequest)&#123; XMLHttp =new XMLHttpRequest(); &#125;else if (window.ActiveXObject)&#123; XMLHttp =new ActiveXObject("Microsoft.XMLHTTP") &#125; return XMLHttp;&#125; 简单对象使用工厂模式会增加其系统的复杂度。所以工厂模式适用的场景只是对象的构建十分复杂，处理大量具有相同属性的小对象，需要依赖具体环境创建不同实例； 代理模式概念：把对一个对象的访问, 交给另一个代理对象来操作举一个例子：我们公司的补打卡是最后是要交给大boss来审批的，但是公司那么多人，每天都那么多补打卡，那大boss岂不是被这些琐事累死。所以大boss下会有一个助理，来帮忙做这个审批，最后再将每个月的补打卡统一交给大boss看看就行； 1234567891011121314151617181920// 补打卡事件var fillOut = function (lateDate) &#123; this.lateDate = lateDate;&#125;;// 这是bigBossvar bigBoss = function (fillOut) &#123; this.state = function (isSuccess) &#123; console.log("忘记打卡的日期为：" + fillOut.lateDate + ", 补打卡状态：" + isSuccess); &#125;&#125;;// 助理代理大boss 完成补打卡审批var proxyAssis = function (fillOut) &#123; this.state = function (isSuccess) &#123; (new bigBoss(fillOut)).state(isSuccess); // 替bigBoss审批 &#125;&#125;;// 调用方法：var proxyAssis = new proxyAssis(new fillOut("2016-9-11"));proxyAssis.state("补打卡成功");// 忘记打卡的日期为：2016-9-11, 补打卡状态：补打卡成功 应用场景：比如图片的懒加载，我们就可以运用这种技术。在图片未加载完成之前，给个loading图片，加载完成后再替换成实体路径。还有解决跨域问题都能采用代理模式； 观察者模式（发布订阅)概念：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。它需要一种高级的抽象策略，以便订阅者能够彼此独立地发生改变，而发行方能够接受任何有消费意向的订阅者。发布订阅流程： 确定谁是发布者(比如我的博客)。 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者。 发布消息，发布者需要遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 退订（比如不想再接收到这些订阅的信息了，就可以取消掉）这种其实很好理解，特别是我学习了框架之后，subscribe用来订阅；unsubscribe取消订阅； 还有更多设计模式；可以自行去了解下； 列举数组相关的方法一个简单数组：12345var mycars=new Arrat();mycars[0]='Sab';mycars[1]='Volvo';mycars[2]='BMW';console.log(mycars); 输出结果很简单，就是这样：从图可以看出数组有啥属性吧，length,construtor,prototype;现在主要来介绍数组的方法；看看如何使用：1&lt;button onclick="myage.forEach(myFunction)"&gt;点我&lt;/button&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var mycars=new Array(); mycars[0]='Sab'; mycars[1]='Volvo'; mycars[2]='BMW'; console.log(mycars); //["Sab", "Volvo", "BMW"] var myshops=new Array('小雨','haha'); console.log(myshops);//["小雨", "haha"] var mys=mycars.concat(myshops); console.log(mys);//["Sab", "Volvo", "BMW", "小雨", "haha"] var mybeds=new Array('床'); var mys=myshops.concat(mybeds,mycars); console.log(mys);//["小雨", "haha", "床", "Sab", "Volvo", "BMW"] //所以concat不止传入一个参数，和拼接顺序有关； mycars.copyWithin(1,0); console.log(mycars);//["Sab", "Sab", "Volvo"] //copyWiththin是用于数组内部的 var myage=[32,15,25,25]; function checkAdult(age)&#123; return age&gt;=18; &#125; console.log(myage.every(checkAdult));//false //every用于检测所有元素是否都符合条件，有一个不满足都会返回false；如果有一个返回false，则其余的并不会被检测；并外不能检测空数组；和 some方法相反，some方法一旦有满足条件就返回true； console.log(myage.filter(checkAdult));//[32, 25, 25] //filter输出的是符合检索的所有值，对空数组无效 console.log(myage.find(checkAdult)); //32 //find返回的是符合条件的第一个值，如果没有符合条件的就返回undefined，对空数组无效 //对于以上的检索方法都是传入一个检查条件 console.log(myage.findIndex(checkAdult));//0 //findIndex 顾名思义，返回的是符合条件的值的索引值，和上面的find类似；没有返回-1； mycars.fill('shaonvyu'); console.log(mycars);//["shaonvyu", "shaonvyu", "shaonvyu"] //fill 使用一个固定值来替换数组中所有的值，对空数组无效 function myFunction(item, index) &#123; console.log( "index[" + index + "]: " + item ); //index[0]: 32 index[1]: 15 index[2]: 25 index[3]: 25 &#125; //forEach用于调用数组中的每一个元素，并将元素给回调函数，有一个用于场景，点击的时候想获取每一个列表的值，但是使用for返回的总是只有最后一个，这时候可以试试forEach；对空数组无效; console.log(mycars.indexOf('Sab')); //-1 console.log(myshops.indexOf('haha')); //1 //indexof用来返回某个指定字符串首次出现在数组中的位置,按从左到右顺序索引的，如果想反过来就使用lastIndexOf；没有找到则返回-1； //但是上面的两个输出为什么第一个是-1,从直观感觉看，Sab这个值却是在mycars数组中；那是因为数组开始时new的一个空数组，Sab是我们后来加入进去的值，采用Indexof索引的是原始数组，所以找不到； var join=mycars.join(); console.log(join); //shaonvyu,shaonvyu,shaonvyu // join用于把数组中的所有元素转换成一个字符串，用,或者指定的符号进行分割；为什么输出是shaonvyu呢，因为上面的fill方法； console.log(myage.map(Math.sqrt)); //[5.656854249492381, 3.872983346207417, 5, 5] //map返回一个新的数组，数组中的值是经过函数调用返回的值，对空数组无效，按序处理 console.log(mys);//["小雨", "haha", "床", "Sab", "Volvo", "BMW"] console.log(mys.pop());//BMW console.log(mys);//["小雨", "haha", "床", "Sab", "Volvo"] //pop方法删除数组的最后一个元素，并返回被删除元素的值；会改变数组长度，shift方法用来删除数组的第一个元素，和pop相反； console.log(mys.shift()); //小雨 console.log(mys.indexOf('haha')); //0 console.log(mycars.push('Sab')); //4 console.log(mycars);//["shaonvyu", "shaonvyu", "shaonvyu", "Sab"] //push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。新增的元素被添加在末尾;改变了数组长度，如果想在开始位置添加，使用unshift方法;都是返回新的长度 function getSum(total,age)&#123; return total + age; &#125; console.log(myage.reduce(getSum));//97 // reduce 只返回一个值，从左到右开始计算，作为一个累加，如果想从右到左，使用reduceRight方法，功能一样 console.log(myshops.reverse()); //["haha", "小雨"] console.log(myshops);//["haha", "小雨"] //reverse 反序输出数组，将数组顺序颠倒； console.log(mys);//["haha", "床", "Sab", "Volvo"] console.log(mys.slice(1,3)); //["床", "Sab"] //slice方法从已有数组中返回指定的部分，并返回出来，输出的是索引，取前不取后；不改变原始数组 console.log(mys);//["haha", "床", "Sab", "Volvo"] mys.splice(2,0,"HRE","DDD") console.log(mys);//["haha", "床", "HRE", "DDD", "Sab", "Volvo"] //splice() 方法用于插入、删除或替换数组的元素。会改变原始数组 console.log(myage.sort()); //[15, 25, 25, 32] var a=[-1,3,45,8,35]; console.log(a.sort()); //[-1,3,45,8] //sort对数组内的字母或数字进行排序，并按升序或者降序，默认是升序；这个方法会改变原始数组;注意不能对还有负数的数组进行排序 console.log(mys.toString())//haha,床,HRE,DDD,Sab,Volvo //tostring是最常用的， 可把数组转换为字符串，并返回结果。数组中的元素之间用逗号分隔。 console.log(mycars.valueOf()); //["shaonvyu", "shaonvyu", "shaonvyu", "Sab"] //valueOf返回数组的原始值，和mycars输出的值一样，原始值指的是Array 对象派生的所有对象继承出来的值，不改变数组长度 以上就是所有的数组方法了； 列举与字符串相关的常用方法首先应该知道字符串就是一个或多个排列在一起的字符，放在单引号或双引号之中。12 var str="abcdfe";console.log(str.length);//6 字符串只有一个属性，就是length；常用的多一些方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344var str="abcdfe"; console.log(str.length);//6 console.log(str.charAt(2)); //c //charAt(n) 传入的是一个索引值，如果不在 0~str.length-1之间，则返回一个空字符串 console.log(str.charCodeAt(2));//99 //charCodeAt() 用法和charAt一样，只是返回的是指定位置的Unicode值, fromCharCode()将unicode值转成字符串 var str1="fdrref"; var a=str.concat(str1); console.log(a)//abcdfefdrref //concat 连接两个或多个字符串，返回连接后的字符串 console.log(str.indexOf('c'));//c //indexof返回 substr 在字符串 str 中首次出现的位置,从 start 位置开始查找，如果不存在，则返回 -1。start可以是任意整数，默认值为 0。如果 start &lt; 0 则查找整个字符串（如同传进了 0）。如果 start &gt;= str.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，此时返回 str.length.从最后一个位置查找lastIndexOf() console.log(str1.localeCompare(str));//1 //localCompare用本地特定的顺序来比较两个字符串，大于返回1，小于返回-1 console.log(str.match(/ab/)) //["ab", index: 0, input: "abcdfe"] //match 返回一个包含匹配结果的数组，如果没有匹配项，则返回 null。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象,返回一个数组 console.log(str.replace('a','love'));//lovebcdfe //replace str.replace(regexp|substr, newSubStr|function) 替换 str 的子字符串 不改变原始字符串 console.log(str);//abcdfe console.log(str.search(/d/)); //3 //search() 查找 str 与一个正则表达式是否匹配。如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引；否则，返回 -1。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象 console.log(str.slice(3,-1))//df //slice 返回从 start 到 end （不包括）之间的字符，可传负值; console.log(str.split('b')); //["abcdfe"] console.log(str.split('b'));//["a", "cdfe"] //split 返回一个数组，分隔符 separator 可以是一个字符串或正则表达式,把字符串分割为子字符串数组 console.log(str);//abcdfe console.log(str.substr(4,2)); //fe // 返回 str 中从指定位置开始到指定长度的子字符串，start可为负值,第一个表示索引，第二个表示长度 console.log(str.substring(2,5));//cdf //提取字符串中两个指定的索引号之间的字符 都是取前不取后 console.log(str.toLocaleLowerCase()); //abcdfe console.log(str.toLocaleUpperCase()); //ABCDFE //toLocaleLowerCase()根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射，toLocaleUpperCase()反之 console.log(str.toLowerCase());//abcdfe console.log(str.toUpperCase()); //ABCDFE //将指定字符串转换成小写或者大写 console.log(str.toString());//abcdfe //tostring 返回字符串对象值 var a=" fdfde dffd "; console.log(a.trim()); //fdfde dffd //trim移除字符串首尾空白，中间的不移除 console.log(str.valueOf());//abcdfe //返回某个字符串的原始值，和直接输出一样 好了，所有的字符串的方法都在这里呀； 判断一个字符串中出现次数最多的字符，统计这个次数12345678910111213141516171819202122232425262728var str = 'asdfdffhwfeuwdasdsaaaaaaaa'; var json = &#123;&#125;; //遍历str拆解其中的每一个字符，将其中某个字符得到值及其出现的次数拿出来作为json的key和value for (var i = 0; i &lt; str.length; i++) &#123; //判断json中是否有当前str值 if (!json[str.charAt(i)]) &#123; //如果不存在，就将当前值添加到json中去； json[str.charAt(i)] = 1; &#125; else &#123; //else的话就让数组中已有的当前值的index值++； json[str.charAt(i)]++; &#125; &#125; console.log(json); //储存出现次数最多的值和次数 var iMax = 0; var iIndex = ''; //遍历json 使用打擂算法统计需要的值 for (var i in json) &#123; //如果当前项大于下一项 if (json[i] &gt; iMax) &#123; //让当前值更改为出现次数最多的值 iMax = json[i]; iIndex = i; &#125; &#125; //打印最终结果 console.log ('出现最多的值是'+ iIndex+ '出现的次数为'+iMax); //出现最多的值是a出现的次数为10 看看json 里面存入的值： 编写一个方法，求一个字符串的字节长度123456789101112var str="22来那个"; console.log(getStrlen(str)); //3 5 function getStrlen(str)&#123; var json=&#123;len:0&#125;; var re=/[\u4e00-\u9fa5]/; for(var i=0;i&lt;str.length;i++)&#123; if(re.test(str.charAt(i)))&#123; json['len']++; &#125; &#125;; return json['len']+" "+str.length; &#125; 关于里面的正则表达式，可以看这里 JavaScript中如何检测一个变量是一个String类型？请写出函数实现12typeof(obj)=='string';obj.constructor==String; 说到数据类型，补充一点：1234console.log(typeof null);console.log(typeof &#123;&#125;);console.log(typeof []);console.log(typeof undefined); 结果：1234objectobjectobjectundefined 给String对象定义一个repeatify方法。该方法接收一个整数参数，作为字符串重复的次数，最后返回重复指定次数的字符串例如：console.log(‘hello’.repeatify(3));输出：hellohellohello.12345678String.prototype.repeatify=String.prototype.repeatify || function(times)&#123; var str=''; for(var i=0;i&lt;times;i++)&#123; str+=this; &#125; return str;&#125;console.log('hello'.repeatify(3)) //hellohellohello 下面这段代码的结果是什么？为什么？123456789function test()&#123; console.log(a); //undefined console.log(foo()); //2 var a=1; function foo()&#123; return 2; &#125; &#125; test(); 变量和函数的声明都被提前至函数体的顶部，而同时变量并没有被赋值；因此，当打印变量a时，它虽然存在于函数体，仍然是Undefined; 怎么添加，移动，移除，复制，创建和查找节点？1)创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点2)添加，移除，替换，插入appendChild() //添加removeChild() //移除replaceChild() //替换insertBefore() //插入3)查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值getElementById() //通过元素Id,唯一性；现在还有一个通用的：querySelector() //可以是类名，id名，标签名； jQuery的事件委托方法on,live,delegate以及bind之间有什么区别?随着Dom结构的复杂化，有许多新的元素动态的添加进来，直接用click事件会发现新添加的元素并不能直接取到，这里就需要用到事件委托的方法；什么是事件委托呢？假定有一个dom结构是这样的body&gt;div&gt;a，如果点击a标签，click事件会从a一直冒泡到div和body,因此，发生在a上面的单击事件，div和body同样也可以处理，就可以是事件委托。具体来说，事件委托是事件目标本身不处理事件，而是将事件交于其父元素或者祖先元素处理，甚至根元素(document)；先直接看看代码：1.bind:作用是在选择到得元素上绑定事件类型的监听函数，bind(type,[data],function(eventObject))type:事件类型，如click，change,mouseover等；data:传入监听函数的参数，通过event.data取到，可选;function:监听函数，可传入event对象，这里的event是jquery封装的event对象，与原生的event对象有区别，使用时得注意；源码：bind:function(types,data,fn){ return this.on(types,null,data,fn);}这里其实也是调用了on方法；bind的特点就是会把监听器绑定到目标元素上，有一个绑一个，在页面上的元素不会动态添加的时候使用它没什么问题。但如果列表中动态增加一个“列表元素5”，点击它是没有反应的，必须再bind一次才行。2.livelive(type,[data],fn)源码：live:function(types,data,fn){ jQuery(this.context).on(types,this.selector,data,fn); return this;}可以看到Live方法并没有将监听器绑定到自己身上；而是绑定到this.context上，Live正是利用了事件委托机制来完成事件监听处理，把节点都委托给了document，添加新的元素不必再绑定一次监听；缺点也是有的：默认把事件绑定到$(document)元素，如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失；只能放在直接选择的元素后面，不能在连缀的DOM遍历方法后面使用；即$(“#table td”).live…可以，但$(“#table”).find(“td”).live…不行；而且$()函数会找到当前页面中的所有td元素并创建jQuery对象，但在确认事件目标时却不用这个td元素集合，而是使用选择符表达式与event.target或其祖先元素进行比较，因而生成这个jQuery对象会造成不必要的开销;解决的办法就是在$(document).ready()方法外部调用.live()，使其形成一个闭包，例如123(function($)&#123; $("table td").live("click",function()&#123;/*显示更多信息*/&#125;);&#125;)(jQuery); 3.delegate为了解决bind方法的局限性，jquery1.3引入了live方法，而后为了解决”事件传播链过长”问题，jquery1.4方法又指定了上下文，而为了解决无谓生成元素集合问题，jquery1.4.2引入了delegate；将监听事件绑定在就近的父级元素上，源码:delegate: function( selector, types, data, fn ) {return this.on( types, selector, data, fn );}是这样使用的：$(“table”).delegate(“td”,”click”,function(){/显示更多信息/});直接将目标元素选择符(‘td’),事件(‘click’)以及处理程序与’受施方’(table)绑定在一起了； 4.onon(type,[selector],[data],fn)参数和delegate差不多，但是有细微区别;type和select换了位置，其次，select变成了可选项；而且与bind的效果一样，event.currenttarget对象是自己；]]></content>
      <categories>
        <category>前端面试题整理</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
        <tag>字符串,数组,设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述alert和console.log的区别]]></title>
    <url>%2Fjs%2Fconsole20170905%2F</url>
    <content type="text"><![CDATA[生活中还是得有发现美好和差别的眼睛, 学习前端那么久既然还不知道alert和console.log的差别;本菜鸟一直以为alert和console.log其实是一样的用法，只是alert以弹出框形式呈现，而console.log在控制台输出而已。只到道昨天输出一段代码，结果发现alert和console.log输出结果不一样,本宝宝可算涨见识了, 然后就是各种查阅资料，百度查看，终于发现点眉目啦 ; 我写了这样一段代码：alert输出的结果为：console.log输出的结果为： 然后我就尴尬了 [1]原来console.log() 可以打印任何类型的数据。而 alert() 只能输出string，[2]如果alert输出是对象会自动调用 toString() 方法。如果想 console.log() 输出的与alert相同，需要调用 toString()。[3]所以将后面的改写成&nbsp;console.log(hmac.toString()) 就可以啦 下面再来总结下两者的差别123456789101112alert() 1.1 有阻塞作用，不点击确定，后续代码无法继续执行 1.2 alert()只能输出string,如果alert输出的是对象会自动调用toString()方法 e.g. alert([a,b,c]); //a,b,c 1.3 alert不支持多个参数的写法,只能输出第一个值 e.g. alert(1,2,3); // 1console.log() 2.1 在打印台输出 2.2 可以打印任何类型的数据 e.g. console.log([a,b,c]); //[a,b,c] 2.3 支持多个参数的写法 e.g. console.log(1,2,3) // 1 2 3 好啦~~~就是这样啦。]]></content>
      <categories>
        <category>前端那些微小事</category>
      </categories>
      <tags>
        <tag>console.log</tag>
        <tag>alert</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2+ 设置组件样式的那些事]]></title>
    <url>%2Fangular%2Fstyle%2Fcomponent-style20170902%2F</url>
    <content type="text"><![CDATA[你用Angular吗？ 介绍 :如何只改动最简单的css代码，呈现完全不一样的视图效果。第一种：最基本的设置： 图1 代码图2 界面运行效果图平常，想给一个label或者p等标签添加样式，我们就是这样操作，在Angular中也是一样的。现在，如果我想要将字体换成红色呢，首先想到的就是去修改.label里的color属性值，可如果样式表是封装的或者外部引用的，不方便修改呢？这时候就要用到ElementRef 和Renderer2了。可以去Angular 官网里搜索哟。&nbsp; renderer.class 图### 第二种:我们可以这样用&nbsp; label.html&nbsp; label.ts当然ElementRef和renderer2都引用自@angular/core库里面的。 至于ViewChild 和ngAfterViewInit()可以自行去了解。&nbsp;&nbsp;&nbsp; 修改效果图 当然，你说这样修改的弊端有没有呢？肯定是有的，因为，this.el.nativeElement获取的是当前元素，如果用*ngFor生成了一系列的label的话，它只会给你修改第一个label的。那有没有其他的办法可以修改呢。当然也是有的！ 第三种：我们可以获取到元素的节点进行操作? &nbsp; label.ts 获取元素节点，还是用上面的elementref。 如果要改变所有的，For循环皆可以啦。可是，这样做又有问题了？如果想不同的label不同字体颜色怎么办呢？当然Angular也提供了方法呀？ ngStyle和ngClass可以用呀！ &nbsp;ngStyle [ngStyle]=”{color:’&nbsp; ‘}”&nbsp; 和[style.color]是一样的意思。你的label想变成什么颜色，你就给我传那个值进来，0就是green……这种适用于只需要修改少量属性的标签。如果你需要修改颜色，字体大小，间距….这种方式显然太繁琐，这时候ngclass就来了。&nbsp;ngclass注意ngClass后面的字样。label为什么没有用单引号呢，而后面的text-primary却有呢？.label是一个变量，我们的样式是可以传参的。也就是你的html标签不需要改动，需要什么样式就在ts离传入即可。ngClass也可以利用这个特性去修改。其实这几种用的地方也挺多的，不过得根据实际需求去采用不同形式。欢迎来找我交流Angular 或前端技术哟。]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>ngStyle</tag>
        <tag>ngClass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2+ 路由的那些事]]></title>
    <url>%2Fangular%2Froute%2Ftitle20170901%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路由的作用就是（导航）：会加载与请求路由相关联的组件，并获取特定路由的相关数据，这允许我们通过控制不同的路由，获取不同的数据，从而渲染不同的页面； 几种常见的路由配置：Angular路由器是一个可选的外部Angular NgModule ，叫RouterModule;路由器里面包含多种服务(RouterModule)，多种指令（RouterOutlet，RouterLink,RouterLinkActive），和一套配置（Routes）; 123456789import &#123; RouterModule&#125; from '@angular/router'; RouterModule.forRoot([ &#123; path: 'test', component: TestComponent &#125; ]) &lt;a routerLink="test"&gt;Test&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; 详细解析：路由定义包括下面部分： [1] Path:路由器会用它来匹配浏览器地址栏中的地址，如’test’; [2] Component:导航到此路由时，需要加载的组件；注意，path不能以斜杠（/）开头。 路由器会为解析和构建最终的URL，这样当我们在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。 另外： 这里用到了RouterModule对象为我们提供的两个静态方法：forRoot()和forChild() 来配置路由信息； forRoot()方法提供了路由需要的路由服务提供商和指令，并基于当前浏览器 URL 初始化导航；用于在模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令； a标签中的routerLink 指令绑定一个字符串，字符串是path路径中配置的字符串，它将告诉路由器，当用户点击这个链接时，应该导航到哪里； 当然routerLink还可以绑定一个数组，就是我们的带参路由,下面会具体介绍的：1&lt;a [routerLink]="['/test', id]"&gt;test&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以在上面这样配置添加一个routerLinkActive指令, 我们需要让用户知道哪个路由处于激活状态，通常情况下我们通过向激活的链接添加一个 class 来实现该功能,然后我们写一个active的类:1234&lt;a routerLink="test" routerLinkActive="active"&gt;test&lt;/a&gt; .active&#123; color：red &#125; &nbsp;&nbsp;&nbsp;&nbsp;当此路由被点击时，字体会变成红色；这也是routerLinkActive的作用，使我们知道哪个路由处于激活状态；当然还可以添加上这个[routerLinkActiveOptions]=”{exact: true}” 只有当路由完全一样时，才会将active类加载上去：1&lt;a routerLink="dashboard" routerLinkActive="active" [routerLinkActiveOptions]="&#123;exact: true&#125;"&gt;Dashboard&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;chrome控制台这样显示：&nbsp;&nbsp;&nbsp;&nbsp;可见routerLink还是会自动将路由链接到href上的；class=”active“也作用上去啦；当切换路由时：class=”active” 移到我点击的路由上，只是应该是调用了：ngAfterContentInit(),ngOnChanges(),ngOnDestroy() 注意：第一个路径片段可以以 / ，./ 或 ../ 开头： 如果以 / 开头，路由将从根路由开始查找 如果以 ./ 开头或没有使用 / ，则路由将从当前激活路由的子路由开始查找 如果以 ../ 开头，路由往上一级查找1&lt;a [routerLink]="['../test', id]"&gt;test&lt;/a&gt; 当然这里我们也可以通过在component里控制写:123456import &#123;Router&#125; from '@angular/router';&lt;a (click)="go()"&gt;Heroes&lt;/a&gt;constructor(private router: Router) &#123;&#125;go() &#123; this.router.navigate(['heroes']);&#125; 这种效果也是一样的；这里就需要注入router服务：router方法用于切换路由很有用，下面会具体来介绍router服务的； 路由出口:RouterOutlet是由RouterModule提供的指令之一。当我们在应用中导航时，路由器就把激活的组件显示在&lt;/router-outlet&gt; 里面。不写1&lt;router-outlet&gt;&lt;/router-outlet&gt; 会导致组件内容不加载进来，从而不显示内容；但是一个组件可以共用一个routeroutlet，所以app.component.ts里面配置即可：1&lt;router-outlet&gt;&lt;/router-outlet&gt; 第二种写法：请看代码：12345678910111213RouterModule.forRoot([...]) 将[] 及中间的内容当成配置文件提取出去；RouterModule.forRoot(routes),routes是我们需要导入的配置文件参数名：import &#123; routes&#125; from './app-routing.module';app-routing.module:中我们可以这样写：import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';import &#123; HeroDetailComponent &#125; from './detail/hero-detail.component';export const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'detail/:id', component: HeroDetailComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;, &#123; path: '**', component:DashboardComponent&#125;]; 注意： { path: ‘’, redirectTo: ‘/dashboard’, pathMatch: ‘full’ } 表示重定向路由：需要一个pathMatch属性，告诉路由器是如何用URL去匹配路由的路径的，没有这个属性就会报错；意思就是当路由URL等于’’时，会去加载DashboardComponent组件；所以你运行你的服务端口号：localhost:4200首先加载的就会是这个组件；{ path: “**”, component:DashboardComponent} **路径是一个通配符，表示除了以上几种path,任何的路径都会加载DashboardComponent组件，这个记得写在路由配置最后 当然这种方式我们还能这么写: 无declarations！声明是关联模块的重点。我们将AppRoutingModule抛出去，当做一个路由模块， 1234567891011121314import &#123; NgModule &#125; from '@angular/core';import &#123; Routes,RouterModule&#125; from '@angular/router';import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;];@NgModule(&#123; imports: [ RouterModule.forChild(routes) ], exports: [ RouterModule ]&#125;)export class AppRoutingModule &#123;&#125; app.module.ts中引入： 1import &#123; AppRoutingModule&#125; from './app-routing.module'; imports:中导入这个就可以啦AppRoutingModule这种用法和上面这种用法是一样的还有一点：如何解决第二次刷新出现404问题： 1[RouterModule.forRoot(routes,&#123;useHash:true&#125;)] 配置后面这一点，通过添加一个#，防止刷新第二次出现404；http://localhost:4201/#RouterModule.forChild(routes)写在子模块里面，而且这边用的是forChild(),不是forRoot（）,使用forRoot()也是不会错的，但是一般情况下根模块中使用forRoot()，子模块中使用forChild() forChild()只能用在特性模块中，这样的一点好处就是我们不必在主模块就配置好所有的路由信息，在需要的时候将他们导入主模块； 参数化路由1&#123; path: 'detail/:id', component: HeroDetailComponent &#125;, 配置参数化路由格式： :id 是一个占位符，当导航到HeroDetailCompnent组件上时，会被填入一个特定的id；这里我们是这样绑定的：1&lt;a *ngFor="let hero of heroes" [routerLink]="['/detail', hero.id]" class="col-1-4"&gt;&lt;/a&gt; eg: http://localhost:4201/detail/11 这时的id等于11； [1]传参类型的id作用可以根据传入的id不同让HeroDetailComponent显示不同的内容； [2]但是怎么能让其显示不同的内容呢？ 也就和我们这个id有关系，如何获取这个id 用在我们的组件里面呢？ [3]通过注入ActivatedRoute服务，一站式获取路由信息；1234import &#123; ActivatedRoute&#125; from '@angular/router'; constructor( private route: ActivatedRoute, ) &#123;&#125; 接下来我们这样试试：1234567public params;this.route.params.subscribe( params =&gt; &#123; this.params = params; console.log(this.params); &#125; ); 这样获取来的是一个对象：直接取id就能获取到了；既然是一站式获取，肯定不止这几个功能 后面会具体介绍它： 路由配置是也可以通过子路由来配置children：1234567&#123; path: 'heroes', component: HeroesComponent, children: [ &#123; path: 'heroTest', component: HeroTestComponent &#125;, ] &#125; 是这样配置的；此时HeroTestComponent组件的路由其实是:’heroes/heroTest’; 懒加载loadChildren:1234&#123; path:'loadtest', loadChildren:'./loadtest/loadtest.module#LoadtestModule' &#125; 路由是这样配置的： [1]这里注意几点：1import &#123; LoadtestComponent &#125; from './loadtest/loadtest.component'; 组件不需要在app.module.ts引入 [2]loadtest.module.ts 也不需要在app.module.ts中引入；而是通过loadchildren属性，在需要的时候告诉Angular路由依据loadchildren属性配置的路径去加载LoadtestModule模块，这就是模块懒加载功能；当用户需要的时候才回去加载，大大减少了应用启动时的资源加载大小； [3] loadChildren后面的字符串由三部分组成：(3.1) 需要导入模块路劲的相对路径(3.2) #分隔符(3.3) 导出模块类的名称 [4]还有一点也是也是重要的：loadtestModule代码是这样的：里面要引入自己的路由； 123456789101112131415import &#123; NgModule &#125; from '@angular/core';import &#123;CommonModule&#125; from '@angular/common';import &#123; LoadtestComponent &#125; from './loadtest.component';import &#123;RouterModule&#125; from '@angular/Router';import &#123;route&#125; from './loadtest-routing.module';@NgModule(&#123; imports:[ CommonModule, RouterModule.forChild(route), ], declarations:[ LoadtestComponent ]&#125;)export class LoadtestModule&#123;&#125; 在route路由里面记得这样配置这样一句才不会出错：1234567import &#123; LoadtestComponent &#125; from './loadtest.component';export const route = [ &#123; path:'', component: LoadtestComponent &#125;,] path:’’,才能保证代码不出错；懒加载的文件要注意：app.module.ts中：1234567declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent, TestComponent, ], 这里面的文件，采用懒在家的模块是引用不到得，因为lazy加载文件有自己的ngModule ，如果要使用的组件是同一个，最好建立一个shareModule模块；采用commonModule 将共享文件放进去，之后的Module里使用再加载进imports中； Router服务：123456789101112131415161718192021 class Router&#123;2. errorHandler:ErrorHandler3. navigated: boolean4. urlHandlingStrategy:UrlHandlingStrategy5. routeReuseStrategy:RouteReuseStrategy6. config:Routes7. initialNavigation():void8. setUpLocationChangeListener():void9. get routerState():RouterState10. get url(): string11. get events():Observable&lt;Event&gt;12. resetConfig(config:Routes):void13. ngOnDestroy():void14. dispose():void15. createUrlTree(commands: any[], navigationExtras:NavigationExtras):UrlTree16. navigateByUrl(url: string|UrlTree, extras:NavigationExtras):Promise&lt;boolean&gt;17. navigate(commands: any[], extras:NavigationExtras):Promise&lt;boolean&gt;18. serializeUrl(url:UrlTree): string19. parseUrl(url: string):UrlTree20. isActive(url: string|UrlTree, exact: boolean): boolean21. &#125; 这是Router API为我们提供的方法和属性； 看看几个常用的： navigate()该方法支持的参数类型和routerLink指令一样，所以他们的作用也是一样的：1this.router.navigate(['test', id]); 或者1this.router.navigate(['test']); 调用该方法后页面会自动跳转到对应的路由地址；1this.router.navigate(['test'], &#123; relativeTo: this.route&#125;); 我们可以设置一个参照路径，参照路径this.route从ActivatedRoute里面取；配置这个可以让自己知道相对于什么位置导航，this.route就是相对于当前的路由进行导航，假如当前url：localhost:4200/hero ,那么导航后的结果就是：localhost:4200/hero/test navigateByUrl() 这个叫做绝对路由；1this.router.navigateByUrl('home'); 可以帮助你快速的切换到某个路由下面，如果你当时的路由是这样的：localhost:4200/hero/test 点击这个路由后就是：localhost:4200/home 我们一般用这个路由来回到首页；和navigate()的区别还有点是：这个不是根据参数来确定路由地址的 config 会将页面所有的路由配置信息都显示：看看路由树： url 输出当前 的路由patheg：http://localhost:4200/detail/11url: /detail/11 每次导航前都会调用events方法；1RouterModule.forRoot(routes, &#123;enableTracing: true &#125;) 通过在控制台配置enableTracing: true可以在控制台看到相关改变； 注意：enableTracing: true 只能在forRoot()里面添加具体的事件有： chrome控制台:注意：这些事件是以Observable的形式提供的 ActivateRoute API :12345678910111213141516171819interface ActivatedRoute &#123;snapshot: ActivatedRouteSnapshoturl: Observable&lt;UrlSegment[]&gt;params: Observable&lt;Params&gt;queryParams: Observable&lt;Params&gt;fragment: Observable&lt;string&gt;data: Observable&lt;Data&gt;outlet: stringcomponent: Type&lt;any&gt;|string|nullget routeConfig(): Route|nullget root(): ActivatedRouteget parent(): ActivatedRoute|nullget firstChild(): ActivatedRoute|nullget children(): ActivatedRoute[]get pathFromRoot(): ActivatedRoute[]get paramMap(): Observable&lt;ParamMap&gt;get queryParamMap(): Observable&lt;ParamMap&gt;toString(): string&#125; parmaMap123456789第一步：import &#123; Router, ActivatedRoute, ParamMap &#125; from '@angular/router';第二步：import 'rxjs/add/operator/switchMap';导入switchMap操作符是因为我们稍后将会处理路由参数的可观察对象Observable ;会在以后的章节中介绍操作符的；第三步：constructor( private heroService: HeroService, private route: ActivatedRoute, private router: Router, ) &#123;&#125;&lt;code&gt; &lt;br&gt;&lt;/code&gt; 假定事先写好了HeroService： 1234this.route.paramMap .switchMap((params: ParamMap) =&gt; this.heroService.getHero(+params.get('id'))) .subscribe(hero =&gt; this.hero = hero ); &#125; 我们这样操作，前面已经介绍过用parmas获取参数；所以这样写也可以，用的是paramMap就引入paramMap，params就引入Params 123456this.route.params .switchMap((params: Params) =&gt; this.heroService.getHero(+params['id'])) .subscribe(hero =&gt; this.hero = hero; &#125; ); 由于参数是作为Observable提供的，所以我们得用switchMap操作符来根据名字取得id参数，并告诉HeroService来获取带有那个id的英雄。 snapshot(快照)route.snapshot提供了路由参数的初始值。 我们可以通过它来直接访问参数，而不用订阅或者添加Observable的操作符所以获取参数的id还可以这样：12&lt;a *ngFor="let hero of heroes" [routerLink]="['/detail', hero.id]" class="col-1-4"&gt;&lt;/a&gt; &lt;br&gt;this.params = this.route.snapshot.paramMap.get('id');&lt;br&gt;&lt;br&gt;console.log(this.params); 所以上面的代码改成这样更好： 1234this.params = this.route.snapshot.paramMap.get('id'); console.log(this.params);this.heroService.getHero(this.params) .then(hero =&gt; this.hero = hero); 两种方法：params 和snapshot到底什么时候该用哪种呢？ 需要直接访问参数，主要获取初始值，不用订阅的情况下用snapshot； 需要连续导航多次的用params; 总结 ,路由主要是用到了这些方面啦： 给路由添加一些新特性：添加动画[1] 在app.module.ts中引入启用Angular动画必备的, 记得在imports中导入：1import &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations'; [2] 在app.component.ts同级下创建一个animation.ts文件，用来存放我们的动画效果； 1234567891011121314151617181920212223 import &#123; animate, AnimationEntryMetadata, state, style, transition, trigger &#125; from '@angular/core';export const slideInDownAnimation: AnimationEntryMetadata = trigger('routeAnimation', [ state('*', style(&#123; opacity: 1, transform: 'translateX(0)' &#125;) ), transition(':enter', [ style(&#123; opacity: 0, transform: 'translateX(-100%)' &#125;), animate('0.2s ease-in') ]), transition(':leave', [ animate('0.5s ease-out', style(&#123; opacity: 0, transform: 'translateY(100%)' &#125;)) ]) ]); 假定我有以上代码，视图进场和出场； 构建动画需要的库； 导出了一个名叫slideInDownAnimation的常量，并把它设置为一个名，用于外部引入此ts文件； 叫routeAnimation的动画触发器。带动画的组件将会引用这个名字。用在外部html页面引用 指定了一个通配符状态 —— *，它匹配该路由组件存在时的任何动画状态。 定义两个过渡效果，其中一个（:enter）在组件进入应用视图时让它从屏幕左侧缓动进入（ease-in），另一个（:leave）在组件离开应用视图时让它向下飞出。 [3] 如何使用动画； 在需要的组件中引入变量名为：slideInDownAnimation的文件animation.ts； 1import &#123;slideInDownAnimation&#125; from '../animation'; [4]组件中配置12templateUrl: 'hero-detail.component.html',animations: [slideInDownAnimation] [5]html模板中这样引入：1&lt;div *ngIf="hero" [@routeAnimation]="'active'"&gt; @routeAnimation 动画触发器名 点击之后会自动加载动画的； 多重路由出口一般情况下：我们使用一个路由出口就行啦，什么情况下会使用第二路由呢？ 1.创建一个新组件ComposemessageComponent2.路由配置：12345&#123; path:'compose', component:ComposemessageComponent, outlet:'popup' &#125; 3.html页面这样配置：123456789&lt;nav&gt; &lt;a routerLink="dashboard" routerLinkActive="active" [routerLinkActiveOptions]="&#123;exact: true&#125;"&gt;Dashboard&lt;/a&gt; &lt;a (click)="go()" &gt;Heroes&lt;/a&gt; &lt;a routerLink="test" routerLinkActive="active" [routerLinkActiveOptions]="&#123;exact: true&#125;"&gt;Test&lt;/a&gt; &lt;a routerLink="loadtest" routerLinkActive="active"&gt;loadTest&lt;/a&gt; &lt;a [routerLink]="[&#123; outlets: &#123; popup: ['compose'] &#125; &#125;]"&gt;Contact&lt;/a&gt; &lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;router-outlet name="popup"&gt;&lt;/router-outlet&gt; 这是我的页面所有的路由配置；点击Contact 不会替换其他的组件信息，注意看Url:http://localhost:4200/dashboard(popup:compose)点击Contact url地址没有变成http://localhost:4200/contact而是采用圆括号加载 圆括号包裹的部分是第二路由。 第二路由包括一个出口名称（popup）、一个冒号分隔符和第二路由的路径（compose）而是显示在下面，点击test也是一样： Contact路由加载的组件不会被清除，一直显示在下面，状态一直被激活；这里我们就能知道第二路由的用处：即使在应用中的不同页面之间切换，这个组件也应该始终保持打开状态，多重出口可以在同一时间根据不同的路由来显示不同的内容；但是什么时候清除我们的第二路由呢？如果我页面不需要呢？注意：1234&lt;a (click)="go()" &gt;Heroes&lt;/a&gt;go() &#123; this.router.navigateByUrl('heroes'); &#125; 当点击Heroes时，Contact路由加载的内容就不会被显示：原因是这样的：它使用Router.navigateNyUrl()方法进行强制导航,所以路由清除啦；还可以这样清除： 123this.router.navigate([&#123; outlets: &#123; popup: null &#125;&#125;]);outlets属性的值是另一个对象，该对象用一些出口名称作为属性名。 唯一的命名出口是'popup'。但这里，'popup'的值是null。null不是一个路由，但却是一个合法的值。 把popup这个RouterOutlet设置为null会清除该出口，并且从当前URL中移除第二路由popup 路由守卫按照上面所说：任何用户都能在任何时候导航到任何地方，这样就有问题，可能此用户并没有权限切换到此路由，可能用户未登陆不能切换，或者做一些友好提示之后再切换；所以路由守卫就来了：守卫返回一个值，以控制路由器的行为： 如果它返回true，导航过程会继续 如果它返回false，导航过程会终止，且用户会留在原地。也就是你导航的路由是可以取消的，路由守卫还有一个好处就是回退功能时，可以防止用户无限回退，走出app；路由守卫怎么做：用CanActivate来处理导航到某路由的情况。用CanActivateChild来处理导航到某子路由的情况。用CanDeactivate来处理从当前路由离开的情况.用Resolve在路由激活之前获取路由数据。用CanLoad来处理异步导航到某特性模块的情况。 返回的值是一个Observable或Promise，路由器会等待这个可观察对象被解析为true或false。在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。看看路由守卫怎么实现：1.new 一个新项目activeComponent;2.编写守卫服务： 123456789import &#123; Injectable &#125; from '@angular/core';import &#123; CanActivate &#125; from '@angular/router';@Injectable()export class LoadTestService implements CanActivate&#123; canActivate() &#123; console.log('AuthGuard#canActivate called'); return true; &#125;&#125; 3.路由中这样导入我们的守卫： 123456789101112131415import &#123; ActiveComponent &#125; from './active/active.component';import &#123;LoadTestService&#125; from './loadtest.service';export const route = [ &#123; path:'', component: LoadtestComponent, canActivate:[LoadTestService], children:[ &#123; path:'a', component: ActiveComponent &#125; ] &#125;,] 这样我们的ActiveComponent就是受保护的； 当然这只是模拟；还有更多用法，以后来列举；]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>router</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
</search>
