<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Angular 4 自定义组件封装遇见的一些事儿]]></title>
    <url>%2Fangular%2Fstyle%2Fcomponent-120170908%2F</url>
    <content type="text"><![CDATA[你用Angular 吗？一.介绍说说封装Angular 组建过程中遇见的一些问题和感悟.用久了Angular,就会遇见很多坑，许多基于Angular开发的框架最喜欢做的事情就是封装组件,然后复用因为这是最省事的.二.基本构建组件思想 界面构建草图简要介绍上图：1.View 就是我们需要完成的界面,但是界面无非就是由若干个label,button,table,img,list等一些基本控件构成的,所有的前端页面构成都是一样,只是加上CSS排版确定最后的显示效果。2.五种基类，其实不止五种,只是列举。这里就需要我们将基类都封装成组件的形式,对外提供组件标签就可以使用.不管构建多少个页面,都可以用这几个基本组件完成.eg：一个button组件 button.component.html这个Button组件里面是还包裹一个label组件的. button.component.ts对外只用提供选择器，就可以使用Button了.3.可是为什么还要有中间的UIbuileder呢？是这样的，每次引选择器名是不是也很麻烦，看起来没有省力多少，封装的基本组件只需要对外抛出一个TYPEID，UIbuilder只要知道1是代表button组件，2代表label组件，UIbuilder将组件构建出来。 UIBuilder.html 构建组建图VIEW界面需要Button给我传一个1，需要label传一个2，需要什么传对于的id就行。此时的界面和组件是完全分离的，这样构件界面的时候几乎可以没有代码就出来一个页面啦。而且下次用的时候，基类是完全不用动的。三.样式控制。也许你会觉得这样构件出来的只有最简单的页面，那么样式呢？的确呀，这样就是很老土的界面，那么样式要怎么实现呢？其实Angular 提供了很多的方法的。1.一张样式表，定义所有的样式。相当于boostrap一样。 button样式定义都知道双花括号的定义,你只要在最外面将你需要的样式名传进来就可以啦.2.代码修改样式ElementRef ，Renderer2 有多少人知道这两个属性的。 代码修改样式这种都是可以在外部修改样式的,你的基组件不需要改动。 可能看起来费劲,但用起来好处很多，不用copy,copy了,而且你的思想也会到一个新的境界。其实，我用Angular有一段时间了,如果你也是,欢迎来交流。]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>自定义</tag>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flexible Box布局基础知识详解]]></title>
    <url>%2Fcss%2Ffb-120170908%2F</url>
    <content type="text"><![CDATA[1.基本概念，借用阮一峰老师的一张图：容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。2.容器的基本属性123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 2.1 flex-direction 属性决定主轴的方向 (及行排列) 1234.box&#123; flex-direction：row | row-reverse | column |column-reverse /*有四个值 分别的显示效果*/ &#125;默认值：row html5实现代码： 123456&lt;div class="box"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css3部分实现代码：12345678910111213141516171819body&#123; margin: 0 auto; width: 1000px; &#125; .box&#123; background: gold; margin: 1px; display: flex; /*必须设置这个*/ flex-direction: row; /*一排的方式排列*/ &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 实现效果：如果css3改成 flex-direction: row-reverse;其他两个属性类推；2.2 flex-wrap 定义如果一条轴线排不下，如何换行 1234 .box&#123; flex-wrap：nowrap | wrap | wrap-reverse; &#125;默认：nowrap html部分代码：1234567891011121314&lt;div class="box1"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css 部分代码： 123456789101112131415.box1&#123; background: gold; margin: 1px; display: flex; flex-flow: wrap; &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 效果：这是换行的效果，其他效果可以尝试；2.3 flex-flow 是flex-direction 和 flex-wrap的缩写；所以当独写上面的要写两个默认值为row norap 123.box&#123; flex-flow: flex-direction || flex-wrap &#125; 2.4 justify-content 属性定义了项目在主轴上的对齐方式 123.box&#123; justify-content:flex-start | flex-end | center | space-between | space-around; &#125; flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。html5代码： 12345678910&lt;div class="box2"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css3代码：123456789101112131415.box2&#123; background: gold; margin: 1px; display: flex; justify-content: center; /**可以换换其他的属性值*/ &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 效果图：其他的可以自己试试：flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2.5 align-items 定义项目在交叉轴上如何对齐（纵轴）123.box&#123; align-items:flex-start | flex-end |center | baseline |stretch &#125; html5代码： 1234567891011121314&lt;div class="box3"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item item-tall"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css3代码： 1234567891011121314151617181920.box3&#123; background: gold; margin: 1px; display: flex; align-items:flex-end; /*可以换其他值看看*/ flex-wrap: wrap; &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; .item-tall&#123; height: 200px; /*交叉轴，高度不一*/ line-height: 200px; &#125; 效果：其他的可以自己试试：flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。2.6 align-content 属性定义了多根轴线(多行)的对齐方式，如果项目只有一根轴线，该属性起不来作用123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; &#125; html代码： 1234567891011121314&lt;div class="box3 box3-tall"&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;div class="box-item"&gt;1&lt;/div&gt; &lt;div class="box-item"&gt;2&lt;/div&gt; &lt;div class="box-item"&gt;3&lt;/div&gt; &lt;div class="box-item"&gt;4&lt;/div&gt; &lt;/div&gt; css代码：12345678910111213141516171819.box3&#123; background: gold; margin: 1px; display: flex; flex-wrap: wrap; align-content: space-around; &#125; .box-tall &#123; height: 300px; &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 效果：其他的可以自己试试：flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。3.容器里子元素的属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch通常我们定义flex:1;表示的就是这三个；3.1 order 属性html代码：1234&lt;div class="box4"&gt; &lt;div class="box-item1 "&gt;1&lt;/div&gt; &lt;div class="box-item1 order"&gt;2&lt;/div&gt; /*注意是第二个元素有Order类*/ &lt;/div&gt; css代码：123456789101112131415161718.box4&#123; background: gold; margin: 1px; display: flex; &#125; .box-item1&#123; flex: 1; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; .order&#123; background: blue; order: -1; &#125; 效果图：如果我这样设置：12345.order&#123; background: blue; order: -1; flex-grow:2; /*多了这个*/ &#125; 其他的去试一试，大概就是这样]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>弹性布局</tag>
        <tag>Flexible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular4 中自定义pagination组件]]></title>
    <url>%2Fangular%2Fpg-120170908%2F</url>
    <content type="text"><![CDATA[你用Angular 吗?一.介绍一个基于angular4 开发的可以分页的组件。组件的好处就是可以复用，复用…..作为一个前端码农，开始的分页功能实现是我用jquery写的，其他同事用的时候都要将我的代码拷贝过去，于是我被鄙视了。为了不继续被鄙视就开始了尝试。二.基本功能1.根据规定的每页数据条数，分页显示数据 上下页操作数据直接上界面图可能清晰点：项目截图根据图片进行讲解下：根据你总数据条数:totalNum; 每页显示条数:pageSize,通过组件会自动给你分页显示。eg：总数41 条数据,每页显示10条数据，则是分成5页。如果想每页显示7条，则会分成6页。三.简要代码架构目录图：项目目录有两个组件：pagination和page;&nbsp; pagination是用来显示前面数据的，page是用来下面分页的。pagination.html示例代码：数据显示部分代码ngb-xxx不用在意，是用的ng-bootstrap，只是为了让界面好看点。其实就是一个简单的table用来显示数据。*ngFor用来取数据，懂Angular 的人应该都会，这不是重点就不介绍了。&lt;page&gt;&lt;/page&gt;&nbsp;这里是引入page组件。但是传入了一些属性值；关于模板语法，依赖注入，自定义事件就不介绍了。只要知道这里是：pagination组件向page组件传入了几个值：pageSize(页面显示数据条数)，totalNum(总数据条数),curPage(当前页码 ），totalPage(总页码),pageData(每页显示数据)其中pageSize和pageData是一样的，只是后面为了操作，多传了一个值；那么：pageSize等值都是哪里来的呢，当然是pagination.ts里定义的：pagination.ts代码代码中的page就是你获得到得数据，自然totalNum就会等于数据的长度。依次算出来就好了。pagination组件算是完成了，现在就来看看page是怎么接收到数据并进行操作的。page.html页面的代码：page.ts 分页数据的html其实很简单：就一个a标签显示条数，页数的，三个button,一个显示上一页，一个页数，一个下一页。每个按钮都绑定了一个changePage事件；看一下实现部分的代码：page.ts分页实现部分代码@Input是接收pagination.html组件传过来的数据。@Output是定义pagination.html页面定义的changeCurPage事件。通过三个if else判断，对传多来的数据进行处理。其实就分为：数据只够显示一页；数据显示到最后一页；数据刷新到中间页码；这三种情况下的操作。好了，基本就完成了。有些东西也是借助网友的想法，但是思路大致都是这样。现在我改变条数和数据量看看：&nbsp; 项目截图详情代码及效果：https://github.com/sulishibaobei/pagination]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular2+</tag>
        <tag>分页组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap简单图文环绕效果]]></title>
    <url>%2Fbootstrap%2Fbt-120170908%2F</url>
    <content type="text"><![CDATA[一.下载bootstrap-3.3.7二.在html页面引入css,js;eg:&lt;link src=”bootstrap-3.3.7-dist/css/bootstrap.min.css”&gt;&lt;script type=”text/javascript” src=”jquery.min.js”&gt;&lt;/ script&gt; &lt; script type=”text/javascript” src=”bootstrap-3.3.7-dist/js/bootstrap.min.js”&gt;&lt;/ script&gt; 注意：因为会用到jquery，所以引入了jquery .js;三.body部分的代码是这样的：123456&lt;body style="margin: 10px;padding: 0px"&gt; &lt;div class="left"&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;/div&gt;&lt;body/&gt; 简单解析下： body里包含两个div ,一个在左边排列(用于放图片)，一个在右边排列(用于放文字);都用class名进行区分啦，left和right;简单的给两个div添加点样式： .left { float : left ; max-width : 43% ; padding-left : 5px ; } .right{ margin-left : 5px ; } 现在还看不出什么效果;给第一个div里添加图片;&lt; img src=”index.jpg” class=”img-responsive” alt=”图像”&gt; 给第二个div添加文字，里面的文字是采用Boostrap的样式; &lt;div class="container"&gt; &lt;h1&gt;图文环绕&lt;/h1&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-offset-3" style=" box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;div class="row"&gt; &lt;div class="col-md-6" style=" box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;风雨中走过却不安世事的心&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;我还是很喜欢你，像风走了三千米不问归期 我希望有个如你一般的人如山间清爽的风如古城温暖的光从清晨到夜晚由山野到书房只要最后是你就好 &lt;/p&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-sm-offset-3" style="box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;我觉得这个世界美好无比。晴时满树花开，雨天一湖涟漪，阳光席卷城市，微风穿越指间，入夜每个电台播放的情歌，沿途每条山路铺开的影子，全部是你不经意写的一字一句，留我年复一年朗读。这世界是你的遗嘱，而我是你唯一的遗物。 &lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;一个人的记忆就是座城市，时间腐蚀着一切建筑，把高楼和道路全部沙化。如果你不往前走，就会被沙子掩埋。所以我们泪流满面，步步回头，可是只能往前走 &lt;/p&gt; &lt;/div&gt; &lt;div class="clearfix visible-xs"&gt;&lt;/div&gt; &lt;div class="col-xs-6 col-md-offset-3" style=" box-shadow:inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;你燃烧，我陪你焚成灰烬。你熄灭，我陪你低落尘埃。你出生，我陪你徒步人海。你沉默，我陪你一言不发，你欢笑，我陪你山呼海啸。你衰老，我陪你满目疮痍。你逃避，我陪你隐入夜晚。你离开，我只能等待。 &lt;/p&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-sm-offset-3" style="box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;"&gt; &lt;p&gt;我希望买的鞋子是你渴望的颜色。我希望拨通电话时你恰好在想我。我希望说早安你也刚起床。我希望写的书是你欣赏的故事。我希望关灯的刹那你正泛起困意。我希望买的水果你永远觉得是甜的。我希望点的歌都是你喜欢唱的。我希望我希望的是你希望的。 &lt;/p&gt; &lt;/div&gt; &lt;div class="clearfix visible-xs"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 采用的是bootstrap的架构： container&gt; row&gt; column&nbsp;将css样式也写在标签上，所以有点看起来复杂，其实很简单，这几段文字的结构都一样。看看运行效果：拖动页面试试你可以通过控制台随意拖动页面的宽度，看看文字的适配程度。源码另外有两个免费网站模板也可以看看，在同一个github路径下]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
        <tag>图文环绕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack初略学习]]></title>
    <url>%2Fwebpack%2Fwp-120170907%2F</url>
    <content type="text"><![CDATA[熟话说浓缩就是精华，哈哈，所以就这么简单粗暴的介绍下吧，写下的都是精华。 已经不是第一次听说webpack，但是我的起步有点晚，现在才看。开门见山~~ 1. 什么是webpack？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack是当下最热门的前端资源模块化管理和打包工具（就是一个打包器），可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源，还可以将需要加载的模块进行代码分离，等到实际需要的时候再进行异步加载。通过loader的转换，任何资源都可以视作模块，如COMMONJS模块 ,AMD模块，JS CSS ,JSON 等 ，它会根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 2.为什么要有webpack等打包器？ 平常的模块加载方式都是在&lt;script&gt;标签里引入，这种情况是在全局作用模式window下的，这样做的弊端就是只能按&lt;script&gt;的书写顺序进行加载，而且全局作用域下容易产生冲突，引入数量比较多的文件情况下难以管理。 而且，如果单独请求每个模块会造成请求次数过多，导致应用启动缓慢，但是，将所有文件压缩成一个文件，一次请求加载所有模块会导致流量的浪费，初始化过程缓慢。 所以编译的时候对所有的代码进行静态分析，分析出各个模块的类型及依赖关系，然后将他们提交给适配的加载器处理，所以webpack就应运而生。 3.COMMONJS模块，AMD模块，CMD模块，UMD模块几种常用模块？ Commonjs：允许模块通过require方法同步加载所需依赖的其他模式，然后通过exports或module.exports来导出需要暴露的接口。 1234eg： require("module"); require("./script.js"); export.doStuff= function ()&#123;&#125;; module.exports=someValue; 优点：各个模块可以进行重用，npm中已经有许多可供使用的包。 缺点：只能是同步加载的，同步就意味着阻塞加载，所以不适合在浏览器环境中，因为浏览器的资源是同步加载的，不能非阻塞的并行加载多个模块。 应用实例：nodejs Amd模块：它是在声明模块的时候就指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行依赖前置。 123eg: define("module", ["dep1", "dep2"], function (d1, d2)&#123; return someExportedValue; &#125;); require([ "module", "../file"], function (module, file) &#123; /* ... */ &#125;); 优点：适合异步加载模块，在浏览器环境中，并且可以并行运行多个模块。和commonjs相反。 缺点：提前加好所有依赖，代码要复杂很多。 应用实例：requirejs，curl Cmd模块：和AMD类似，并和Commonjs也有很大的兼容性。 1234eg: define( function (require, exports, module)&#123; var $ = require('jquery'); var Spinning = require('./spinning'); exports.doSomething = ... module.exports = ... &#125;) 优点：容易在nodejs中运行你的代码 缺点：依赖spm打包，模块的加载逻辑比较重、 应用实例：Sea.js Umd模块：主要解决模块定义的跨平台问题 123eg: import "jquery"; export function doStuff() &#123;&#125; module "localModule" &#123;&#125; 优点：容易进行静态分析，面向未来的ES标准； 缺点：原生浏览器不支持。 4.如何使用webpack？假装你的电脑里面已经安装了Node.js, 然后输入：npm install webpack -g ,可以通过webpack -h来查看安装信息。(1)假装创建一个项目test,进入项目路径，创建一个index.html页面，代码如下图： (2)然后再创建一个名为：bundle.js的文件，在上图的index.html中引入它。此文件里面什么代码都不需要写。(3)在创建一个名为entry.js的文件，不需要在index.html页面引入哟，此文件里面用来写内容。document.write( &quot;hello world&quot;);(4)然后将entry.js打包进bundle.js文件中，webpack会分析入口文件，解析包含依赖关系的各个文件，然后打包到bundle.js中 webpack entry.js bundle.jswebpack打包的原理就是给每一个模块都分配一个唯一的id并通过这个id索引和访问模块，启动时，会先执行entry.js里面的代码，其他模块会在运行require的时候执行。(5)此时打开bundle.js文件查看，你就可以发现里面已经 有代码了:(6)运行inde.html页面，在浏览器中就可以看到Hello world.但是webpack本身是只能处理javascript模块的，如果碰到css,json等其他模块文件，就需要使用loader转换。 loader就是一个装换器，一个可以输入任何资源但是最终都会帮你转成js模块的工具。总的来说loader有以下几点： 1.管道方式链式调用（允许多个文件转换，最后必定输出js文件）。 2.loader可以同步或异步执行 3.倘若在nodejs环境下，可以做任何事情 4.loader加载时可以接受传参。 5.可以通过文件扩展名来绑定不同类型的文件。 6.loader是通过Npm发布和安装。7.通过定义package.json来指定，同样也可以导出一个loader来使用，命名规则是：xxx-loader。一般是什么功能就命名什么。 下面就直接来试试：(1)在项目里面在新建一个名为：style.css的文件：输入body{ background:green}(2)修改entry.js 加入这一句 require(&quot;!style-loader!css-loader!./style.css&quot;)(3)安装Loader. npm install css-loader style-loader 先用css-loader读取它，再用style-loader将它插入页面中。(4)重新打包:webpack entry.js bundle.js(5)刷新index.html页面可以看到效果。如果有错误，cmd打包时就会显示，index.html运行时，fireug也会显示的。 loader转换器还可以通过配置文件来执行哟(1)通过往package.json里面新增配置项来完成。deDependencies (2)在新配置个webpack.config.js文件 12345678910111213141516171819var webpack = require('webpack')module.exports = &#123; resolve: &#123; fallback: path.join(__dirname, "node_modules") &#125;, resolveLoader: &#123; fallback: path.join(__dirname, "node_modules") &#125;, entry: './entry.js', output: &#123; path: __dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\.css$/, loader: 'style!css'&#125; ] &#125;, plugins:[ new webpack.BannerPlugin('This file is created by yu') ]&#125; (3)直接运行webpack ，刷新index.html 就可以查看效果]]></content>
      <categories>
        <category>前端那些打包工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>CMD,COMMONJS</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css3雪碧图]]></title>
    <url>%2Fcss%2Fsp-120170907%2F</url>
    <content type="text"><![CDATA[Css雪碧图： CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。原理：CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。如何生成雪碧图？安装gulp插件： npm install –g gulp安装制作雪碧图需要的插件 npm install –g gulp.spritesmith最好全局和本地各装一遍； 新建一个Gulpfile.js文件，将下列代码放进去： 1234567891011121314151617 var gulp=require('gulp'); //引入这两个gulp gulp.spritesmith spritesmith=require('gulp.spritesmith'); gulp.task('default',function()&#123; //新建名为sprite的任务 gulp.src('images/*.png') //需要合成的图片路径 *为通配符 表示这个文件夹下面所有后缀为.png的文件都会被应用 .pipe(spritesmith(&#123; imgName:'sprite.png',//合成后需要保存图片的路径 cssName:'sprite.css', //合成后需要保存的css的路径 padding:5, //表示两个图片间的空隙 algorithm:'binary-tree', // Algorithm 有四个可选值分别为top-down、left-right、diagonal、alt-diagonal、binary-tree // cssTemplate:'dist/handlebarsStr.css' //生成的css模板文件，可以是函数也可以是字符串 &#125;)) .pipe(gulp.dest('dist/')) //将生成的文件放到dist文件夹下 &#125;) ``` 或者： 进入项目 npm init 输入需要的信息，创建一个package.json文件: { “name”: “package.json”, “version”: “1.0.0”, “description”: “”, “main”: “Gulpfile.js”, “dependencies”: { “gulp”: “^3.9.1”, “gulp.spritesmith”: “^6.5.1” }, “devDependencies”: {}, “scripts”: { “test”: “echo \”Error: no test specified\” &amp;&amp; exit 1” }, “author”: “”, “license”: “ISC”}12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455这里提几点需要注意的： 需要一个Gulpfile.js（首字母小写也可以） ，运行时执行 gulp default（defaullt是你新建的任务名，不是固定的，你写成其他也行）`imgName:'sprite.png'`//合成后需要保存图片的路径`cssName:'sprite.css'` 这两个文件需要你先创建，里面的文件都要预先创建； 我这里是放在dist下面就要在dis下面创建这两个文件 合成的雪碧图； ![sp](/images/sp-1.png)css样式：```css.icon-1 &#123; background-image: url(sprite.png); background-position: 0px 0px; width: 33px; height: 33px;&#125;.icon-2 &#123; background-image: url(sprite.png); background-position: -38px 0px; width: 33px; height: 33px;&#125;.icon-3 &#123; background-image: url(sprite.png); background-position: 0px -38px; width: 33px; height: 33px;&#125;.icon-4 &#123; background-image: url(sprite.png); background-position: -38px -38px; width: 33px; height: 33px;&#125;.icon-5 &#123; background-image: url(sprite.png); background-position: -76px 0px; width: 33px; height: 33px;&#125;.icon-6 &#123; background-image: url(sprite.png); background-position: -76px -38px; width: 33px; height: 33px;&#125;.icon-7 &#123; background-image: url(sprite.png); background-position: 0px -76px; width: 33px; height: 33px;&#125; algorithm：四个参数只是决定图片的排列顺序；top-down：具体的参数可以看这里：好了,雪碧图就合成啦；下面会讲讲如何使用雪碧图；创建一个文件：index.html引入生成的css &lt;link rel=”stylesheet” type=”text/css” href=”./dist/sprite.css” /&gt;写基本架构：class=&quot;icon-1&quot; 这里是css里生成的样式名；按顺序写好就行; 123456789101112131415161718192021222324252627282930&lt;ul class="sprite"&gt; &lt;li&gt; &lt;s class="icon-1"&gt;&lt;/s&gt; &lt;a href=""&gt;衣服&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-2"&gt;&lt;/s&gt; &lt;a href=""&gt;鞋子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-3"&gt;&lt;/s&gt; &lt;a href=""&gt;背包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-4"&gt;&lt;/s&gt; &lt;a href=""&gt;双肩包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-5"&gt;&lt;/s&gt; &lt;a href=""&gt;裤子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-6"&gt;&lt;/s&gt; &lt;a href=""&gt;羽绒服&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class="icon-7"&gt;&lt;/s&gt; &lt;a href=""&gt;外套&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; 给他们新增加一些样式： 1234567891011121314151617181920212223242526ul &#123; list-style: none; margin: 0; padding: 0;&#125;.sprite &#123; margin: 10px auto; width: 206px; border: 1px solid #b51600;&#125;.sprite li &#123; cursor: pointer; height: 42px; width: 206px; background-color: #b51600; border-bottom: 1px solid #911001; border-top: 1px solid #c11e08;&#125;.sprite li a &#123; color: #fff; line-height: 42px; font-size: 14px;&#125; 效果就是这样：引入了css文件，class也改动了，怎么没有图标呢？生成的css文件里面就告诉你了，让标签dispay:block; 12345.sprite li s&#123; display: inline-block; margin-left: 10px; margin-right: 8px; &#125; 看看效果：]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>雪碧图</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs+websocket实时聊天系统]]></title>
    <url>%2Fwebsocket%2Fwb-120170907%2F</url>
    <content type="text"><![CDATA[介绍下websocket： webSocket协议本质上是一个基于tcp的协议; 建立一个websocket连接，大体的过程： 1.客户端浏览器首先向服务器发起一个http请求，这个请求和平常的请求有什么不同呢？ 多了一点附加头信息：”upgrade:web Socket” 表明我这申请的是一个websocket的http请求； 2.服务器收到请求后，解析这些附加的头信息，然后产生应答信息返回给客户端，这样，连接就建立了； 3.双方就可以通过这个连接通道自由的信息传递，这个连接会一直存在，直到一方自动关闭连接； 客户端到服务端：12345678GET /demo HTTP/1.1Host: example.comConnection: UpgradeSec-WebSocket-Key2: 12998 5 Y3 1 .P00Upgrade: WebSocketSec-WebSocket-Key1: 4@1 46546xW%0l 1 5Origin: http://example.com[8-byte security key] 服务端到客户端：123456HTTP/1.1 101 WebSocket Protocol HandshakeUpgrade: WebSocketConnection: UpgradeWebSocket-Origin: http://example.comWebSocket-Location: ws://example.com/demo[16-byte hash response] 从客户端到服务端请求的信息里面包含：‘Sec-webSocket-key1”,”Sec-WebSocket-key2”和“[8-byte security key]”这样的信息；这是客户端浏览器需要向服务端提供的握手信息，服务端解析这些头信息，并且在握手的过程中依据这些信息生成一个16位的安全密钥并返回给客户端，以表明服务器端获取了客户端的请求；大致步骤： 逐个字符读取 Sec-WebSocket-Key1 头信息中的值，将数值型字符连接到一起放到一个临时字符串里，同时统计所有空格的数量； 将在第 1 步里生成的数字字符串转换成一个整型数字，然后除以第 1 步里统计出来的空格数量，将得到的浮点数转换成整数型； 将第 2 步里生成的整型值转换为符合网络传输的网络字节数组； 对 Sec-WebSocket-Key2 头信息同样进行第 1 到第 3 步的操作，得到另外一个网络字节数组； 将 [8-byte security key] 和在第 3，第 4 步里生成的网络字节数组合并成一个 16 字节的数组； 对第 5 步生成的字节数组使用 MD5 算法生成一个哈希值，这个哈希值就作为安全密钥返回给客户端，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接 123456789101112131415161718var wsServer = 'ws://localhost:8888/Demo'; //连接地址var websocket = new WebSocket(wsServer); //建立连接websocket.onopen = function (evt) &#123; onOpen(evt) &#125;; //4个事件websocket.onclose = function (evt) &#123; onClose(evt) &#125;; websocket.onmessage = function (evt) &#123; onMessage(evt) &#125;; websocket.onerror = function (evt) &#123; onError(evt) &#125;; function onOpen(evt) &#123; console.log("Connected to WebSocket server."); &#125; function onClose(evt) &#123; console.log("Disconnected"); &#125; function onMessage(evt) &#123; console.log('Retrieved data from server: ' + evt.data); &#125; function onError(evt) &#123; console.log('Error occured: ' + evt.data); &#125; 浏览器的支持情况： 浏览器 支持情况 Chrome Supported in version 4+ Firefox Supported in version 4+ Internet Explorer Supported in version 10+ Opera Supported in version 10+ Safari Supported in version 5+ 正文来了：基于websocket制作的简单聊天系统；简单的界面，大致效果就是这样的： 实现逻辑代码：1234567891011121314151617181920212223242526var ws = new WebSocket('ws://127.0.0.1:8082'); ws.onopen = function (e) &#123; console.log("连接服务器成功"); &#125; ws.onmessage = function (e) &#123; value1.removeAttribute("readOnly"); var time = new Date(); mess.innerHTML += time.toUTCString() + ":" + e.data + "&amp;lt;br&amp;gt;"; document.getElementById("send").onclick = function (e) &#123; ws.send(input.value + "说:" + value1.value); value1.value = " "; &#125; document.onkeydown = function (e) &#123; e = e || window.event; if (e.keyCode == 13) &#123; document.getElementById("send").onclick(); return false; &#125; &#125; &#125; ws.onclose = function (e) &#123; console.log("服务器关闭"); &#125; ws.onerror = function () &#123; console.log("连接出错"); &#125; 连接地址：ws://127.0.0.1:8082&nbsp; 那是哪里来的呢？（注意http请求则是写成http://xxx,https请求则是https://xxx；ws当然是ws://xxx);wbsocket只是客服端，地址当然是从我们的服务端给的呀；服务端的搭建采用了一个这样的库： nodejs-websocket npm isntall -g nodejs-websocket 在js页面引入它 1234567891011121314151617 var ws = require("nodejs-websocket" ); ``` 3. 创建一个服务 ```javascript var server = ws.createServer(function (conn) &#123; conn.on('text', function (str) &#123; &#125;) conn.on("close", function (code, reason) &#123; console.log("关闭连接"); &#125;) conn.on("error", function (code, reason) &#123; console.log("异常关闭"); &#125;);&#125;).listen(8082);console.log("websocket连接完毕") websocket连接算是建立啦！下面展示下具体代码：client.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="bootstrap-3.3.7-dist/css/bootstrap.min.css" /&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script src="bootstrap-3.3.7-dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;style&gt; .kuang &#123; width: 600px; min-height: 50px; max-height: 296px; border: 1px solid; float: left; display: block; position: relative; overflow-y: scroll; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="jumbotron bg-dark"&gt; &lt;h1 class="jumbotron-heading"&gt;WebSocket chat,欢迎使用:&lt;/h1&gt; &lt;/div&gt; &lt;div class="input-group text-left"&gt; &lt;label&gt;输入用户名：&lt;/label&gt; &lt;input type="text" id="name" /&gt; &lt;button id="conn"&gt;连接&lt;/button&gt; &lt;button id="close"&gt;断开&lt;/button&gt; &lt;/div&gt; &lt;div class="input-group text-muted"&gt; &lt;div class="kuang" id="mess"&gt;&lt;/div&gt; &lt;/div&gt; &lt;hr class="featurette-divider"&gt; &lt;div class="input-group text-left"&gt; &lt;input type="text" class="value" id="value1" /&gt; &lt;button id="send"&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var input = document.getElementById("name"); var conn = document.getElementById("conn"); var close = document.getElementById("close"); var mess = document.getElementById("mess"); var value1 = document.getElementById("value1"); var pattern = /^[\u4e00-\u9fa5]&#123;2,10&#125;$/; close.disabled = true; if (window.WebSocket) &#123; conn.onclick = function () &#123; if (!pattern.test(input.value)) &#123; alert("名称不能为空且必须为中文"); return; &#125; var ws = new WebSocket('ws://127.0.0.1:8082'); conn.disabled = true; close.disabled = false; ws.onopen = function (e) &#123; console.log("连接服务器成功"); ws.send(input.value); input.setAttribute("readOnly", 'true'); value1.setAttribute("readOnly", 'true'); &#125; ws.onmessage = function (e) &#123; value1.removeAttribute("readOnly"); var time = new Date(); mess.innerHTML += time.toUTCString() + ":" + e.data + "&lt;br&gt;"; document.getElementById("send").onclick = function (e) &#123; ws.send(input.value + "说:" + value1.value); value1.value = " "; &#125; document.onkeydown = function (e) &#123; e = e || window.event; if (e.keyCode == 13) &#123; document.getElementById("send").onclick(); return false; &#125; &#125; &#125; ws.onclose = function (e) &#123; console.log("服务器关闭"); &#125; ws.onerror = function () &#123; console.log("连接出错"); &#125; close.onclick = function () &#123; ws.onclose(); ws.send(input.value + 'close' + "了连接"); input.removeAttribute("readOnly"); conn.disabled = false; close.disabled = true; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var ws = require("nodejs-websocket");console.log("开始建立连接...");var str1 = null, str2 = null, clientReady = false, serverReady = false;var a = [];var server = ws.createServer(function (conn) &#123; conn.on('text', function (str) &#123; a.push(str); if (!clientReady) &#123; if (a[0] === str) &#123; str1 = conn; clientReady = true; str1.sendText("欢迎你" + str); &#125; &#125; else if (!serverReady) &#123; if (str.indexOf('close') &amp;gt;= 0) &#123; a.splice(2,1); clientReady = false; str1=null; return; &#125; if (a[1] === str) &#123; str2 = conn; serverReady = true; str2.sendText("欢迎你" + str); str1.sendText(str + "在线啦，你们可以聊天啦"); return; &#125; &#125; else if (clientReady &amp;amp;&amp;amp; serverReady) &#123; str2.sendText(str); str1.sendText(str); if (str.indexOf('close') &amp;gt;= 0) &#123; a.splice(2, a.length); var len = a.length; for (var i = 0; i &amp;lt; len; i++) &#123; // 定位该元素位置 if (str.indexOf(a[i])&amp;gt;=0) &#123; a.splice(i,1); if(i==0)&#123; str1=str2; &#125; serverReady = false; str2=null; return; &#125; &#125; &#125; &#125; &#125;) conn.on("close", function (code, reason) &#123; console.log("关闭连接"); clientReady = false; serverReady = false; &#125;) conn.on("error", function (code, reason) &#123; console.log("异常关闭"); &#125;);&#125;).listen(8082);console.log("websocket连接完毕") 实现双人聊天，client.html开启两个窗口就行！详细代码在github]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 打卡的第一天]]></title>
    <url>%2Fgit%2Fgit-120170907%2F</url>
    <content type="text"><![CDATA[因为某种原因，所以不得不重新巩固下前端的基础知识，从最基本的学习还得额外的学习新知识，倍感压力之大。 昨天初略学习下git，算是自己学习的一个新知识。简单记录下，希望四海八荒的大神看过来，有错的请指导。 git下载安装git下载安装地址下载好之后记得配置环境变量。git的作用主要是将项目保存到git目录中 git介绍主要分为三个块：[1] working directory(工作目录） 本地上存放项目的目录。[2] staging area 暂存放区域 更新暂未提交的项目。[3] git directory git上存放项目的地方。1.一般我们使用git都会将一些修改的文件保存在暂存区域，然后一并提交更新到git目录中。2.安装好git之后，网页打开github，注册信息。登陆进去，接下来配置信息。3.打开右上角，如下图点击settings。然后点击SSH and GPG keys ,配置SSH。打开cmd或者git bash。找不到git.bash的就在开始那里搜索或者在你安装的git文件里面打开git.bash.exe就一样。4.在命令行输入：ssh-keygen -t rsa -C “你注册github时的邮箱名” 然后会提示你生产的key在id_rsa.pub文件中找。5.在电脑中一个叫.ssh的文件里，然后复制黏贴在右边的key框里面，title就随便打。 此时git的安装目录就为你的根目录。 配置用户信息：git config --global user.name &quot;你注册时的用户名&quot;;git config --global user.email &quot;你的邮箱&quot;;git里面提供了一个git config的命令专门用来配置或者读取相应的工作环境变量。这些变量可以存放在三个地方：etc/gitconfig文件， git config –system读写的就是此文件；~/.gitconfig文件，git config –global 读写的就是此文件；配置好信息后，可以通过git config –list 命令查看&nbsp;&nbsp; 如果git config user.name就是具体的查看某个环境变量的设定。若不知道如何使用git命令，可以git help看看。 git使用。 新建一个git 仓库，也可以导入一个本地项目。进入仓库 复制这个地址 然后打开cmd或者git.bash.exe， 输入git clone git@github.com:sulishibaobei/a.github.io.git （上面复制的这串地址) 就会在你的本地建立一个名为a.github.io的仓库，进入仓库，将你需要上传的代码拷贝进去 123git add *（*是上传所有的本件，若是想具体的就写文件名）git commit -m "version" 提交文件git push 这三步就完成git项目的提交。 可以用git status命令查看当前文件的状态。 所有的文件都可以先add到暂存区域，然后最后再一起commit。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>环境变量配置</tag>
        <tag>基本git操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑稽的下午--Angular 2+管道的使用]]></title>
    <url>%2Fangular%2Fpipe%2Fpipe-120170907%2F</url>
    <content type="text"><![CDATA[注:所有的angular 2+ 其实就包含了4,是向上兼容的； 让一个component组件里的时间显示当前时间并自动刷新。过程:1.首先获取当前时间 new Date();2.弄个定时器隔一秒刷新呀； app.component.ts中这样写到： 123456789101112131415161718InitialTime= new Date(); // 获取当前时间 data:string; getTime(m)&#123; // 判断获取的分钟数是否小于10，小于10只会显示一位数，前面自动补0 if (m&amp;lt;10 )&#123; m ="0"+ m; this .data= this .InitialTime.getHours()+":"+m; // 显示时间(小时+分钟) eg 17:15 &#125; else &#123; this .data= this .InitialTime.getHours()+":"+ this .InitialTime.getMinutes(); // 显示时间(小时+分钟) eg 17:15 &#125; &#125; constructor()&#123; this .getTime( this .InitialTime.getMinutes()); // 运行上面方法让时间显示 setInterval(()=&amp;gt;&#123; // 设置定时器，隔1秒刷新一次，好实时监控时间 this .InitialTime= new Date(); this .getTime( this .InitialTime.getMinutes()); &#125;, 1000 ); &#125; app.component.html中这样写： 1&amp;lt;span class="time"&amp;gt; &#123;&#123; date &#125;&#125;&amp;lt;/span&amp;gt; 然后变成我想要的效果了，可是代码我自己都嫌长，而且还是用传统js方法写的。后来就想不是angular里面有Pipe管道吗，是不是可以试试。app.component.ts是这样写的。 1234567time:any=Date.now(); // 获取当前时间 constructor()&#123; setInterval(() =&amp;gt;&#123; // 设置定时器，隔1秒刷新一次，好实时监控时间 // this.birthday = new Date(); this .time=Date.now(); // Date里面自带方法 &#125;,1000 ); &#125; app.component.html是这样写的： 1&amp;lt;span class="time"&amp;gt; &#123;&#123;time | date:"HH:mm" &#125;&#125;&amp;lt;/span&amp;gt; 注：|是管道标示符。angular里面提供了内置的datePipe管道可以供我们使用 HH：mm 表示输出小时和分钟；yy:MM:dd&nbsp; 表示输出年月日 详情可以看看官网的管道介绍里面关于DatePipe Api的介绍。 同样的效果，代码量就大大减少，所以学习还是在完成的基础上多尝试。耶~~~ 后续会有详细的关于管道学习的更多文章]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>pipe</tag>
        <tag>管道</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2+ 关于新版angular-cli的应用]]></title>
    <url>%2Fangular%2Fangular-cli%2Fangular-120170906%2F</url>
    <content type="text"><![CDATA[以前写过一个webstorm借助angular-cli搭建angular2.0项目的博客。 后来许久没有接触过angular，现在拾起来的时候发现已经更新，用法变了。所以来记录下，以免其他友看到照成误区。这也是说明一个道理，别人写下的东西你不一定适用，因为技术的东西说变就变，谁知道的。 [1]基于Node环境，安装angular-cli。&nbsp; 新版的已经变成安装@angular/cli。所以安装时：npm install -d @angular/cli 那么问题来了，一大堆错误，说缺少pathon和visual studio。还有说版本不兼容的，所以建议node的版本不要太高，也不用太低。第一次我用的7以上的版本说不支持。然后换成6.0以上也是不支持。最后换成6.9几用的好好的。并不是所有人的电脑安装都会出问题的。 既然说缺少pathon那就安装吧。推荐一个网友的解决办法，我也是参照这个解决的，就不重复啰嗦看这里;说到底会出错的原因都是因为npm是国外的，需要FQ，会有那么一丝丝不稳定。不过建议大家先安装cnpm在装，就什么问题都，没有了。npm install -g cnpmcnpm install -g @angular/cli ng命令 安装好angular/cli之后，就可以用ng命令啦。例如：ng –version 查看版本号ng help 帮助 当然最重要的还是用它创建工程。ng new 工程名;然后会自动帮你创建所有的依赖，搭建成一个简单的模板，大概这样 node-modules会自动帮你创建，只是耗时比较长，建议一次下载多次copy。运行项目试试，进入你的工程目录下，然后ng serve; 默认是开启localhost:4200的。所以浏览器里打开localhost:4200就可以啦。 这是最简单的项目啦，当然你可以继续创建命令 例如运行ng g c user 它是四个四个创建的，配套吗！！ 后续介绍一篇文章专门讲angular-cli的这些文件工程太大了，运行时可以打压，ng serve --prod --aot 也是可以的。好了就介绍这些基础的，其实后面的使用并没有改变太多啦之前在博客园中也介绍过关于在webstorm中如何开发angular项目，如果想在webstorm中使用，可以去看看目前我使用VScode ，觉得挺好的！！]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>Angular-cli</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述alert和console.log的区别]]></title>
    <url>%2Fjs%2Fconsole20170905%2F</url>
    <content type="text"><![CDATA[生活中还是得有发现美好和差别的眼睛, 学习前端那么久既然还不知道alert和console.log的差别;本菜鸟一直以为alert和console.log其实是一样的用法，只是alert以弹出框形式呈现，而console.log在控制台输出而已。只到道昨天输出一段代码，结果发现alert和console.log输出结果不一样,本宝宝可算涨见识了, 然后就是各种查阅资料，百度查看，终于发现点眉目啦 ; 我写了这样一段代码：alert输出的结果为：console.log输出的结果为： 然后我就尴尬了 [1]原来console.log() 可以打印任何类型的数据。而 alert() 只能输出string，[2]如果alert输出是对象会自动调用 toString() 方法。如果想 console.log() 输出的与alert相同，需要调用 toString()。[3]所以将后面的改写成&nbsp;console.log(hmac.toString()) 就可以啦 下面再来总结下两者的差别123456789101112alert() 1.1 有阻塞作用，不点击确定，后续代码无法继续执行 1.2 alert()只能输出string,如果alert输出的是对象会自动调用toString()方法 e.g. alert([a,b,c]); //a,b,c 1.3 alert不支持多个参数的写法,只能输出第一个值 e.g. alert(1,2,3); // 1console.log() 2.1 在打印台输出 2.2 可以打印任何类型的数据 e.g. console.log([a,b,c]); //[a,b,c] 2.3 支持多个参数的写法 e.g. console.log(1,2,3) // 1 2 3 好啦~~~就是这样啦。]]></content>
      <categories>
        <category>前端那些微小事</category>
      </categories>
      <tags>
        <tag>console.log</tag>
        <tag>alert</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试中遇见的那些纯js题]]></title>
    <url>%2Fjs%2Fjs120170905%2F</url>
    <content type="text"><![CDATA[js 定义类有哪些常用的方法？1.工厂方式12345678910111213function Car()&#123; var ocar=new Obejct; //不用括号 ocar.color='blue'; ocar.doors=4; ocar.showColor=function()&#123; this.color; &#125; return ocar;&#125;var car1=Car();var car2=Car();console.log(car1); //&#123;color: "blue", doors: 4, snowColor: ƒ&#125; f指的是function()console.log(car2); //&#123;color: "blue", doors: 4, snowColor: ƒ&#125; 注：1.调用此方法时，将创建新的对象，并赋予它所有的属性和方法。使用此函数可以创建两个属性完全相同的对象；2.我们可以通过给函数传递不同的参数来得到具有不同值得对象 12345678910111213function Car(color,door)&#123; var ocar=new Object; ocar.color=color; ocar.doos=door; ocar.showColor=function()&#123; console.log(this.color); &#125; return ocar;&#125;var car1=Car("red",5);var car2=car("blue",4);car1.showColor(); //red；car2.showColor(); //blue 在上面的两个例子中，每次创建一个Car()对象都会创建一个showColor()，意味着每个对象都有自己的showcolor()方法，但是实际上每个对象可以共享同一个函数，最后通过将函数的属性指向该方法* 123456789101112function showColor()&#123; console.log(this.color); &#125; function Car(color,door)&#123; var ocar=new Object(); ocar.color=color; ocar.doors=door; ocar.showColor=showColor; return ocar; &#125; var car1=new Car('red',4); car1.showColor(); 当然这里扯远了 2.构造函数方法这个和工厂方式差不多 1234567891011function Car(color,door)&#123; this.color=color; this.doors=door; this.showColor=function()&#123; console.log(this.color); &#125; &#125; var car1=new Car("red",4); var car2=new Car("blue",5); car1.showColor();//red car2.showColor();//blue 注：这种模式和工厂的方式区别在于，不用通过自己去New一个对象，而是使用this关键字；因为在调用构造函数时就已经创建了对象，而在函数内部只能通过this来访问此对象但是，它和工厂方式一样，每次调用对象都会创建自己的方法 3.原型方式该方式利用了对象的prototype属性，首先用空函数创建类名，然后所有的属性和方法都被赋予prototype属性； 12345678910function Car()&#123;&#125;Car.prototype.color="red";Car.prototype.doors=4;Car.prototype.showColor=function()&#123; console.log(this.color);&#125;var car1=new Car();var car2=new Car(); console.log(car1); 看看最后输出的是什么注：1.首先定义一个空函数，然后通过prototype属性来定义对象的属性；调用该函数时，原型的所有属性都会立即赋予要创建的对象，所有该函数的对象存放的对是指向showColor()的指针，语法上看起来都属于同一个对象；2.但是这个函数没有参数，不能通过传参来初始化属性，必须要在对象创建后才能改变属性的默认值；3.原型方式还有个很大的弊端；如果属性指向的是对象时： 12345678910111213function Car()&#123;&#125;Car.prototype.color="red";Car.prototype.doors=4;Car.prototype.arr=new Array('a',"b");Car.prototype.showColor=function()&#123; console.log(this.color);&#125;var car1=new Car();var car2=new Car();car1.arr.push('cc');console.log(car1.arr); //(3) ["a", "b", "cc"]console.log(car2.arr); //(3) ["a", "b", "cc"] 注：arr对象指向的是一个数组，这里用的是数组的引用值，Car的两个对象指向的都是同一个数组所以car1添加值以后，在car2中也能看到值；形式是这样的： 4.联合方式（构造函数+原型方式)1234567891011121314function Car(color,door)&#123; this.color=color; this.doors=door; this.arr=new Array("aa","bb"); &#125;; Car.prototype.showColor=function()&#123; console.log(this.color); &#125; var car1=new Car("red",4); var car2=new Car("blue",5); car1.arr.push("cc"); console.log(car1); console.log(car1.arr); // (3) ["aa", "bb", "cc"] console.log(car2.arr); //(2) ["aa", "bb"] 首先来看看car1对象注：1.car1和car2对象都有自己单独的arr属性，所以改变其中一个另一个并不会受影响2.此方式是用构造函数定义对象的非函数属性，用原型对象定义对象的方法 5.动态原型方式和混合模式相似，区别就是赋予对象方法的位置不一样； 12345678910111213141516function Car(color,door)&#123; this.color=color; this.doors=door; this.arr=new Array("aa","bb"); if(typeof Car._initialized =="undefined")&#123; Car.prototype.showColor=function()&#123; console.log(this.color); &#125;; Car._initialized=true; &#125;;&#125;var car1=new Car('blue',3);var car2=new Car('red',3);car1.showColor();car2.showColor();console.log(car1); 注：此方法是用一个标志来判断是否已经给原型赋予了此方法，这样可以保证该方法只被创建一次 6.混合工厂方式目的是创建假构函数，只返回另一种对象的新实例 123456789101112function Car()&#123; var ocar=new Object();//带括号 ocar.color="red"; ocar.doors=4; ocar.showColor=function()&#123; console.log(this.color); &#125; return ocar;&#125;var car1=new Car();var car2=new Car();car1.showColor(); //red 注：和工厂方式很像，不通的就是这是通过New运算符 7.对象直接量采用set get的方式 123456789101112var car1=&#123; color:"", getColor: function()&#123; console.log(this.color); //red return this.color; &#125;, setColor:function(color)&#123; this.color=color; &#125;&#125;car1.setColor('red');car1.getColor(); 8.定义函数对象1234567891011121314var car2=new Function(); //注意大写car2.prototype = &#123; color:"", getColor:function()&#123; console.log(this.color);//blue return this.color; &#125;, setColor:function(color)&#123; this.color=color; &#125;&#125;car2.prototype.setColor('blue');car2.prototype.getColor();console.log(car2.prototype);//&#123;color: "blue", getColor: ƒ, setColor: ƒ&#125; 也是运用上面的原型方式和混合工厂模式 js类继承的方法有哪些既然是继承，首先得有个父类 12345678910111213//定义一个动物类 function Animal(name)&#123; //给一个Name属性 this.name=name || 'Animal'; //实例方法 this.sleep=function()&#123; console.log(this.name+" 在睡觉")； &#125; &#125; //原型方法 Animal.prototype.eat=function(food)&#123; console.log(this.name + '正在吃' +food); &#125; 原型链继承核心： 将父类的实例作为子类的原型 12345678910function Cat()&#123;&#125;Cat.prototype=new Animal();Cat.prototype.name='cat';var cat=new Cat();console.log(cat.name); //catconsole.log(cat.eat('fish')); //cat正在吃fishconsole.log(cat.sleep()); //cat 在睡觉console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 注：使用的的原型方式；特点: 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法和原型属性，子类都能访问 简单，易于实现 缺点: 要想为子类新增方法和属性，必须要在new Animal()这样的语句指向之后，不能放在构造器中； 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 12var cat1=new Cat()console.log(cat1.name) //cat 构造继承 call（）123456789function Cat(name)&#123; Animal.call(this); this.name=name || 'Animal';&#125;var cat=new Cat('cat');console.log(cat.name); //catconsole.log(cat.sleep()); //cat 在睡觉console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 注：这里是调用不到eat原型方法的;特点: 解决了1中，子类实例共享父类引用属性的问题； 创建实例时，可以向父类传参； 可以实现多继承（call 多个父类对象); 缺点: 实例并不是父类的实例 只能继承父类的实例和方法，并不能继承原型属性和方法； 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承 instace核心： 为父类实例添加新特性，作为子类实例返回 12345678910 function Cat(name)&#123; var instace=new Animal(); instace.name=name || 'Animal'; return instace; &#125;var cat=new Cat();console.log(cat.name); //Animalconsole.log(cat.sleep()); //Animal 在睡觉console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点:不限制调用方法，不管是new 子类()还是子类(),返回的对象具有相同的效果；缺点:1.实例是父类的实例，不是子类的实例;2.不支持多继承 拷贝继承123456789101112 function Cat(name)&#123; var animal=new Animal(); for(var p in animal)&#123; Cat.prototype[p]=animal[p]; &#125; Cat.prototype.name=name || 'Tom'; &#125;var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点:支持多继承;缺点: 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 12345678910function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 1.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 2.既是子类的实例，也是父类的实例 3.不存在引用属性共享问题 4.可传参 5.函数可复用缺点：调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 1234567891011121314151617function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点:堪称完美缺点: 实现较为复杂 数组去重给定无序数组，要求去除数组中的重复数组，并且返回新的无重复数组ES6写法： 123var array=[1,2,3,5,2,4,1,9,8];Array.from(new Set(array));console.log(Array.from(new Set(array)));//(7) [1, 2, 3, 5, 4, 9, 8] ES5写法： 12345678910111213console.log(uniqueArray(array));//(7) [1, 2, 3, 5, 4, 9, 8]function uniqueArray(array)&#123; var hashmap=&#123;&#125;; var unique=[]; for(var i=0;i&lt;array.length;i++)&#123; //hasOwnProperty boolean 用于表示一个对象本身是否具有指定名称的属性值 if(!hashmap.hasOwnProperty([array[i]]))&#123; hashmap[array[i]]=1; unique.push(array[i]); &#125; &#125; return unique;&#125; js类多重继承的实现方法是怎么样的其实就是第二部分的代码；1.call/apply 123456789101112131415161718var s1 = function(name)&#123; this.name = name; //专门存放名字的&#125;var s2 = function(sex)&#123; this.sex = sex; //专门存放性别的的&#125;var s3 = function(age)&#123; this.age = age; //专门存放年纪的&#125;var Student = function(name, sex, age, score)&#123; s1.call(this, name); s2.call(this, sex); s3.call(this, age); this.score = score;&#125;Student.prototype.constructor = Student;var s = new Student('jack', 'male', '12', '100');console.log(s.name+" "+s.age+ " " + s.age+" "+ s.score);//jack 12 12 100 1.使用call()实现多重继承，核心就是用Function类的call方法去绑定新的类，使新的类实例化后的对象继承了该属性及方法2.这样我们就可以根据各个不同的功能模块分不同程序员独立开发，最后合并起来，实现了多重继承。3.但它的缺点是基类的方法只能定义在类中，这样在每次实例化的时候都会创建该方法，造成多余内存占用这也是我们上面的构造继承的缺点 2.原型链继承 1234567891011121314151617181920var s1 = function()&#123;&#125;s1.prototype.getName = function()&#123;alert(this.name)&#125;;var s2 = function()&#123;&#125;s2.prototype =new s1();s2.prototype.constructor = s2;s2.prototype.getSex = function()&#123;alert(this.sex)&#125;;var s3 = function()&#123;&#125;s3.prototype = new s2();s3.prototype.constructor = s3;s3.prototype.getAge = function()&#123;alert(this.age)&#125;;var s = new s3();s.name = 'jack';s.sex = 'male';s.age = '22';s.getName();//jacks.getSex();//males.getAge();//22 出现代码冗余，而且无法传递参数 3.混合模式继承就是将上面的两种方式进行结合，扬长避短； 12345678910111213141516171819202122232425var s1 = function(name)&#123;this.name = name;&#125;s1.prototype.getName = function()&#123;alert(this.name)&#125;;var s2 = function(sex)&#123;this.sex = sex;&#125;s2.prototype =new s1();s2.prototype.getSex = function()&#123;alert(this.sex)&#125;;var s3 = function(age)&#123;this.age = age&#125;s3.prototype = new s2();s3.prototype.getAge = function()&#123;alert(this.age)&#125;;var s4 = function(name, sex, age)&#123;s1.call(this, name);s2.call(this, sex);s3.call(this, age);&#125;s4.prototype = new s3();s4.prototype.constructor = s4;var s = new s4('jack', 'male', '25');s.getName();//jacks.getSex();//males.getAge();//25 1.属性用构造的方法，方法采用原型模式；大大提高了效率 js中的作用域是什么样子的变量作用域全局变量的作用域：全局，在代码定义的任何地方都是有定义的；局部变量和函数的参数只有在函数体内才有定义另外，局部变量的优先级要高于同名的全局变量，也就是说当局部变量与全局变量重名时，局部变量会覆盖全局变量； 123456var num = 1; //声明一个全局变量function func() &#123; var num = 2; //声明一个局部变量 return num;&#125;console.log(func()); //输出：2 注：声明局部变量时一定要使用var,否则，解释器会将该变量当做全局对象window的属性。 函数作用域在JavaScript中函数作用域（变量在声明它们的函数体以及这个函数体嵌套的任意函数体都是有定义的） 123456function func() &#123; console.log(num); //输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的 var num = 1; //声明num 在整个函数体func内都有定义 console.log(num); //输出：1 &#125; func(); JavaScript的函数作用域是指在在函数内声明的所有变量在函数体内始终是可见的，也就是说在函数体内变量声明之前就已经可用了作为属性的变量，当声明一个全局变量的时候，实际上是定义了全局对象window的一个属性 12var num = 1; //声明全变量num alert(window.num) //输出：1 声明的全局变量实际上就是声明了一个window对象的属性 js中的this指的是什么1.在全局作用域时：this指向window 1console.log(this === window); //true 因此,我们在全局作用域声明的变量也会指向this 123var x = 1;console.log(this.x);//1console.log(window.x);//1 2.当在函数中时,this指向调用函数的那个对象。 1234567var x = 0;function num()&#123; this.x = 1;&#125;console.log(this.x);//0num();console.log(this.x);//1 这里就是经常容易犯得错误，很多人觉得，当this已经在一个function之中时，其目前所处位置为当前的局部作用域，所以目前指向的应该是此函数 但是，如果你将这个函数实例化（new）之后，此函数将生成一个全新的环境，此时在此实例中的this也会随之发生变化，它将指向所在实例。 12345678num = "0";function setThis()&#123; this.num = "1";&#125;console.log(this.num);//"0"new setThis();console.log(this.num);//"0"console.log(new setThis().num);//1 另外，在我们写javascript的时候，我们通常还会有一种调用函数的方法，即为元素绑定事件，比如button.addEventListener(‘click’, fn, false)等，如果在fn里面需要使用到this的话，那么此时this指向事件处理元素，也就是button 3.作为对象调用时,this 指代上级对象 1234567function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1]]></content>
      <categories>
        <category>前端面试题整理</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2+ 设置组件样式的那些事]]></title>
    <url>%2Fangular%2Fstyle%2Fcomponent-style20170902%2F</url>
    <content type="text"><![CDATA[你用Angular吗？ 介绍 :如何只改动最简单的css代码，呈现完全不一样的视图效果。第一种：最基本的设置： &nbsp; 图1 代码图2 界面运行效果图平常，想给一个label或者p等标签添加样式，我们就是这样操作，在Angular中也是一样的。现在，如果我想要将字体换成红色呢，首先想到的就是去修改.label里的color属性值，可如果样式表是封装的或者外部引用的，不方便修改呢？这时候就要用到ElementRef 和Renderer2了。可以去Angular 官网里搜索哟。&nbsp; renderer.class 图 第二种:我们可以这样用 &nbsp; label.html&nbsp; label.ts当然ElementRef和renderer2都引用自@angular/core库里面的。 至于ViewChild 和ngAfterViewInit()可以自行去了解。&nbsp;&nbsp;&nbsp; 修改效果图 当然，你说这样修改的弊端有没有呢？肯定是有的，因为，this.el.nativeElement获取的是当前元素，如果用*ngFor生成了一系列的label的话，它只会给你修改第一个label的。那有没有其他的办法可以修改呢。当然也是有的！ 第三种：我们可以获取到元素的节点进行操作? &nbsp; label.ts 获取元素节点，还是用上面的elementref。 如果要改变所有的，For循环皆可以啦。可是，这样做又有问题了？如果想不同的label不同字体颜色怎么办呢？当然Angular也提供了方法呀？ ngStyle和ngClass可以用呀！ &nbsp;ngStyle [ngStyle]=”{color:’&nbsp; ‘}”&nbsp; 和[style.color]是一样的意思。你的label想变成什么颜色，你就给我传那个值进来，0就是green……这种适用于只需要修改少量属性的标签。如果你需要修改颜色，字体大小，间距….这种方式显然太繁琐，这时候ngclass就来了。&nbsp;ngclass注意ngClass后面的字样。label为什么没有用单引号呢，而后面的text-primary却有呢？.label是一个变量，我们的样式是可以传参的。也就是你的html标签不需要改动，需要什么样式就在ts离传入即可。ngClass也可以利用这个特性去修改。其实这几种用的地方也挺多的，不过得根据实际需求去采用不同形式。欢迎来找我交流Angular 或前端技术哟。]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>ngStyle</tag>
        <tag>ngClass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2+ 路由的那些事]]></title>
    <url>%2Fangular%2Froute%2Ftitle20170901%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路由的作用就是（导航）：会加载与请求路由相关联的组件，并获取特定路由的相关数据，这允许我们通过控制不同的路由，获取不同的数据，从而渲染不同的页面； 几种常见的路由配置：Angular路由器是一个可选的外部Angular NgModule ，叫RouterModule;路由器里面包含多种服务(RouterModule)，多种指令（RouterOutlet，RouterLink,RouterLinkActive），和一套配置（Routes）; 123456789import &#123; RouterModule&#125; from '@angular/router'; RouterModule.forRoot([ &#123; path: 'test', component: TestComponent &#125; ]) &lt;a routerLink="test"&gt;Test&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; 详细解析：路由定义包括下面部分： [1] Path:路由器会用它来匹配浏览器地址栏中的地址，如’test’; [2] Component:导航到此路由时，需要加载的组件；注意，path不能以斜杠（/）开头。 路由器会为解析和构建最终的URL，这样当我们在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。 另外： 这里用到了RouterModule对象为我们提供的两个静态方法：forRoot()和forChild() 来配置路由信息； forRoot()方法提供了路由需要的路由服务提供商和指令，并基于当前浏览器 URL 初始化导航；用于在模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令； a标签中的routerLink 指令绑定一个字符串，字符串是path路径中配置的字符串，它将告诉路由器，当用户点击这个链接时，应该导航到哪里； 当然routerLink还可以绑定一个数组，就是我们的带参路由,下面会具体介绍的：1&lt;a [routerLink]="['/test', id]"&gt;test&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以在上面这样配置添加一个routerLinkActive指令, 我们需要让用户知道哪个路由处于激活状态，通常情况下我们通过向激活的链接添加一个 class 来实现该功能,然后我们写一个active的类:1234&lt;a routerLink="test" routerLinkActive="active"&gt;test&lt;/a&gt; .active&#123; color：red &#125; &nbsp;&nbsp;&nbsp;&nbsp;当此路由被点击时，字体会变成红色；这也是routerLinkActive的作用，使我们知道哪个路由处于激活状态；当然还可以添加上这个[routerLinkActiveOptions]=”{exact: true}” 只有当路由完全一样时，才会将active类加载上去：1&lt;a routerLink="dashboard" routerLinkActive="active" [routerLinkActiveOptions]="&#123;exact: true&#125;"&gt;Dashboard&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;chrome控制台这样显示：&nbsp;&nbsp;&nbsp;&nbsp;可见routerLink还是会自动将路由链接到href上的；class=”active“也作用上去啦；当切换路由时：class=”active” 移到我点击的路由上，只是应该是调用了：ngAfterContentInit(),ngOnChanges(),ngOnDestroy() 注意：第一个路径片段可以以 / ，./ 或 ../ 开头： 如果以 / 开头，路由将从根路由开始查找 如果以 ./ 开头或没有使用 / ，则路由将从当前激活路由的子路由开始查找 如果以 ../ 开头，路由往上一级查找1&lt;a [routerLink]="['../test', id]"&gt;test&lt;/a&gt; 当然这里我们也可以通过在component里控制写:123456import &#123;Router&#125; from '@angular/router';&lt;a (click)="go()"&gt;Heroes&lt;/a&gt;constructor(private router: Router) &#123;&#125;go() &#123; this.router.navigate(['heroes']);&#125; 这种效果也是一样的；这里就需要注入router服务：router方法用于切换路由很有用，下面会具体来介绍router服务的； 路由出口:RouterOutlet是由RouterModule提供的指令之一。当我们在应用中导航时，路由器就把激活的组件显示在&lt;/router-outlet&gt; 里面。不写1&lt;router-outlet&gt;&lt;/router-outlet&gt; 会导致组件内容不加载进来，从而不显示内容；但是一个组件可以共用一个routeroutlet，所以app.component.ts里面配置即可：1&lt;router-outlet&gt;&lt;/router-outlet&gt; 第二种写法：请看代码：12345678910111213RouterModule.forRoot([...]) 将[] 及中间的内容当成配置文件提取出去；RouterModule.forRoot(routes),routes是我们需要导入的配置文件参数名：import &#123; routes&#125; from './app-routing.module';app-routing.module:中我们可以这样写：import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';import &#123; HeroDetailComponent &#125; from './detail/hero-detail.component';export const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'detail/:id', component: HeroDetailComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;, &#123; path: '**', component:DashboardComponent&#125;]; 注意： { path: ‘’, redirectTo: ‘/dashboard’, pathMatch: ‘full’ } 表示重定向路由：需要一个pathMatch属性，告诉路由器是如何用URL去匹配路由的路径的，没有这个属性就会报错；意思就是当路由URL等于’’时，会去加载DashboardComponent组件；所以你运行你的服务端口号：localhost:4200首先加载的就会是这个组件；{ path: “**”, component:DashboardComponent} **路径是一个通配符，表示除了以上几种path,任何的路径都会加载DashboardComponent组件，这个记得写在路由配置最后 当然这种方式我们还能这么写: 无declarations！声明是关联模块的重点。我们将AppRoutingModule抛出去，当做一个路由模块， 1234567891011121314import &#123; NgModule &#125; from '@angular/core';import &#123; Routes,RouterModule&#125; from '@angular/router';import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;];@NgModule(&#123; imports: [ RouterModule.forChild(routes) ], exports: [ RouterModule ]&#125;)export class AppRoutingModule &#123;&#125; app.module.ts中引入： 1import &#123; AppRoutingModule&#125; from './app-routing.module'; imports:中导入这个就可以啦AppRoutingModule这种用法和上面这种用法是一样的还有一点：如何解决第二次刷新出现404问题： 1[RouterModule.forRoot(routes,&#123;useHash:true&#125;)] 配置后面这一点，通过添加一个#，防止刷新第二次出现404；http://localhost:4201/#RouterModule.forChild(routes)写在子模块里面，而且这边用的是forChild(),不是forRoot（）,使用forRoot()也是不会错的，但是一般情况下根模块中使用forRoot()，子模块中使用forChild() forChild()只能用在特性模块中，这样的一点好处就是我们不必在主模块就配置好所有的路由信息，在需要的时候将他们导入主模块； 参数化路由1&#123; path: 'detail/:id', component: HeroDetailComponent &#125;, 配置参数化路由格式： :id 是一个占位符，当导航到HeroDetailCompnent组件上时，会被填入一个特定的id；这里我们是这样绑定的：1&lt;a *ngFor="let hero of heroes" [routerLink]="['/detail', hero.id]" class="col-1-4"&gt;&lt;/a&gt; eg: http://localhost:4201/detail/11 这时的id等于11； [1]传参类型的id作用可以根据传入的id不同让HeroDetailComponent显示不同的内容； [2]但是怎么能让其显示不同的内容呢？ 也就和我们这个id有关系，如何获取这个id 用在我们的组件里面呢？ [3]通过注入ActivatedRoute服务，一站式获取路由信息；1234import &#123; ActivatedRoute&#125; from '@angular/router'; constructor( private route: ActivatedRoute, ) &#123;&#125; 接下来我们这样试试：1234567public params;this.route.params.subscribe( params =&gt; &#123; this.params = params; console.log(this.params); &#125; ); 这样获取来的是一个对象：直接取id就能获取到了；既然是一站式获取，肯定不止这几个功能 后面会具体介绍它： 路由配置是也可以通过子路由来配置children：1234567&#123; path: 'heroes', component: HeroesComponent, children: [ &#123; path: 'heroTest', component: HeroTestComponent &#125;, ] &#125; 是这样配置的；此时HeroTestComponent组件的路由其实是:’heroes/heroTest’; 懒加载loadChildren:1234&#123; path:'loadtest', loadChildren:'./loadtest/loadtest.module#LoadtestModule' &#125; 路由是这样配置的： [1]这里注意几点：1import &#123; LoadtestComponent &#125; from './loadtest/loadtest.component'; 组件不需要在app.module.ts引入 [2]loadtest.module.ts 也不需要在app.module.ts中引入；而是通过loadchildren属性，在需要的时候告诉Angular路由依据loadchildren属性配置的路径去加载LoadtestModule模块，这就是模块懒加载功能；当用户需要的时候才回去加载，大大减少了应用启动时的资源加载大小； [3] loadChildren后面的字符串由三部分组成：(3.1) 需要导入模块路劲的相对路径(3.2) #分隔符(3.3) 导出模块类的名称 [4]还有一点也是也是重要的：loadtestModule代码是这样的：里面要引入自己的路由； 123456789101112131415import &#123; NgModule &#125; from '@angular/core';import &#123;CommonModule&#125; from '@angular/common';import &#123; LoadtestComponent &#125; from './loadtest.component';import &#123;RouterModule&#125; from '@angular/Router';import &#123;route&#125; from './loadtest-routing.module';@NgModule(&#123; imports:[ CommonModule, RouterModule.forChild(route), ], declarations:[ LoadtestComponent ]&#125;)export class LoadtestModule&#123;&#125; 在route路由里面记得这样配置这样一句才不会出错：1234567import &#123; LoadtestComponent &#125; from './loadtest.component';export const route = [ &#123; path:'', component: LoadtestComponent &#125;,] path:’’,才能保证代码不出错；懒加载的文件要注意：app.module.ts中：1234567declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent, TestComponent, ], 这里面的文件，采用懒在家的模块是引用不到得，因为lazy加载文件有自己的ngModule ，如果要使用的组件是同一个，最好建立一个shareModule模块；采用commonModule 将共享文件放进去，之后的Module里使用再加载进imports中； Router服务：123456789101112131415161718192021 class Router&#123;2. errorHandler:ErrorHandler3. navigated: boolean4. urlHandlingStrategy:UrlHandlingStrategy5. routeReuseStrategy:RouteReuseStrategy6. config:Routes7. initialNavigation():void8. setUpLocationChangeListener():void9. get routerState():RouterState10. get url(): string11. get events():Observable&lt;Event&gt;12. resetConfig(config:Routes):void13. ngOnDestroy():void14. dispose():void15. createUrlTree(commands: any[], navigationExtras:NavigationExtras):UrlTree16. navigateByUrl(url: string|UrlTree, extras:NavigationExtras):Promise&lt;boolean&gt;17. navigate(commands: any[], extras:NavigationExtras):Promise&lt;boolean&gt;18. serializeUrl(url:UrlTree): string19. parseUrl(url: string):UrlTree20. isActive(url: string|UrlTree, exact: boolean): boolean21. &#125; 这是Router API为我们提供的方法和属性； 看看几个常用的： navigate()该方法支持的参数类型和routerLink指令一样，所以他们的作用也是一样的：1this.router.navigate(['test', id]); 或者1this.router.navigate(['test']); 调用该方法后页面会自动跳转到对应的路由地址；1this.router.navigate(['test'], &#123; relativeTo: this.route&#125;); 我们可以设置一个参照路径，参照路径this.route从ActivatedRoute里面取；配置这个可以让自己知道相对于什么位置导航，this.route就是相对于当前的路由进行导航，假如当前url：localhost:4200/hero ,那么导航后的结果就是：localhost:4200/hero/test navigateByUrl() 这个叫做绝对路由；1this.router.navigateByUrl('home'); 可以帮助你快速的切换到某个路由下面，如果你当时的路由是这样的：localhost:4200/hero/test 点击这个路由后就是：localhost:4200/home 我们一般用这个路由来回到首页；和navigate()的区别还有点是：这个不是根据参数来确定路由地址的 config 会将页面所有的路由配置信息都显示：看看路由树： url 输出当前 的路由patheg：http://localhost:4200/detail/11url: /detail/11 每次导航前都会调用events方法；1RouterModule.forRoot(routes, &#123;enableTracing: true &#125;) 通过在控制台配置enableTracing: true可以在控制台看到相关改变； 注意：enableTracing: true 只能在forRoot()里面添加具体的事件有： chrome控制台:注意：这些事件是以Observable的形式提供的 ActivateRoute API :12345678910111213141516171819interface ActivatedRoute &#123;snapshot: ActivatedRouteSnapshoturl: Observable&lt;UrlSegment[]&gt;params: Observable&lt;Params&gt;queryParams: Observable&lt;Params&gt;fragment: Observable&lt;string&gt;data: Observable&lt;Data&gt;outlet: stringcomponent: Type&lt;any&gt;|string|nullget routeConfig(): Route|nullget root(): ActivatedRouteget parent(): ActivatedRoute|nullget firstChild(): ActivatedRoute|nullget children(): ActivatedRoute[]get pathFromRoot(): ActivatedRoute[]get paramMap(): Observable&lt;ParamMap&gt;get queryParamMap(): Observable&lt;ParamMap&gt;toString(): string&#125; parmaMap123456789第一步：import &#123; Router, ActivatedRoute, ParamMap &#125; from '@angular/router';第二步：import 'rxjs/add/operator/switchMap';导入switchMap操作符是因为我们稍后将会处理路由参数的可观察对象Observable ;会在以后的章节中介绍操作符的；第三步：constructor( private heroService: HeroService, private route: ActivatedRoute, private router: Router, ) &#123;&#125;&lt;code&gt; &lt;br&gt;&lt;/code&gt; 假定事先写好了HeroService： 1234this.route.paramMap .switchMap((params: ParamMap) =&gt; this.heroService.getHero(+params.get('id'))) .subscribe(hero =&gt; this.hero = hero ); &#125; 我们这样操作，前面已经介绍过用parmas获取参数；所以这样写也可以，用的是paramMap就引入paramMap，params就引入Params 123456this.route.params .switchMap((params: Params) =&gt; this.heroService.getHero(+params['id'])) .subscribe(hero =&gt; this.hero = hero; &#125; ); 由于参数是作为Observable提供的，所以我们得用switchMap操作符来根据名字取得id参数，并告诉HeroService来获取带有那个id的英雄。 snapshot(快照)route.snapshot提供了路由参数的初始值。 我们可以通过它来直接访问参数，而不用订阅或者添加Observable的操作符所以获取参数的id还可以这样：12&lt;a *ngFor="let hero of heroes" [routerLink]="['/detail', hero.id]" class="col-1-4"&gt;&lt;/a&gt; &lt;br&gt;this.params = this.route.snapshot.paramMap.get('id');&lt;br&gt;&lt;br&gt;console.log(this.params); 所以上面的代码改成这样更好： 1234this.params = this.route.snapshot.paramMap.get('id'); console.log(this.params);this.heroService.getHero(this.params) .then(hero =&gt; this.hero = hero); 两种方法：params 和snapshot到底什么时候该用哪种呢？ 需要直接访问参数，主要获取初始值，不用订阅的情况下用snapshot； 需要连续导航多次的用params; 总结 ,路由主要是用到了这些方面啦： 给路由添加一些新特性：添加动画[1] 在app.module.ts中引入启用Angular动画必备的, 记得在imports中导入：1import &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations'; [2] 在app.component.ts同级下创建一个animation.ts文件，用来存放我们的动画效果； 1234567891011121314151617181920212223 import &#123; animate, AnimationEntryMetadata, state, style, transition, trigger &#125; from '@angular/core';export const slideInDownAnimation: AnimationEntryMetadata = trigger('routeAnimation', [ state('*', style(&#123; opacity: 1, transform: 'translateX(0)' &#125;) ), transition(':enter', [ style(&#123; opacity: 0, transform: 'translateX(-100%)' &#125;), animate('0.2s ease-in') ]), transition(':leave', [ animate('0.5s ease-out', style(&#123; opacity: 0, transform: 'translateY(100%)' &#125;)) ]) ]); 假定我有以上代码，视图进场和出场； 构建动画需要的库； 导出了一个名叫slideInDownAnimation的常量，并把它设置为一个名，用于外部引入此ts文件； 叫routeAnimation的动画触发器。带动画的组件将会引用这个名字。用在外部html页面引用 指定了一个通配符状态 —— *，它匹配该路由组件存在时的任何动画状态。 定义两个过渡效果，其中一个（:enter）在组件进入应用视图时让它从屏幕左侧缓动进入（ease-in），另一个（:leave）在组件离开应用视图时让它向下飞出。 [3] 如何使用动画； 在需要的组件中引入变量名为：slideInDownAnimation的文件animation.ts； 1import &#123;slideInDownAnimation&#125; from '../animation'; [4]组件中配置12templateUrl: 'hero-detail.component.html',animations: [slideInDownAnimation] [5]html模板中这样引入：1&lt;div *ngIf="hero" [@routeAnimation]="'active'"&gt; @routeAnimation 动画触发器名 点击之后会自动加载动画的； 多重路由出口一般情况下：我们使用一个路由出口就行啦，什么情况下会使用第二路由呢？ 1.创建一个新组件ComposemessageComponent2.路由配置：12345&#123; path:'compose', component:ComposemessageComponent, outlet:'popup' &#125; 3.html页面这样配置：123456789&lt;nav&gt; &lt;a routerLink="dashboard" routerLinkActive="active" [routerLinkActiveOptions]="&#123;exact: true&#125;"&gt;Dashboard&lt;/a&gt; &lt;a (click)="go()" &gt;Heroes&lt;/a&gt; &lt;a routerLink="test" routerLinkActive="active" [routerLinkActiveOptions]="&#123;exact: true&#125;"&gt;Test&lt;/a&gt; &lt;a routerLink="loadtest" routerLinkActive="active"&gt;loadTest&lt;/a&gt; &lt;a [routerLink]="[&#123; outlets: &#123; popup: ['compose'] &#125; &#125;]"&gt;Contact&lt;/a&gt; &lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;router-outlet name="popup"&gt;&lt;/router-outlet&gt; 这是我的页面所有的路由配置；点击Contact 不会替换其他的组件信息，注意看Url:http://localhost:4200/dashboard(popup:compose)点击Contact url地址没有变成http://localhost:4200/contact而是采用圆括号加载 圆括号包裹的部分是第二路由。 第二路由包括一个出口名称（popup）、一个冒号分隔符和第二路由的路径（compose）而是显示在下面，点击test也是一样： Contact路由加载的组件不会被清除，一直显示在下面，状态一直被激活；这里我们就能知道第二路由的用处：即使在应用中的不同页面之间切换，这个组件也应该始终保持打开状态，多重出口可以在同一时间根据不同的路由来显示不同的内容；但是什么时候清除我们的第二路由呢？如果我页面不需要呢？注意：1234&lt;a (click)="go()" &gt;Heroes&lt;/a&gt;go() &#123; this.router.navigateByUrl('heroes'); &#125; 当点击Heroes时，Contact路由加载的内容就不会被显示：原因是这样的：它使用Router.navigateNyUrl()方法进行强制导航,所以路由清除啦；还可以这样清除： 123this.router.navigate([&#123; outlets: &#123; popup: null &#125;&#125;]);outlets属性的值是另一个对象，该对象用一些出口名称作为属性名。 唯一的命名出口是'popup'。但这里，'popup'的值是null。null不是一个路由，但却是一个合法的值。 把popup这个RouterOutlet设置为null会清除该出口，并且从当前URL中移除第二路由popup 路由守卫按照上面所说：任何用户都能在任何时候导航到任何地方，这样就有问题，可能此用户并没有权限切换到此路由，可能用户未登陆不能切换，或者做一些友好提示之后再切换；所以路由守卫就来了：守卫返回一个值，以控制路由器的行为： 如果它返回true，导航过程会继续 如果它返回false，导航过程会终止，且用户会留在原地。也就是你导航的路由是可以取消的，路由守卫还有一个好处就是回退功能时，可以防止用户无限回退，走出app；路由守卫怎么做：用CanActivate来处理导航到某路由的情况。用CanActivateChild来处理导航到某子路由的情况。用CanDeactivate来处理从当前路由离开的情况.用Resolve在路由激活之前获取路由数据。用CanLoad来处理异步导航到某特性模块的情况。 返回的值是一个Observable或Promise，路由器会等待这个可观察对象被解析为true或false。在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。看看路由守卫怎么实现：1.new 一个新项目activeComponent;2.编写守卫服务： 123456789import &#123; Injectable &#125; from '@angular/core';import &#123; CanActivate &#125; from '@angular/router';@Injectable()export class LoadTestService implements CanActivate&#123; canActivate() &#123; console.log('AuthGuard#canActivate called'); return true; &#125;&#125; 3.路由中这样导入我们的守卫： 123456789101112131415import &#123; ActiveComponent &#125; from './active/active.component';import &#123;LoadTestService&#125; from './loadtest.service';export const route = [ &#123; path:'', component: LoadtestComponent, canActivate:[LoadTestService], children:[ &#123; path:'a', component: ActiveComponent &#125; ] &#125;,] 这样我们的ActiveComponent就是受保护的； 当然这只是模拟；还有更多用法，以后来列举；]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>router</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
</search>
