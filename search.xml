<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端面试中遇见的那些纯js题]]></title>
    <url>%2Fjs120170905%2F</url>
    <content type="text"><![CDATA[js 定义类有哪些常用的方法？1.工厂方式12345678910111213function Car()&#123; var ocar=new Obejct; //不用括号 ocar.color='blue'; ocar.doors=4; ocar.showColor=function()&#123; this.color; &#125; return ocar;&#125;var car1=Car();var car2=Car();console.log(car1); //&#123;color: "blue", doors: 4, snowColor: ƒ&#125; f指的是function()console.log(car2); //&#123;color: "blue", doors: 4, snowColor: ƒ&#125; 注： 1.调用此方法时，将创建新的对象，并赋予它所有的属性和方法。使用此函数可以创建两个属性完全相同的对象；2.我们可以通过给函数传递不同的参数来得到具有不同值得对象 12345678910111213function Car(color,door)&#123; var ocar=new Object; ocar.color=color; ocar.doos=door; ocar.showColor=function()&#123; console.log(this.color); &#125; return ocar;&#125;var car1=Car("red",5);var car2=car("blue",4);car1.showColor(); //red；car2.showColor(); //blue &nbsp;&nbsp;在上面的两个例子中，每次创建一个Car()对象都会创建一个showColor()，意味着每个对象都有自己的showcolor()方法，但是实际上每个对象可以共享同一个函数，最后通过将函数的属性指向该方法 123456789101112function showColor()&#123; console.log(this.color); &#125; function Car(color,door)&#123; var ocar=new Object(); ocar.color=color; ocar.doors=door; ocar.showColor=showColor; return ocar; &#125; var car1=new Car('red',4); car1.showColor(); 当然这里扯远了 2.构造函数方法 这个和工厂方式差不多 1234567891011function Car(color,door)&#123; this.color=color; this.doors=door; this.showColor=function()&#123; console.log(this.color); &#125; &#125; var car1=new Car("red",4); var car2=new Car("blue",5); car1.showColor();//red car2.showColor();//blue 注： 这种模式和工厂的方式区别在于，不用通过自己去New一个对象，而是使用this关键字；因为在调用构造函数时就已经创建了对象，而在函数内部只能通过this来访问此对象但是，它和工厂方式一样，每次调用对象都会创建自己的方法 3.原型方式 该方式利用了对象的prototype属性，首先用空函数创建类名，然后所有的属性和方法都被赋予prototype属性； 12345678910function Car()&#123;&#125;Car.prototype.color="red";Car.prototype.doors=4;Car.prototype.showColor=function()&#123; console.log(this.color);&#125;var car1=new Car();var car2=new Car(); console.log(car1); 看看最后输出的是什么 注： 1.首先定义一个空函数，然后通过prototype属性来定义对象的属性；调用该函数时，原型的所有属性都会立即赋予要创建的对象，所有该函数的对象存放的对是指向showColor()的指针，语法上看起来都属于同一个对象；2.但是这个函数没有参数，不能通过传参来初始化属性，必须要在对象创建后才能改变属性的默认值；3.原型方式还有个很大的弊端；如果属性指向的是对象时： 12345678910111213function Car()&#123;&#125;Car.prototype.color="red";Car.prototype.doors=4;Car.prototype.arr=new Array('a',"b");Car.prototype.showColor=function()&#123; console.log(this.color);&#125;var car1=new Car();var car2=new Car();car1.arr.push('cc');console.log(car1.arr); //(3) ["a", "b", "cc"]console.log(car2.arr); //(3) ["a", "b", "cc"] 注： arr对象指向的是一个数组，这里用的是数组的引用值，Car的两个对象指向的都是同一个数组所以car1添加值以后，在car2中也能看到值；形式是这样的： 4.联合方式（构造函数+原型方式)123456789101112131415function Car(color,door)&#123; this.color=color; this.doors=door; this.arr=new Array("aa","bb"); &#125;; Car.prototype.showColor=function()&#123; console.log(this.color); &#125; var car1=new Car("red",4); var car2=new Car("blue",5); car1.arr.push("cc"); console.log(car1); console.log(car1.arr); // (3) ["aa", "bb", "cc"] console.log(car2.arr); //(2) ["aa", "bb"] 首先来看看car1对象注： 1.car1和car2对象都有自己单独的arr属性，所以改变其中一个另一个并不会受影响2.此方式是用构造函数定义对象的非函数属性，用原型对象定义对象的方法 5.动态原型方式 和混合模式相似，区别就是赋予对象方法的位置不一样； 12345678910111213141516function Car(color,door)&#123; this.color=color; this.doors=door; this.arr=new Array("aa","bb"); if(typeof Car._initialized =="undefined")&#123; Car.prototype.showColor=function()&#123; console.log(this.color); &#125;; Car._initialized=true; &#125;;&#125;var car1=new Car('blue',3);var car2=new Car('red',3);car1.showColor();car2.showColor();console.log(car1); 注： 此方法是用一个标志来判断是否已经给原型赋予了此方法，这样可以保证该方法只被创建一次 6.混合工厂方式目的是创建假构函数，只返回另一种对象的新实例 123456789101112function Car()&#123; var ocar=new Object();//带括号 ocar.color="red"; ocar.doors=4; ocar.showColor=function()&#123; console.log(this.color); &#125; return ocar;&#125;var car1=new Car();var car2=new Car();car1.showColor(); //red 注： 和工厂方式很像，不通的就是这是通过New运算符 7.对象直接量 采用set get的方式 123456789101112var car1=&#123; color:"", getColor: function()&#123; console.log(this.color); //red return this.color; &#125;, setColor:function(color)&#123; this.color=color; &#125;&#125;car1.setColor('red');car1.getColor(); 8.定义函数对象1234567891011121314var car2=new Function(); //注意大写car2.prototype = &#123; color:"", getColor:function()&#123; console.log(this.color);//blue return this.color; &#125;, setColor:function(color)&#123; this.color=color; &#125;&#125;car2.prototype.setColor('blue');car2.prototype.getColor();console.log(car2.prototype);//&#123;color: "blue", getColor: ƒ, setColor: ƒ&#125; 也是运用上面的原型方式和混合工厂模式 js类继承的方法有哪些 既然是继承，首先得有个父类 12345678910111213//定义一个动物类 function Animal(name)&#123; //给一个Name属性 this.name=name || 'Animal'; //实例方法 this.sleep=function()&#123; console.log(this.name+" 在睡觉")； &#125; &#125; //原型方法 Animal.prototype.eat=function(food)&#123; console.log(this.name + '正在吃' +food); &#125; 原型链继承 核心： 将父类的实例作为子类的原型 12345678910function Cat()&#123;&#125;Cat.prototype=new Animal();Cat.prototype.name='cat';var cat=new Cat();console.log(cat.name); //catconsole.log(cat.eat('fish')); //cat正在吃fishconsole.log(cat.sleep()); //cat 在睡觉console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 注： 使用的的原型方式；特点: 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法和原型属性，子类都能访问 简单，易于实现 缺点: 要想为子类新增方法和属性，必须要在new Animal()这样的语句指向之后，不能放在构造器中； 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 12var cat1=new Cat()console.log(cat1.name) //cat 构造继承 call（）123456789function Cat(name)&#123; Animal.call(this); this.name=name || 'Animal';&#125;var cat=new Cat('cat');console.log(cat.name); //catconsole.log(cat.sleep()); //cat 在睡觉console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 注： 这里是调用不到eat原型方法的;特点: 解决了1中，子类实例共享父类引用属性的问题； 创建实例时，可以向父类传参； 可以实现多继承（call 多个父类对象); 缺点: 实例并不是父类的实例 只能继承父类的实例和方法，并不能继承原型属性和方法； 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承 instace核心： 为父类实例添加新特性，作为子类实例返回 12345678910 function Cat(name)&#123; var instace=new Animal(); instace.name=name || 'Animal'; return instace; &#125;var cat=new Cat();console.log(cat.name); //Animalconsole.log(cat.sleep()); //Animal 在睡觉console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点: 1.不限制调用方法，不管是new 子类()还是子类(),返回的对象具有相同的效果；缺点: 1.实例是父类的实例，不是子类的实例 2.不支持多继承 拷贝继承 123456789101112 function Cat(name)&#123; var animal=new Animal(); for(var p in animal)&#123; Cat.prototype[p]=animal[p]; &#125; Cat.prototype.name=name || 'Tom'; &#125;var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点: 支持多继承; 缺点: 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 12345678910function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 1.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 2.既是子类的实例，也是父类的实例 3.不存在引用属性共享问题 4.可传参 5.函数可复用缺点： 1.调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 1234567891011121314151617function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点:堪称完美 缺点: 实现较为复杂]]></content>
      <categories>
        <category>前端面试题整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述alert和console.log的区别]]></title>
    <url>%2Fconsole20170905%2F</url>
    <content type="text"><![CDATA[生活中还是得有发现美好和差别的眼睛, 学习前端那么久既然还不知道alert和console.log的差别; 本菜鸟一直以为alert和console.log其实是一样的用法，只是alert以弹出框形式呈现，而console.log在控制台输出而已。 知道昨天输出一段代码，结果发现alert和console.log输出结果不一样,本宝宝可算涨见识了, 然后就是各种查阅资料，百度查看，终于发现点眉目啦 ; 我写了这样一段代码：alert输出的结果为：console.log输出的结果为： 然后我就尴尬了 [1]原来console.log() 可以打印任何类型的数据。而 alert() 只能输出string，[2]如果alert输出是对象会自动调用 toString() 方法。如果想 console.log() 输出的与alert相同，需要调用 toString()。[3]所以将后面的改写成&nbsp;console.log(hmac.toString()) 就可以啦 下面再来总结下两者的差别123456789101112alert() 1.1 有阻塞作用，不点击确定，后续代码无法继续执行 1.2 alert()只能输出string,如果alert输出的是对象会自动调用toString()方法 e.g. alert([a,b,c]); //a,b,c 1.3 alert不支持多个参数的写法,只能输出第一个值 e.g. alert(1,2,3); // 1console.log() 2.1 在打印台输出 2.2 可以打印任何类型的数据 e.g. console.log([a,b,c]); //[a,b,c] 2.3 支持多个参数的写法 e.g. console.log(1,2,3) // 1 2 3 好啦~~~就是这样啦。]]></content>
      <categories>
        <category>前端那些微小事</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>console.log</tag>
        <tag>alert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2+ 设置组件样式的那些事]]></title>
    <url>%2Fcomponent-style20170902%2F</url>
    <content type="text"><![CDATA[你用Angular吗？ 介绍 :如何只改动最简单的css代码，呈现完全不一样的视图效果。第一种：最基本的设置： &nbsp; 图1 代码图2 界面运行效果图 平常，想给一个label或者p等标签添加样式，我们就是这样操作，在Angular中也是一样的。 现在，如果我想要将字体换成红色呢，首先想到的就是去修改.label里的color属性值，可如果样式表是封装的或者外部引用的，不方便修改呢？ 这时候就要用到ElementRef 和Renderer2了。可以去Angular 官网里搜索哟。 &nbsp; renderer.class 图 第二种:我们可以这样用 &nbsp; label.html&nbsp; label.ts 当然ElementRef和renderer2都引用自@angular/core库里面的。 至于ViewChild 和ngAfterViewInit()可以自行去了解。 &nbsp;&nbsp;&nbsp; 修改效果图 当然，你说这样修改的弊端有没有呢？肯定是有的，因为，this.el.nativeElement获取的是当前元素，如果用*ngFor生成了一系列的label的话，它只会给你修改第一个label的。那有没有其他的办法可以修改呢。当然也是有的！ 第三种：我们可以获取到元素的节点进行操作? &nbsp; label.ts 获取元素节点，还是用上面的elementref。 如果要改变所有的，For循环皆可以啦。可是，这样做又有问题了？如果想不同的label不同字体颜色怎么办呢？当然Angular也提供了方法呀？ ngStyle和ngClass可以用呀！ &nbsp;ngStyle [ngStyle]=”{color:’&nbsp; ‘}”&nbsp; 和[style.color]是一样的意思。你的label想变成什么颜色，你就给我传那个值进来，0就是green……这种适用于只需要修改少量属性的标签。如果你需要修改颜色，字体大小，间距….这种方式显然太繁琐，这时候ngclass就来了。&nbsp;ngclass注意ngClass后面的字样。label为什么没有用单引号呢，而后面的text-primary却有呢？.label是一个变量，我们的样式是可以传参的。也就是你的html标签不需要改动，需要什么样式就在ts离传入即可。ngClass也可以利用这个特性去修改。其实这几种用的地方也挺多的，不过得根据实际需求去采用不同形式。欢迎来找我交流Angular 或前端技术哟。]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>ngStyle</tag>
        <tag>ngClass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2+ 路由的那些事]]></title>
    <url>%2Ftitle20170901%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路由的作用就是（导航）：会加载与请求路由相关联的组件，并获取特定路由的相关数据，这允许我们通过控制不同的路由，获取不同的数据，从而渲染不同的页面； 几种常见的路由配置： Angular路由器是一个可选的外部Angular NgModule ，叫RouterModule; 路由器里面包含多种服务(RouterModule)，多种指令（RouterOutlet，RouterLink,RouterLinkActive），和一套配置（Routes）; 123456789import &#123; RouterModule&#125; from '@angular/router'; RouterModule.forRoot([ &#123; path: 'test', component: TestComponent &#125; ]) &lt;a routerLink="test"&gt;Test&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; 详细解析：路由定义包括下面部分： [1] Path:路由器会用它来匹配浏览器地址栏中的地址，如’test’; [2] Component:导航到此路由时，需要加载的组件；注意，path不能以斜杠（/）开头。 路由器会为解析和构建最终的URL，这样当我们在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。 另外： 这里用到了RouterModule对象为我们提供的两个静态方法：forRoot()和forChild() 来配置路由信息； forRoot()方法提供了路由需要的路由服务提供商和指令，并基于当前浏览器 URL 初始化导航；用于在模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令； a标签中的routerLink 指令绑定一个字符串，字符串是path路径中配置的字符串，它将告诉路由器，当用户点击这个链接时，应该导航到哪里； 当然routerLink还可以绑定一个数组，就是我们的带参路由,下面会具体介绍的：1&lt;a [routerLink]="['/test', id]"&gt;test&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以在上面这样配置添加一个routerLinkActive指令, 我们需要让用户知道哪个路由处于激活状态，通常情况下我们通过向激活的链接添加一个 class 来实现该功能,然后我们写一个active的类:1234&lt;a routerLink="test" routerLinkActive="active"&gt;test&lt;/a&gt; .active&#123; color：red &#125; &nbsp;&nbsp;&nbsp;&nbsp;当此路由被点击时，字体会变成红色；这也是routerLinkActive的作用，使我们知道哪个路由处于激活状态；当然还可以添加上这个[routerLinkActiveOptions]=”{exact: true}” 只有当路由完全一样时，才会将active类加载上去：1&lt;a routerLink="dashboard" routerLinkActive="active" [routerLinkActiveOptions]="&#123;exact: true&#125;"&gt;Dashboard&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;chrome控制台这样显示：&nbsp;&nbsp;&nbsp;&nbsp;可见routerLink还是会自动将路由链接到href上的；class=”active“也作用上去啦；当切换路由时：class=”active” 移到我点击的路由上，只是应该是调用了：ngAfterContentInit(),ngOnChanges(),ngOnDestroy() 注意：第一个路径片段可以以 / ，./ 或 ../ 开头： 如果以 / 开头，路由将从根路由开始查找 如果以 ./ 开头或没有使用 / ，则路由将从当前激活路由的子路由开始查找 如果以 ../ 开头，路由往上一级查找1&lt;a [routerLink]="['../test', id]"&gt;test&lt;/a&gt; 当然这里我们也可以通过在component里控制写:123456import &#123;Router&#125; from '@angular/router';&lt;a (click)="go()"&gt;Heroes&lt;/a&gt;constructor(private router: Router) &#123;&#125;go() &#123; this.router.navigate(['heroes']);&#125; 这种效果也是一样的；这里就需要注入router服务：router方法用于切换路由很有用，下面会具体来介绍router服务的； 路由出口:RouterOutlet是由RouterModule提供的指令之一。当我们在应用中导航时，路由器就把激活的组件显示在&lt;/router-outlet&gt; 里面。不写1&lt;router-outlet&gt;&lt;/router-outlet&gt; 会导致组件内容不加载进来，从而不显示内容；但是一个组件可以共用一个routeroutlet，所以app.component.ts里面配置即可：1&lt;router-outlet&gt;&lt;/router-outlet&gt; 第二种写法： 请看代码：12345678910111213RouterModule.forRoot([...]) 将[] 及中间的内容当成配置文件提取出去；RouterModule.forRoot(routes),routes是我们需要导入的配置文件参数名：import &#123; routes&#125; from './app-routing.module';app-routing.module:中我们可以这样写：import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';import &#123; HeroDetailComponent &#125; from './detail/hero-detail.component';export const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'detail/:id', component: HeroDetailComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;, &#123; path: '**', component:DashboardComponent&#125;]; 注意： { path: ‘’, redirectTo: ‘/dashboard’, pathMatch: ‘full’ } 表示重定向路由：需要一个pathMatch属性，告诉路由器是如何用URL去匹配路由的路径的，没有这个属性就会报错；意思就是当路由URL等于’’时，会去加载DashboardComponent组件；所以你运行你的服务端口号：localhost:4200首先加载的就会是这个组件； { path: “**”, component:DashboardComponent} **路径是一个通配符，表示除了以上几种path,任何的路径都会加载DashboardComponent组件，这个记得写在路由配置最后 当然这种方式我们还能这么写: 无declarations！声明是关联模块的重点。我们将AppRoutingModule抛出去，当做一个路由模块， 1234567891011121314import &#123; NgModule &#125; from '@angular/core';import &#123; Routes,RouterModule&#125; from '@angular/router';import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;];@NgModule(&#123; imports: [ RouterModule.forChild(routes) ], exports: [ RouterModule ]&#125;)export class AppRoutingModule &#123;&#125; app.module.ts中引入： 1import &#123; AppRoutingModule&#125; from './app-routing.module'; imports:中导入这个就可以啦AppRoutingModule 这种用法和上面这种用法是一样的还有一点：如何解决第二次刷新出现404问题： 1[RouterModule.forRoot(routes,&#123;useHash:true&#125;)] 配置后面这一点，通过添加一个#，防止刷新第二次出现404；http://localhost:4201/# RouterModule.forChild(routes)写在子模块里面，而且这边用的是forChild(),不是forRoot（）,使用forRoot()也是不会错的，但是一般情况下根模块中使用forRoot()，子模块中使用forChild() forChild()只能用在特性模块中，这样的一点好处就是我们不必在主模块就配置好所有的路由信息，在需要的时候将他们导入主模块； 参数化路由1&#123; path: 'detail/:id', component: HeroDetailComponent &#125;, 配置参数化路由格式： :id 是一个占位符，当导航到HeroDetailCompnent组件上时，会被填入一个特定的id；这里我们是这样绑定的：1&lt;a *ngFor="let hero of heroes" [routerLink]="['/detail', hero.id]" class="col-1-4"&gt;&lt;/a&gt; eg: http://localhost:4201/detail/11 这时的id等于11； [1]传参类型的id作用可以根据传入的id不同让HeroDetailComponent显示不同的内容； [2]但是怎么能让其显示不同的内容呢？ 也就和我们这个id有关系，如何获取这个id 用在我们的组件里面呢？ [3]通过注入ActivatedRoute服务，一站式获取路由信息；1234import &#123; ActivatedRoute&#125; from '@angular/router'; constructor( private route: ActivatedRoute, ) &#123;&#125; 接下来我们这样试试：1234567public params;this.route.params.subscribe( params =&gt; &#123; this.params = params; console.log(this.params); &#125; ); 这样获取来的是一个对象：直接取id就能获取到了；既然是一站式获取，肯定不止这几个功能 后面会具体介绍它： 路由配置是也可以通过子路由来配置children：1234567&#123; path: 'heroes', component: HeroesComponent, children: [ &#123; path: 'heroTest', component: HeroTestComponent &#125;, ] &#125; 是这样配置的；此时HeroTestComponent组件的路由其实是:’heroes/heroTest’; 懒加载loadChildren:1234&#123; path:'loadtest', loadChildren:'./loadtest/loadtest.module#LoadtestModule' &#125; 路由是这样配置的： [1]这里注意几点：1import &#123; LoadtestComponent &#125; from './loadtest/loadtest.component'; 组件不需要在app.module.ts引入 [2]loadtest.module.ts 也不需要在app.module.ts中引入；而是通过loadchildren属性，在需要的时候告诉Angular路由依据loadchildren属性配置的路径去加载LoadtestModule模块，这就是模块懒加载功能；当用户需要的时候才回去加载，大大减少了应用启动时的资源加载大小； [3] loadChildren后面的字符串由三部分组成：(3.1) 需要导入模块路劲的相对路径(3.2) #分隔符(3.3) 导出模块类的名称 [4]还有一点也是也是重要的：loadtestModule代码是这样的：里面要引入自己的路由； 123456789101112131415import &#123; NgModule &#125; from '@angular/core';import &#123;CommonModule&#125; from '@angular/common';import &#123; LoadtestComponent &#125; from './loadtest.component';import &#123;RouterModule&#125; from '@angular/Router';import &#123;route&#125; from './loadtest-routing.module';@NgModule(&#123; imports:[ CommonModule, RouterModule.forChild(route), ], declarations:[ LoadtestComponent ]&#125;)export class LoadtestModule&#123;&#125; 在route路由里面记得这样配置这样一句才不会出错：1234567import &#123; LoadtestComponent &#125; from './loadtest.component';export const route = [ &#123; path:'', component: LoadtestComponent &#125;,] path:’’,才能保证代码不出错； 懒加载的文件要注意：app.module.ts中：1234567declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent, TestComponent, ], 这里面的文件，采用懒在家的模块是引用不到得，因为lazy加载文件有自己的ngModule ，如果要使用的组件是同一个，最好建立一个shareModule模块；采用commonModule 将共享文件放进去，之后的Module里使用再加载进imports中； Router服务：123456789101112131415161718192021 class Router&#123;2. errorHandler:ErrorHandler3. navigated: boolean4. urlHandlingStrategy:UrlHandlingStrategy5. routeReuseStrategy:RouteReuseStrategy6. config:Routes7. initialNavigation():void8. setUpLocationChangeListener():void9. get routerState():RouterState10. get url(): string11. get events():Observable&lt;Event&gt;12. resetConfig(config:Routes):void13. ngOnDestroy():void14. dispose():void15. createUrlTree(commands: any[], navigationExtras:NavigationExtras):UrlTree16. navigateByUrl(url: string|UrlTree, extras:NavigationExtras):Promise&lt;boolean&gt;17. navigate(commands: any[], extras:NavigationExtras):Promise&lt;boolean&gt;18. serializeUrl(url:UrlTree): string19. parseUrl(url: string):UrlTree20. isActive(url: string|UrlTree, exact: boolean): boolean21. &#125; 这是Router API为我们提供的方法和属性； 看看几个常用的： navigate() 该方法支持的参数类型和routerLink指令一样，所以他们的作用也是一样的：1this.router.navigate(['test', id]); 或者1this.router.navigate(['test']); 调用该方法后页面会自动跳转到对应的路由地址；1this.router.navigate(['test'], &#123; relativeTo: this.route&#125;); 我们可以设置一个参照路径，参照路径this.route从ActivatedRoute里面取；配置这个可以让自己知道相对于什么位置导航，this.route就是相对于当前的路由进行导航，假如当前url：localhost:4200/hero ,那么导航后的结果就是：localhost:4200/hero/test navigateByUrl() 这个叫做绝对路由；1this.router.navigateByUrl('home'); 可以帮助你快速的切换到某个路由下面，如果你当时的路由是这样的：localhost:4200/hero/test 点击这个路由后就是：localhost:4200/home 我们一般用这个路由来回到首页；和navigate()的区别还有点是：这个不是根据参数来确定路由地址的 config 会将页面所有的路由配置信息都显示：看看路由树： url 输出当前 的路由patheg：http://localhost:4200/detail/11url: /detail/11 每次导航前都会调用events方法；1RouterModule.forRoot(routes, &#123;enableTracing: true &#125;) 通过在控制台配置enableTracing: true可以在控制台看到相关改变； 注意：enableTracing: true 只能在forRoot()里面添加具体的事件有： chrome控制台:注意：这些事件是以Observable的形式提供的 ActivateRoute API :12345678910111213141516171819interface ActivatedRoute &#123;snapshot: ActivatedRouteSnapshoturl: Observable&lt;UrlSegment[]&gt;params: Observable&lt;Params&gt;queryParams: Observable&lt;Params&gt;fragment: Observable&lt;string&gt;data: Observable&lt;Data&gt;outlet: stringcomponent: Type&lt;any&gt;|string|nullget routeConfig(): Route|nullget root(): ActivatedRouteget parent(): ActivatedRoute|nullget firstChild(): ActivatedRoute|nullget children(): ActivatedRoute[]get pathFromRoot(): ActivatedRoute[]get paramMap(): Observable&lt;ParamMap&gt;get queryParamMap(): Observable&lt;ParamMap&gt;toString(): string&#125; parmaMap123456789第一步：import &#123; Router, ActivatedRoute, ParamMap &#125; from '@angular/router';第二步：import 'rxjs/add/operator/switchMap';导入switchMap操作符是因为我们稍后将会处理路由参数的可观察对象Observable ;会在以后的章节中介绍操作符的；第三步：constructor( private heroService: HeroService, private route: ActivatedRoute, private router: Router, ) &#123;&#125;&lt;code&gt; &lt;br&gt;&lt;/code&gt; 假定事先写好了HeroService： 1234this.route.paramMap .switchMap((params: ParamMap) =&gt; this.heroService.getHero(+params.get('id'))) .subscribe(hero =&gt; this.hero = hero ); &#125; 我们这样操作，前面已经介绍过用parmas获取参数；所以这样写也可以，用的是paramMap就引入paramMap，params就引入Params 123456this.route.params .switchMap((params: Params) =&gt; this.heroService.getHero(+params['id'])) .subscribe(hero =&gt; this.hero = hero; &#125; ); 由于参数是作为Observable提供的，所以我们得用switchMap操作符来根据名字取得id参数，并告诉HeroService来获取带有那个id的英雄。 snapshot(快照)route.snapshot提供了路由参数的初始值。 我们可以通过它来直接访问参数，而不用订阅或者添加Observable的操作符所以获取参数的id还可以这样：12&lt;a *ngFor="let hero of heroes" [routerLink]="['/detail', hero.id]" class="col-1-4"&gt;&lt;/a&gt; &lt;br&gt;this.params = this.route.snapshot.paramMap.get('id');&lt;br&gt;&lt;br&gt;console.log(this.params); 所以上面的代码改成这样更好： 1234this.params = this.route.snapshot.paramMap.get('id'); console.log(this.params);this.heroService.getHero(this.params) .then(hero =&gt; this.hero = hero); 两种方法：params 和snapshot到底什么时候该用哪种呢？ 需要直接访问参数，主要获取初始值，不用订阅的情况下用snapshot； 需要连续导航多次的用params; ##总结 ,路由主要是用到了这些方面啦： 给路由添加一些新特性：添加动画 [1] 在app.module.ts中引入启用Angular动画必备的, 记得在imports中导入： 1import &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations'; [2] 在app.component.ts同级下创建一个animation.ts文件，用来存放我们的动画效果； 1234567891011121314151617181920212223 import &#123; animate, AnimationEntryMetadata, state, style, transition, trigger &#125; from '@angular/core';export const slideInDownAnimation: AnimationEntryMetadata = trigger('routeAnimation', [ state('*', style(&#123; opacity: 1, transform: 'translateX(0)' &#125;) ), transition(':enter', [ style(&#123; opacity: 0, transform: 'translateX(-100%)' &#125;), animate('0.2s ease-in') ]), transition(':leave', [ animate('0.5s ease-out', style(&#123; opacity: 0, transform: 'translateY(100%)' &#125;)) ]) ]); 假定我有以上代码，视图进场和出场； 构建动画需要的库； 导出了一个名叫slideInDownAnimation的常量，并把它设置为一个名，用于外部引入此ts文件； 叫routeAnimation的动画触发器。带动画的组件将会引用这个名字。用在外部html页面引用 指定了一个通配符状态 —— *，它匹配该路由组件存在时的任何动画状态。 定义两个过渡效果，其中一个（:enter）在组件进入应用视图时让它从屏幕左侧缓动进入（ease-in），另一个（:leave）在组件离开应用视图时让它向下飞出。 [3] 如何使用动画； 在需要的组件中引入变量名为：slideInDownAnimation的文件animation.ts； 1import &#123;slideInDownAnimation&#125; from '../animation'; [4]组件中配置 12templateUrl: 'hero-detail.component.html',animations: [slideInDownAnimation] [5]html模板中这样引入： 1&lt;div *ngIf="hero" [@routeAnimation]="'active'"&gt; @routeAnimation 动画触发器名点击之后会自动加载动画的； 多重路由出口一般情况下：我们使用一个路由出口就行啦，什么情况下会使用第二路由呢？ 创建一个新组件ComposemessageComponent 路由配置： 12345&#123; path:'compose', component:ComposemessageComponent, outlet:'popup' &#125; html页面这样配置： 123456789&lt;nav&gt; &lt;a routerLink="dashboard" routerLinkActive="active" [routerLinkActiveOptions]="&#123;exact: true&#125;"&gt;Dashboard&lt;/a&gt; &lt;a (click)="go()" &gt;Heroes&lt;/a&gt; &lt;a routerLink="test" routerLinkActive="active" [routerLinkActiveOptions]="&#123;exact: true&#125;"&gt;Test&lt;/a&gt; &lt;a routerLink="loadtest" routerLinkActive="active"&gt;loadTest&lt;/a&gt; &lt;a [routerLink]="[&#123; outlets: &#123; popup: ['compose'] &#125; &#125;]"&gt;Contact&lt;/a&gt; &lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;router-outlet name="popup"&gt;&lt;/router-outlet&gt; 这是我的页面所有的路由配置；点击Contact 不会替换其他的组件信息，注意看Url:http://localhost:4200/dashboard(popup:compose)点击Contact url地址没有变成http://localhost:4200/contact而是采用圆括号加载 圆括号包裹的部分是第二路由。 第二路由包括一个出口名称（popup）、一个冒号分隔符和第二路由的路径（compose）而是显示在下面，点击test也是一样：Contact路由加载的组件不会被清除，一直显示在下面，状态一直被激活；这里我们就能知道第二路由的用处：即使在应用中的不同页面之间切换，这个组件也应该始终保持打开状态，多重出口可以在同一时间根据不同的路由来显示不同的内容；但是什么时候清除我们的第二路由呢？如果我页面不需要呢？ 注意： 1234&lt;a (click)="go()" &gt;Heroes&lt;/a&gt;go() &#123; this.router.navigateByUrl('heroes'); &#125; 当点击Heroes时，Contact路由加载的内容就不会被显示：原因是这样的：它使用Router.navigateNyUrl()方法进行强制导航,所以路由清除啦；还可以这样清除： 123this.router.navigate([&#123; outlets: &#123; popup: null &#125;&#125;]);outlets属性的值是另一个对象，该对象用一些出口名称作为属性名。 唯一的命名出口是'popup'。但这里，'popup'的值是null。null不是一个路由，但却是一个合法的值。 把popup这个RouterOutlet设置为null会清除该出口，并且从当前URL中移除第二路由popup 路由守卫按照上面所说：任何用户都能在任何时候导航到任何地方，这样就有问题，可能此用户并没有权限切换到此路由，可能用户未登陆不能切换，或者做一些友好提示之后再切换；所以路由守卫就来了：守卫返回一个值，以控制路由器的行为： 如果它返回true，导航过程会继续 如果它返回false，导航过程会终止，且用户会留在原地。也就是你导航的路由是可以取消的，路由守卫还有一个好处就是回退功能时，可以防止用户无限回退，走出app； 路由守卫怎么做：用CanActivate来处理导航到某路由的情况。用CanActivateChild来处理导航到某子路由的情况。用CanDeactivate来处理从当前路由离开的情况.用Resolve在路由激活之前获取路由数据。用CanLoad来处理异步导航到某特性模块的情况。 返回的值是一个Observable或Promise，路由器会等待这个可观察对象被解析为true或false。在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。看看路由守卫怎么实现：1.new 一个新项目activeComponent;2.编写守卫服务： 123456789import &#123; Injectable &#125; from '@angular/core';import &#123; CanActivate &#125; from '@angular/router';@Injectable()export class LoadTestService implements CanActivate&#123; canActivate() &#123; console.log('AuthGuard#canActivate called'); return true; &#125;&#125; 3.路由中这样导入我们的守卫： 123456789101112131415import &#123; ActiveComponent &#125; from './active/active.component';import &#123;LoadTestService&#125; from './loadtest.service';export const route = [ &#123; path:'', component: LoadtestComponent, canActivate:[LoadTestService], children:[ &#123; path:'a', component: ActiveComponent &#125; ] &#125;,] 这样我们的ActiveComponent就是受保护的； 当然这只是模拟；还有更多用法，以后来列举；]]></content>
      <categories>
        <category>Angular 2+</category>
      </categories>
      <tags>
        <tag>Angular 2+</tag>
        <tag>router</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
</search>
