[{"title":"Angular 2+ 路由的那些事","date":"2017-09-01T03:08:53.000Z","path":"title20170901/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路由的作用就是（导航）：会加载与请求路由相关联的组件，并获取特定路由的相关数据，这允许我们通过控制不同的路由，获取不同的数据，从而渲染不同的页面； 几种常见的路由配置： Angular路由器是一个可选的外部Angular NgModule ，叫RouterModule; 路由器里面包含多种服务(RouterModule)，多种指令（RouterOutlet，RouterLink,RouterLinkActive），和一套配置（Routes）;123456789import &#123; RouterModule&#125; from '@angular/router'; RouterModule.forRoot([ &#123; path: 'test', component: TestComponent &#125; ]) &lt;a routerLink=\"test\"&gt;Test&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; 详细解析：路由定义包括下面部分： [1] Path:路由器会用它来匹配浏览器地址栏中的地址，如’test’; [2] Component:导航到此路由时，需要加载的组件；注意，path不能以斜杠（/）开头。 路由器会为解析和构建最终的URL，这样当我们在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。解:(1)这里用到了RouterModule对象为我们提供的两个静态方法：forRoot()和forChild() 来配置路由信息；(2)forRoot()方法提供了路由需要的路由服务提供商和指令，并基于当前浏览器 URL 初始化导航；用于在模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令；(3)a标签中的routerLink 指令绑定一个字符串，字符串是path路径中配置的字符串，它将告诉路由器，当用户点击这个链接时，应该导航到哪里；(4) 当然routerLink还可以绑定一个数组，就是我们的带参路由,下面会具体介绍的： 1&lt;a [routerLink]=\"['/test', id]\"&gt;test&lt;/a&gt; (5)还可以在上面这样配置添加一个routerLinkActive指令： 1&lt;a routerLink=\"test\" routerLinkActive=\"active\"&gt;test&lt;/a&gt; 我们需要让用户知道哪个路由处于激活状态，通常情况下我们通过向激活的链接添加一个 class 来实现该功能,然后我们写一个active的类： 123.active&#123; color：red&#125; 当此路由被点击时，字体会变成红色；这也是routerLinkActive的作用，使我们知道哪个路由处于激活状态； 当然还可以添加上这个[routerLinkActiveOptions]=”{exact: true}” 只有当路由完全一样时，才会将active类加载上去： 1&lt;a routerLink=\"dashboard\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"&#123;exact: true&#125;\"&gt;Dashboard&lt;/a&gt; chrome控制台这样显示： 可见routerLink还是会自动将路由链接到href上的；class=”active“也作用上去啦；当切换路由时： class=”active” 移到我点击的路由上，只是应该是调用了：ngAfterContentInit(),ngOnChanges(),ngOnDestroy() 注意：第一个路径片段可以以 / ，./ 或 ../ 开头：如果以 / 开头，路由将从根路由开始查找如果以 ./ 开头或没有使用 / ，则路由将从当前激活路由的子路由开始查找如果以 ../ 开头，路由往上一级查找 1&lt;a [routerLink]=\"['../test', id]\"&gt;test&lt;/a&gt; 当然这里我们也可以通过在component里控制写： 123456import &#123;Router&#125; from '@angular/router';&lt;a (click)=\"go()\"&gt;Heroes&lt;/a&gt;constructor(private router: Router) &#123;&#125;go() &#123; this.router.navigate(['heroes']);&#125; 这种效果也是一样的；这里就需要注入router服务： router方法用于切换路由很有用，下面会具体来介绍router服务的； 路由出口:RouterOutlet是由RouterModule提供的指令之一。当我们在应用中导航时，路由器就把激活的组件显示在里面。不写 1&lt;router-outlet&gt;&lt;/router-outlet&gt; 会导致组件内容不加载进来，从而不显示内容； 但是一个组件可以共用一个routeroutlet，所以app.component.ts里面配置了 1&lt;router-outlet&gt;&lt;/router-outlet&gt; 就可以啦； 第二种写法：12345678910111213RouterModule.forRoot([...]) 将[] 及中间的内容当成配置文件提取出去；RouterModule.forRoot(routes),routes是我们需要导入的配置文件参数名：import &#123; routes&#125; from './app-routing.module';app-routing.module:中我们可以这样写：import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';import &#123; HeroDetailComponent &#125; from './detail/hero-detail.component';export const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'detail/:id', component: HeroDetailComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;, &#123; path: '**', component:DashboardComponent&#125;]; 注意： { path: ‘’, redirectTo: ‘/dashboard’, pathMatch: ‘full’ } 表示重定向路由：需要一个pathMatch属性，告诉路由器是如何用URL去匹配路由的路径的，没有这个属性就会报错；意思就是当路由URL等于’’时，会去加载DashboardComponent组件；所以你运行你的服务端口号：localhost:4200首先加载的就会是这个组件； { path: “**”, component:DashboardComponent} **路径是一个通配符，表示除了以上几种path,任何的路径都会加载DashboardComponent组件，这个记得写在路由配置最后 当然这种方式我们还能这么写: 1234567891011121314import &#123; NgModule &#125; from '@angular/core';import &#123; Routes,RouterModule&#125; from '@angular/router';import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;];@NgModule(&#123; imports: [ RouterModule.forChild(routes) ], exports: [ RouterModule ]&#125;)export class AppRoutingModule &#123;&#125; 无declarations！声明是关联模块的重点。我们将AppRoutingModule抛出去，当做一个路由模块， app.module.ts中引入： 1import &#123; AppRoutingModule&#125; from './app-routing.module'; imports:中导入这个就可以啦AppRoutingModule 这种用法和上面这种用法是一样的还有一点：如何解决第二次刷新出现404问题：1[RouterModule.forRoot(routes,&#123;useHash:true&#125;)] 配置后面这一点，通过添加一个#，防止刷新第二次出现404；http://localhost:4201/#","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路由的作用就是（导航）：会加载与请求路由相关联的组件，并获取特定路由的相关数据，这允许我们通过控制不同的路由，获取不同的数据，从而渲染不同的页面；</p>\n<h2 id=\"几种常见的路由配置：\"><a href=\"#几种常见的路由配置：\" class=\"headerlink\" title=\"几种常见的路由配置：\"></a>几种常见的路由配置：</h2><blockquote>\n<ul>\n<li>Angular路由器是一个可选的外部Angular NgModule ，叫RouterModule;</li>\n<li>路由器里面包含多种服务(RouterModule)，多种指令（RouterOutlet，RouterLink,RouterLinkActive），和一套配置（Routes）;<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; RouterModule&#125; from '@angular/router';</div><div class=\"line\"> RouterModule.forRoot([</div><div class=\"line\">       &#123;</div><div class=\"line\">         path: 'test',</div><div class=\"line\">         component: TestComponent</div><div class=\"line\">       &#125;</div><div class=\"line\"> ]) </div><div class=\"line\">&lt;a routerLink=\"test\"&gt;Test&lt;/a&gt; </div><div class=\"line\">&lt;router-outlet&gt;&lt;/router-outlet&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"详细解析：\"><a href=\"#详细解析：\" class=\"headerlink\" title=\"详细解析：\"></a>详细解析：</h3><h4 id=\"路由定义包括下面部分：\"><a href=\"#路由定义包括下面部分：\" class=\"headerlink\" title=\"路由定义包括下面部分：\"></a>路由定义包括下面部分：</h4><ul>\n<li>[1]  Path:路由器会用它来匹配浏览器地址栏中的地址，如’test’; </li>\n<li><p>[2]  Component:导航到此路由时，需要加载的组件；<br><strong><font color=\"#0099ff\">注意，path不能以斜杠（/）开头。 路由器会为解析和构建最终的URL，这样当我们在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。</font></strong><br><strong>解:</strong><br>(1)这里用到了RouterModule对象为我们提供的两个静态方法：forRoot()和forChild() 来配置路由信息；<br>(2)forRoot()方法提供了路由需要的路由服务提供商和指令，并基于当前浏览器 URL 初始化导航；用于在模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令；<br>(3)a标签中的routerLink 指令绑定一个字符串，字符串是path路径中配置的字符串，它将告诉路由器，当用户点击这个链接时，应该导航到哪里；<br>(4) 当然routerLink还可以绑定一个数组，就是我们的带参路由,下面会具体介绍的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> [<span class=\"attr\">routerLink</span>]=<span class=\"string\">\"['/test', id]\"</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p> (5)还可以在上面这样配置添加一个routerLinkActive指令：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">routerLink</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">routerLinkActive</span>=<span class=\"string\">\"active\"</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<pre><code>我们需要让用户知道哪个路由处于激活状态，通常情况下我们通过向激活的链接添加一个 class 来实现该功能,然后我们写一个active的类：\n</code></pre><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.active&#123;</div><div class=\"line\"> color：red</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>   当此路由被点击时，字体会变成红色；这也是routerLinkActive的作用，使我们知道哪个路由处于激活状态；<br>   当然还可以添加上这个[routerLinkActiveOptions]=”{exact: true}”  只有当路由完全一样时，才会将active类加载上去：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">routerLink</span>=<span class=\"string\">\"dashboard\"</span> <span class=\"attr\">routerLinkActive</span>=<span class=\"string\">\"active\"</span>  [<span class=\"attr\">routerLinkActiveOptions</span>]=<span class=\"string\">\"&#123;exact: true&#125;\"</span>&gt;</span>Dashboard<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>  chrome控制台这样显示：<br><img src=\"/images/router-1.png\" alt=\"cmd-markdown-logo\"><br>  可见routerLink还是会自动将路由链接到href上的；class=”active“也作用上去啦；当切换路由时：<br><img src=\"/images/router-2.png\" alt=\"cmd-markdown-logo\"><br>  class=”active” 移到我点击的路由上，只是应该是调用了：ngAfterContentInit(),ngOnChanges(),ngOnDestroy()</p>\n<blockquote>\n<p>注意：第一个路径片段可以以 / ，./ 或 ../ 开头：<br>如果以 / 开头，路由将从根路由开始查找<br>如果以 ./ 开头或没有使用 / ，则路由将从当前激活路由的子路由开始查找<br>如果以 ../ 开头，路由往上一级查找 </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> [<span class=\"attr\">routerLink</span>]=<span class=\"string\">\"['../test', id]\"</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n</blockquote>\n<p>当然这里我们也可以通过在component里控制写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;Router&#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/router'</span>;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"go()\"</span>&gt;</span>Heroes<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">constructor</span>(private router: Router) &#123;&#125;</div><div class=\"line\">go() &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.router.navigate([<span class=\"string\">'heroes'</span>]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这种效果也是一样的；这里就需要注入router服务：<br> router方法用于切换路由很有用，下面会具体来介绍router服务的；<br> 路由出口:RouterOutlet是由RouterModule提供的指令之一。当我们在应用中导航时，路由器就把激活的组件显示在<router-outlet>里面。不写</router-outlet></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-outlet</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-outlet</span>&gt;</span></div></pre></td></tr></table></figure>\n<p> 会导致组件内容不加载进来，从而不显示内容；<br> 但是一个组件可以共用一个routeroutlet，所以app.component.ts里面配置了</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-outlet</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-outlet</span>&gt;</span></div></pre></td></tr></table></figure>\n<p> 就可以啦；</p>\n</li>\n</ul>\n<h2 id=\"第二种写法：\"><a href=\"#第二种写法：\" class=\"headerlink\" title=\"第二种写法：\"></a>第二种写法：</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">RouterModule.forRoot([...]) 将[] 及中间的内容当成配置文件提取出去；</div><div class=\"line\">RouterModule.forRoot(routes),</div><div class=\"line\">routes是我们需要导入的配置文件参数名：</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; routes&#125; from <span class=\"string\">'./app-routing.module'</span>;</div><div class=\"line\">app-routing.module:中我们可以这样写：</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; DashboardComponent &#125; from <span class=\"string\">'./dashboard/dashboard.component'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; HeroesComponent &#125; from <span class=\"string\">'./hero/heroes.component'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; HeroDetailComponent &#125; from <span class=\"string\">'./detail/hero-detail.component'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> routes = [</div><div class=\"line\">  &#123; path: <span class=\"string\">''</span>, redirectTo: <span class=\"string\">'/dashboard'</span>, pathMatch: <span class=\"string\">'full'</span> &#125;,</div><div class=\"line\">  &#123; path: <span class=\"string\">'dashboard'</span>,  component: DashboardComponent &#125;,</div><div class=\"line\">  &#123; path: <span class=\"string\">'detail/:id'</span>, component: HeroDetailComponent &#125;,</div><div class=\"line\">  &#123; path: <span class=\"string\">'heroes'</span>,     component: HeroesComponent &#125;,  &#123; path: <span class=\"string\">'**'</span>, component:DashboardComponent&#125;];</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li><strong>{ path: ‘’, redirectTo: ‘/dashboard’, pathMatch: ‘full’ }</strong><br> 表示重定向路由：需要一个pathMatch属性，告诉路由器是如何用URL去匹配路由的路径的，没有这个属性就会报错；意思就是当路由URL等于’’时，会去加载DashboardComponent组件；所以你运行你的服务端口号：localhost:4200首先加载的就会是这个组件；</li>\n<li><em>{ path: “**”, component:DashboardComponent}</em><br> **路径是一个通配符，表示除了以上几种path,任何的路径都会加载DashboardComponent组件，这个记得写在路由配置最后<br> 当然这种方式我们还能这么写:</li>\n</ul>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NgModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; Routes,RouterModule&#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/router'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; DashboardComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./dashboard/dashboard.component'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; HeroesComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./hero/heroes.component'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> routes = [</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">''</span>, <span class=\"attr\">redirectTo</span>: <span class=\"string\">'/dashboard'</span>, <span class=\"attr\">pathMatch</span>: <span class=\"string\">'full'</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">'dashboard'</span>,  <span class=\"attr\">component</span>: DashboardComponent &#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">'heroes'</span>,     <span class=\"attr\">component</span>: HeroesComponent &#125;</div><div class=\"line\">];</div><div class=\"line\">@NgModule(&#123;</div><div class=\"line\">  <span class=\"attr\">imports</span>: [ RouterModule.forChild(routes) ],</div><div class=\"line\">  <span class=\"attr\">exports</span>: [ RouterModule ]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppRoutingModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>  无declarations！声明是关联模块的重点。我们将AppRoutingModule抛出去，当做一个路由模块，<br>   app.module.ts中引入：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRoutingModule&#125; from <span class=\"string\">'./app-routing.module'</span>;</div></pre></td></tr></table></figure>\n<p>   imports:中导入这个就可以啦<strong>AppRoutingModule</strong><br>   这种用法和上面这种用法是一样的还有一点：如何解决第二次刷新出现404问题：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[RouterModule.forRoot(routes,&#123;useHash:<span class=\"literal\">true</span>&#125;)]</div></pre></td></tr></table></figure></p>\n<p>   配置后面这一点，通过添加一个#，防止刷新第二次出现404；<em><a href=\"http://localhost:4201/#\" target=\"_blank\" rel=\"external\">http://localhost:4201/#</a></em></p>\n","comments":true,"categories":[{"name":"Angular 2+","slug":"Angular-2","permalink":"www.sulishibaobei.com/categories/Angular-2/"}],"tags":[{"name":"-- Angular 2+ -- router -- 懒加载","slug":"Angular-2-router-懒加载","permalink":"www.sulishibaobei.com/tags/Angular-2-router-懒加载/"}]}]