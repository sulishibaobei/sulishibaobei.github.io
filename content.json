[{"title":"前端面试中常见的那些HTML/CSS题","date":"2017-09-26T02:08:53.000Z","path":"css/css-120170926/","text":"什么是盒子模型？一般面试都会问：盒子模型你是怎么理解的？盒子模型分为两种：W3C(标准的)盒子模型和IE(怪异)盒子模型有图可知，标准的盒子模型包含margin,border,padding,content，并别content部分不包含其他部分；例如一个盒子模型如下：margin:20px;border:10px;padding:10px;width:200px;height:100px;如果用w3c计算盒子模型占用为：宽度为：20x2+10x2+10x2+200=280px;高度为：20x2+10x2+10x2+100=180px;盒子的实际宽度为：10x2+10x2+200=240px; 因为实际的宽度margin是不计算在内；在IE6以上统一盒子的实际高度为：10x2+10x2+100=140px;所以：标准盒子模型下，元素的宽度等于content的宽度；盒子模型占据的位置计算方式是2margin+2border+2padding+width/height;盒子的实际大小：2xborder+2xpadding+width/height有图可知IE盒子模型包含padding，margin，border，content四部分，但是ie盒子模型的content已经计算border和padding在内。还是上面那一题，如果采用IE盒子模型方式计算，盒子需占据的位置宽度为：202+200=240px; 高度为：20*2+100=140px;盒子的实际大小为：宽 200px; 高100px；所以:IE盒子模型下，元素的宽度实际上包含了content+padding+border在内，所以计算的时候实际不需要再加上padding,border;w3c可能也认识到这种差异性，所以允许我们事先定义盒子模型的解析方式；box-sizing:content-box(default) | border-box | inheritcontent-box:让元素维持W3C的标准模型；border-box：让元素维持IE传统盒子模型;接下来通过代码来看一看差别：来一段基本的代码： 12&lt;div id=\"div1\"&gt;content-box&lt;/div&gt;&lt;div id=\"div2\"&gt;border-box&lt;/div&gt; 123456789101112*&#123; margin:0; padding:0;&#125;div&#123; width: 200px; height: 100px; background: red; margin: 20px; padding: 20px; border: 10px solid black;&#125; 这一段简单的代码，来看看效果：这时候，两个div显示的效果是一样的，默认都是采用content-box方式解析的；接下来改变代码看一看：123#div2&#123; box-sizing: border-box;&#125; 先来看看效果图：从肉眼直观来看，第二个盒子显然比第一个盒子小了许多，但是我们要用网页设计的观点来解释这个问题的话就可以看下面两张图：这是第一个div的图；这是第二个div的图；这就是为什么我们上面的题算出来的结果是那样的；IE下认为一个盒子的宽度应该是包含content,padding和border在内的；所以第二张图的时候，padding和border都侵蚀了元素的内容部分；最后总结一点： w3c中的盒子模型占用的大小：margin + border + padding + width/height;width: margin2 + border2 + padding2 + width;height: margin2 + border2 + padding2 + height;w3c中盒子模型的实际大小：border + padding + width/height;width: border2 + padding2 + width;height: border2 + padding2 + height;w3c中盒子模型的内容区域的大小：width/heightwidth: width;height: height; IE 盒子模型占用的宽度：margin + content-width/height;width: margin2 + width;height: margin2 + height;IE 盒子模型的实际大小：content-width/heightwidth: width;height: height; 另外还有一点：css3的伸缩盒模型指的是FlexBox,想了解的戳链接 为什么样式定义开头要定义* {margin:0;padding:0;}是用来清除所有元素的默认内外边距；举一个例子：1&lt;div id=\"div1\"&gt;&lt;/div&gt; 12345div&#123; width: 100px; height: 200px; background: red; &#125; 这时候我们可以看看效果：这时候，我们并没有给div设置margin和padding,但是确有一个边距存在，这就是浏览器给我们的默认边距；当我们设置这样一句：1234*&#123; margin: 0; padding: 0; &#125; 看到效果了吧，也就是设置这样一句的作用;例外平常还有两中比较常见的设置方法，可能有些人会这样设置：1234html&#123; margin:0; padding:0;&#125; 这种方式是没用的，并不能清除脏边距；还有一种123body&#123; margin:0;&#125; 这种方式是有效地，不同的浏览器，不同的兼容性，从代码通用性来说，设置*号是最好的方式；","content":"<h2 id=\"什么是盒子模型？\"><a href=\"#什么是盒子模型？\" class=\"headerlink\" title=\"什么是盒子模型？\"></a>什么是盒子模型？</h2><p>一般面试都会问：盒子模型你是怎么理解的？<br>盒子模型分为两种：W3C(标准的)盒子模型和IE(怪异)盒子模型<br><img src=\"/images/html-1.png\" alt=\"html\"><br><a id=\"more\"></a><br>有图可知，标准的盒子模型包含margin,border,padding,content，并别content部分不包含其他部分；<br>例如一个盒子模型如下：margin:20px;border:10px;padding:10px;width:200px;height:100px;<br>如果用w3c计算盒子模型占用为：宽度为：20x2+10x2+10x2+200=280px;高度为：20x2+10x2+10x2+100=180px;<br>盒子的实际宽度为：10x2+10x2+200=240px; 因为实际的宽度margin是不计算在内；在IE6以上统一<br>盒子的实际高度为：10x2+10x2+100=140px;<br>所以：标准盒子模型下，元素的宽度等于content的宽度；盒子模型占据的位置计算方式是2<em>margin+2</em>border+2<em>padding+width/height;<br>盒子的实际大小：2xborder+2xpadding+width/height<br><img src=\"/images/html-2.png\" alt=\"html\"><br>有图可知IE盒子模型包含padding，margin，border，content四部分，但是ie盒子模型的content已经计算border和padding在内。<br>还是上面那一题，如果采用IE盒子模型方式计算，盒子需占据的位置宽度为：20</em>2+200=240px; 高度为：20*2+100=140px;<br>盒子的实际大小为：宽 200px; 高100px；<br>所以:IE盒子模型下，元素的宽度实际上包含了content+padding+border在内，所以计算的时候实际不需要再加上padding,border;<br>w3c可能也认识到这种差异性，所以允许我们事先定义盒子模型的解析方式；<br>box-sizing:content-box(default) | border-box | inherit<br>content-box:让元素维持W3C的标准模型；<br>border-box：让元素维持IE传统盒子模型;<br>接下来通过代码来看一看差别：<br>来一段基本的代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"div1\"</span>&gt;</span>content-box<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"div2\"</span>&gt;</span>border-box<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">*&#123;</div><div class=\"line\">            <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">            <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">background</span>: red;</div><div class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">20px</span>;</div><div class=\"line\">            <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</div><div class=\"line\">            <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid black;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一段简单的代码，来看看效果：<br><img src=\"/images/html-3.png\" alt=\"html\"><br>这时候，两个div显示的效果是一样的，默认都是采用content-box方式解析的；<br>接下来改变代码看一看：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#div2</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>先来看看效果图：<br><img src=\"/images/html-4.png\" alt=\"html\"><br>从肉眼直观来看，第二个盒子显然比第一个盒子小了许多，但是我们要用网页设计的观点来解释这个问题的话就可以看下面两张图：<br><img src=\"/images/html-5.png\" alt=\"html\"><br>这是第一个div的图；<br><img src=\"/images/html-6.png\" alt=\"html\"><br>这是第二个div的图；<br>这就是为什么我们上面的题算出来的结果是那样的；IE下认为一个盒子的宽度应该是包含content,padding和border在内的；所以第二张图的时候，padding和border都侵蚀了元素的内容部分；<br>最后总结一点：</p>\n<blockquote>\n<ul>\n<li><p>w3c中的盒子模型占用的大小：margin + border + padding + width/height;<br>width: margin2 + border2 + padding2 + width;<br>height: margin2 + border2 + padding2 + height;<br>w3c中盒子模型的实际大小：border + padding + width/height;<br>width: border2 + padding2 + width;<br>height: border2 + padding2 + height;<br>w3c中盒子模型的内容区域的大小：width/height<br>width: width;<br>height: height;</p>\n</li>\n<li><p>IE 盒子模型占用的宽度：margin + content-width/height;<br>width: margin2 + width;<br>height: margin2 + height;<br>IE 盒子模型的实际大小：content-width/height<br>width: width;<br>height: height;</p>\n</li>\n</ul>\n</blockquote>\n<p>另外还有一点：css3的伸缩盒模型指的是<a href=\"http://www.sulishibaobei.com/css/fb-120170908/\">FlexBox</a>,想了解的戳链接</p>\n<h2 id=\"为什么样式定义开头要定义-margin-0-padding-0\"><a href=\"#为什么样式定义开头要定义-margin-0-padding-0\" class=\"headerlink\" title=\"为什么样式定义开头要定义* {margin:0;padding:0;}\"></a>为什么样式定义开头要定义* {margin:0;padding:0;}</h2><p>是用来清除所有元素的默认内外边距；<br>举一个例子：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"div1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">           <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">           <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">           <span class=\"attribute\">background</span>: red;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>这时候我们可以看看效果：<br><img src=\"/images/html-7.png\" alt=\"html\"><br>这时候，我们并没有给div设置margin和padding,但是确有一个边距存在，这就是浏览器给我们的默认边距；<br>当我们设置这样一句：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">*&#123;</div><div class=\"line\">           <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">           <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"images/html-8.png\" alt=\"html\"><br>看到效果了吧，也就是设置这样一句的作用;<br>例外平常还有两中比较常见的设置方法，可能有些人会这样设置：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这种方式是没用的，并不能清除脏边距；<br>还有一种<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这种方式是有效地，不同的浏览器，不同的兼容性，从代码通用性来说，设置*号是最好的方式；</p>\n","comments":true,"categories":[{"name":"前端面试题整理","slug":"前端面试题整理","permalink":"http://www.sulishibaobei.com/categories/前端面试题整理/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.sulishibaobei.com/tags/CSS/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.sulishibaobei.com/tags/HTML5/"},{"name":"面试题","slug":"面试题","permalink":"http://www.sulishibaobei.com/tags/面试题/"}]},{"title":"nginx第一课","date":"2017-09-25T03:08:53.000Z","path":"nginx/ng-120170925/","text":"有这样一个问题，我的nicefish项目里面要从我的服务器http://112.74.180.53 里面去拿去数据，然后遇见了跨域；然后就想到了用nginx做一个代理去拿数据；其实解决的办法由很多种，单单就跨域的这个问题的话，proxy.config.json也是可以解决，jsonp也可以解决，这里聊一聊我用nginx解决的过程； nginx 下载戳这里我下载的是1.12.1 ,哪个版本都可以打开可以看到几个文件夹和一个可执行文件 ，向下面的一样；html 文件里面主要放html代码或者项目的；conf 主要是放置我们的配置文件；我们切换到当前文件内运行nginx.exe或者nginx start默认的端口号是80，浏览器打开localhost 就可以看到一个页面，这时候运行的是html文件里面的index.html；如果想修改端口号，则是conf文件夹里的nginx.conf 下面会仔细来介绍这个配置文件的； 打开nginx.conf文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#user nobody;worker_processes 1; #允许生成的进程数2 ,默认数1#error_log logs/error.log; #指定日志路径，级别，这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid; #指定ngInx进程运行文件存放地址events &#123; #events块 worker_connections 1024; #最大连接数 默认为512 #accept_mutex on; #设置网络连接序列化，防止惊群现象发生， # multi_accept on; # 设置一个进程是否同时接受多个网络连接，默认为off; # use epoll; #事件驱动模型， select|poll|kqueue|epoll|resig|/dev/poll|eventport;&#125;http &#123; # http 块 可以嵌套多个server ,配置代理 include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #proxy_method get; #access_log off; # 取消服务日志 #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; # 自定义格式 #access_log logs/access.log main; #combined为日志格式默认值 sendfile on; #允许sendfile方式传输文件，默认值为off，可以在http块，server块，location块； #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #链接超时时间，默认值为75s，可以在http块，server块,location块； #sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 #gzip on; #upstream mysvr&#123; #server 127.0.0.1:80; #server 112.74.180.53:80; #&#125; server &#123; # server块 配置虚拟主机的相关参数，一个http中可以有多个server listen 80; #监听端口 server_name tomcat; #监听地址 root html; index index.html; location /file &#123; #配置请求的路由 以及各个页面的处理情况 proxy_pass http://112.74.180.53:80; &#125; location /toutiao &#123; proxy_pass http://v.juhe.cn; &#125; location ~* \\.(js|css|png|gif|jpg|mp3|ogg|ttf|woff|woff2|html|json|map)$ &#123; expires 30d; &#125; default_type 'text/html'; charset utf-8; # keepalive_timeout 120; #单链接请求上限次数 # location ~*^.+$ &#123; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 #root path; #根目录 #index vv.txt #设置默认页 #proxy_pass http://mysvr #请求转向mysvr定义的服务器列表 #deny 127.0.0.1; #拒绝的ip #allow 172.18.5.54 #允许的ip # &#125; #charset koi8-r; #access_log logs/host.access.log main; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html #proxy_intercept_errors on; #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。 error_page 500 502 503 504 /50x.html; #错误页 location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; #都是被注释的代码；root html;index index.html;这就是为什么运行localhost会打开html里面index.html文件的原因，都是在配置文件里配置好的；也就是如果我d盘有个项目，root换成d盘路径，打开的就是我的项目了；1234upstream mysvr&#123; #server 127.0.0.1:8081; server 112.74.180.53:80; &#125; 看到有这样一段代码，被我注释掉了；其实是和这个一起使用的123location /file &#123; #配置请求的路由 以及各个页面的处理情况 proxy_pass http://112.74.180.53:80; &#125; 如果上面的upstream mysvr不被注释，那么这段应该这么写： 123location /file &#123; #配置请求的路由 以及各个页面的处理情况 proxy_pass http://mysvr; &#125; 能用到的每一行都在后面写了注释，跟着使用就可以啦；举个例子：我要去这个下面获取数据http://112.74.180.53/file/comment-mock.json注意看看我的location那里怎么配置的；proxy_pass http://112.74.180.53:80; 将地址写在这里；location /file 表示只要遇见/file开头的请求就调用这个代理；这就是为什么配置了多个的原因： 1234567location /file &#123; #配置请求的路由 以及各个页面的处理情况 proxy_pass http://112.74.180.53:80; &#125;location /toutiao &#123; proxy_pass http://v.juhe.cn; &#125; 不同的文件，调用不同的；但是怎么知道是不是file开头呢？就是和我们的html里面的代码有关；我们的url中这样写就可以啦：private url=’/file/comment-mock.json’;碰到是这个请求的就会走入第一个配置啦；这边也推荐几个觉得写得不错的文章，如果还有疑问，可以去这些文章中看一看；用nginx的反向代理机制解决前端跨域问题nginx常用代理配置玩玩nginx或者私信给我，我们一起来聊一聊；","content":"<p>有这样一个问题，我的nicefish项目里面要从我的服务器<a href=\"http://112.74.180.53\" target=\"_blank\" rel=\"external\">http://112.74.180.53</a> 里面去拿去数据，然后遇见了跨域；然后就想到了用nginx做一个代理去拿数据；<br>其实解决的办法由很多种，单单就跨域的这个问题的话，proxy.config.json也是可以解决，jsonp也可以解决，这里聊一聊我用nginx解决的过程；<br><a id=\"more\"></a></p>\n<h2 id=\"nginx-下载\"><a href=\"#nginx-下载\" class=\"headerlink\" title=\"nginx 下载\"></a>nginx 下载</h2><p><a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"external\">戳这里</a><br>我下载的是1.12.1 ,哪个版本都可以<br>打开可以看到几个文件夹和一个可执行文件 ，向下面的一样；<br><img src=\"/images/nginx-1.png\" alt=\"nginx\"><br>html 文件里面主要放html代码或者项目的；<br>conf 主要是放置我们的配置文件；<br>我们切换到当前文件内运行nginx.exe或者nginx start默认的端口号是80，浏览器打开localhost 就可以看到一个页面，这时候运行的是html文件里面的index.html；如果想修改端口号，则是conf文件夹里的nginx.conf 下面会仔细来介绍这个配置文件的；</p>\n<p>打开nginx.conf文件：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div></pre></td><td class=\"code\"><pre><div class=\"line\">#user  nobody;</div><div class=\"line\">worker_processes  1;  #允许生成的进程数2 ,默认数1</div><div class=\"line\"></div><div class=\"line\">#error_log  logs/error.log;  #指定日志路径，级别，这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</div><div class=\"line\">#error_log  logs/error.log  notice;</div><div class=\"line\">#error_log  logs/error.log  info;</div><div class=\"line\"></div><div class=\"line\">#pid        logs/nginx.pid;   #指定ngInx进程运行文件存放地址</div><div class=\"line\">events &#123;                       #events块</div><div class=\"line\">    worker_connections  1024;   #最大连接数  默认为512</div><div class=\"line\">    #accept_mutex on;  #设置网络连接序列化，防止惊群现象发生，</div><div class=\"line\">    # multi_accept on; # 设置一个进程是否同时接受多个网络连接，默认为off;</div><div class=\"line\">    # use epoll;  #事件驱动模型， select|poll|kqueue|epoll|resig|/dev/poll|eventport;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">http &#123;      # http 块  可以嵌套多个server ,配置代理</div><div class=\"line\">    include       mime.types;  #文件扩展名与文件类型映射表</div><div class=\"line\">    default_type  application/octet-stream;  #默认文件类型，默认为text/plain</div><div class=\"line\">    #proxy_method get;</div><div class=\"line\">    #access_log off; # 取消服务日志</div><div class=\"line\">    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '</div><div class=\"line\">    #                  '$status $body_bytes_sent \"$http_referer\" '</div><div class=\"line\">    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';</div><div class=\"line\">    # 自定义格式</div><div class=\"line\">    #access_log  logs/access.log  main;  #combined为日志格式默认值</div><div class=\"line\"></div><div class=\"line\">    sendfile        on; #允许sendfile方式传输文件，默认值为off，可以在http块，server块，location块；</div><div class=\"line\">    #tcp_nopush     on;</div><div class=\"line\"></div><div class=\"line\">    #keepalive_timeout  0;</div><div class=\"line\">    keepalive_timeout  65; #链接超时时间，默认值为75s，可以在http块，server块,location块；</div><div class=\"line\">    #sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</div><div class=\"line\">    #gzip  on;</div><div class=\"line\">    #upstream mysvr&#123;</div><div class=\"line\">            #server 127.0.0.1:80;</div><div class=\"line\">            #server 112.74.180.53:80;</div><div class=\"line\">    #&#125;</div><div class=\"line\">    server &#123;      # server块  配置虚拟主机的相关参数，一个http中可以有多个server</div><div class=\"line\">        listen       80;  #监听端口</div><div class=\"line\">        server_name  tomcat;   #监听地址</div><div class=\"line\">        root  html;</div><div class=\"line\">        index  index.html;</div><div class=\"line\">        location /file &#123;    #配置请求的路由 以及各个页面的处理情况</div><div class=\"line\">            proxy_pass  http://112.74.180.53:80;</div><div class=\"line\">        &#125;</div><div class=\"line\">        location /toutiao &#123;</div><div class=\"line\">            proxy_pass http://v.juhe.cn;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        location ~* \\.(js|css|png|gif|jpg|mp3|ogg|ttf|woff|woff2|html|json|map)$ &#123;</div><div class=\"line\">              expires 30d;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">        default_type 'text/html';</div><div class=\"line\">        charset utf-8;</div><div class=\"line\">       </div><div class=\"line\">         # keepalive_timeout 120; #单链接请求上限次数</div><div class=\"line\">       # location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</div><div class=\"line\">               #root path; #根目录</div><div class=\"line\">               #index vv.txt #设置默认页</div><div class=\"line\">               #proxy_pass http://mysvr #请求转向mysvr定义的服务器列表</div><div class=\"line\">               #deny 127.0.0.1; #拒绝的ip</div><div class=\"line\">               #allow 172.18.5.54 #允许的ip</div><div class=\"line\">         # &#125;</div><div class=\"line\">       </div><div class=\"line\">        #charset koi8-r;</div><div class=\"line\">        #access_log  logs/host.access.log  main;</div><div class=\"line\">        #error_page  404              /404.html;</div><div class=\"line\"></div><div class=\"line\">        # redirect server error pages to the static page /50x.html</div><div class=\"line\">        #proxy_intercept_errors on;   #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。</div><div class=\"line\">        error_page   500 502 503 504  /50x.html; #错误页</div><div class=\"line\"></div><div class=\"line\">        location = /50x.html &#123;</div><div class=\"line\">            root   html;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</div><div class=\"line\">        #</div><div class=\"line\">        #location ~ \\.php$ &#123;</div><div class=\"line\">        #    proxy_pass   http://127.0.0.1;</div><div class=\"line\">        #&#125;</div><div class=\"line\"></div><div class=\"line\">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</div><div class=\"line\">        #</div><div class=\"line\">        #location ~ \\.php$ &#123;</div><div class=\"line\">        #    root           html;</div><div class=\"line\">        #    fastcgi_pass   127.0.0.1:9000;</div><div class=\"line\">        #    fastcgi_index  index.php;</div><div class=\"line\">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</div><div class=\"line\">        #    include        fastcgi_params;</div><div class=\"line\">        #&#125;</div><div class=\"line\"></div><div class=\"line\">        # deny access to .htaccess files, if Apache's document root</div><div class=\"line\">        # concurs with nginx's one</div><div class=\"line\">        #</div><div class=\"line\">        #location ~ /\\.ht &#123;</div><div class=\"line\">        #    deny  all;</div><div class=\"line\">        #&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    # another virtual host using mix of IP-, name-, and port-based configuration</div><div class=\"line\">    #</div><div class=\"line\">    #server &#123;</div><div class=\"line\">    #    listen       8000;</div><div class=\"line\">    #    listen       somename:8080;</div><div class=\"line\">    #    server_name  somename  alias  another.alias;</div><div class=\"line\"></div><div class=\"line\">    #    location / &#123;</div><div class=\"line\">    #        root   html;</div><div class=\"line\">    #        index  index.html index.htm;</div><div class=\"line\">    #    &#125;</div><div class=\"line\">    #&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    # HTTPS server</div><div class=\"line\">    #</div><div class=\"line\">    #server &#123;</div><div class=\"line\">    #    listen       443 ssl;</div><div class=\"line\">    #    server_name  localhost;</div><div class=\"line\"></div><div class=\"line\">    #    ssl_certificate      cert.pem;</div><div class=\"line\">    #    ssl_certificate_key  cert.key;</div><div class=\"line\"></div><div class=\"line\">    #    ssl_session_cache    shared:SSL:1m;</div><div class=\"line\">    #    ssl_session_timeout  5m;</div><div class=\"line\"></div><div class=\"line\">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</div><div class=\"line\">    #    ssl_prefer_server_ciphers  on;</div><div class=\"line\"></div><div class=\"line\">    #    location / &#123;</div><div class=\"line\">    #        root   html;</div><div class=\"line\">    #        index  index.html index.htm;</div><div class=\"line\">    #    &#125;</div><div class=\"line\">    #&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>#</code>都是被注释的代码；<br>root  html;<br>index  index.html;<br>这就是为什么运行localhost会打开html里面index.html文件的原因，都是在配置文件里配置好的；<br>也就是如果我d盘有个项目，root换成d盘路径，打开的就是我的项目了；<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">upstream mysvr&#123;</div><div class=\"line\">        #server 127.0.0.1:8081;</div><div class=\"line\">        server 112.74.180.53:80;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>看到有这样一段代码，被我注释掉了；<br>其实是和这个一起使用的<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">location /file &#123;    #配置请求的路由 以及各个页面的处理情况</div><div class=\"line\">           proxy_pass  http://112.74.180.53:80;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<p>如果上面的upstream mysvr不被注释，那么这段应该这么写：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">location /file &#123;    #配置请求的路由 以及各个页面的处理情况</div><div class=\"line\">            proxy_pass  http://mysvr;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>能用到的每一行都在后面写了注释，跟着使用就可以啦；<br>举个例子：我要去这个下面获取数据<a href=\"http://112.74.180.53/file/comment-mock.json\" target=\"_blank\" rel=\"external\">http://112.74.180.53/file/comment-mock.json</a><br>注意看看我的location那里怎么配置的；<br>proxy_pass  <a href=\"http://112.74.180.53:80\" target=\"_blank\" rel=\"external\">http://112.74.180.53:80</a>; 将地址写在这里；<br>location /file 表示只要遇见/file开头的请求就调用这个代理；这就是为什么配置了多个的原因：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">location /file &#123;    #配置请求的路由 以及各个页面的处理情况</div><div class=\"line\">           proxy_pass  http://112.74.180.53:80;</div><div class=\"line\">       &#125;</div><div class=\"line\">location /toutiao &#123;</div><div class=\"line\">           proxy_pass http://v.juhe.cn;</div><div class=\"line\"></div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p>不同的文件，调用不同的；但是怎么知道是不是file开头呢？就是和我们的html里面的代码有关；<br>我们的url中这样写就可以啦：private url=’/file/comment-mock.json’;<br>碰到是这个请求的就会走入第一个配置啦；<br>这边也推荐几个觉得写得不错的文章，如果还有疑问，可以去这些文章中看一看；<br><a href=\"http://www.cnblogs.com/gabrielchen/p/5066120.html\" target=\"_blank\" rel=\"external\">用nginx的反向代理机制解决前端跨域问题</a><br><a href=\"http://www.cnblogs.com/fanzhidongyzby/p/5194895.html\" target=\"_blank\" rel=\"external\">nginx常用代理配置</a><br><a href=\"http://blog.csdn.net/zhangliangzi/article/details/52143358\" target=\"_blank\" rel=\"external\">玩玩nginx</a><br>或者私信给我，我们一起来聊一聊；</p>\n","comments":true,"categories":[{"name":"前端那些微小事","slug":"前端那些微小事","permalink":"http://www.sulishibaobei.com/categories/前端那些微小事/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.sulishibaobei.com/tags/nginx/"},{"name":"配置","slug":"配置","permalink":"http://www.sulishibaobei.com/tags/配置/"}]},{"title":"教你如何使用正则表达式","date":"2017-09-25T01:08:53.000Z","path":"js/zhengze20170925/","text":"认识一些元字符\\b 表示单词开头或者结尾，也就是单词的分界处；虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔符中的任何一个，它只匹配一个位置；例如：\\bhi\\b* 代表前边的内容可以连续重复使用任意次以使整个表达式得到匹配;.连在一起就意味着任意数量的不包含换行的字符；例如：\\bhi\\b.\\bLucy\\b 表示：一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。\\d 表示匹配是一个数字（0,或1，…);\\s 匹配任意的空白符，包括空格，制表符，换行符，中文全角空格等；\\w 匹配字母或数字或下划线或汉字等；+ 匹配重复1次或更多次。如果我们同时使用元字符，就可以构造出更强大的表达式，例如：0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d 匹配这样的字符串：以0开头，然后中间有两个数字，然后一个连接符“-” ,最后是8个数字；为了不写这么麻烦，我们也可以这样：0\\d{2}-\\d{8},这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)；\\ba\\w\\b 匹配以字符a开头的单词–先是某个单词开始出(\\b),然后是字母a，然后是任意数字的字母或者数字(\\w),最后是单词结束处(\\b);\\d+ 匹配一个或更多连续的数字。\\b\\w{6}\\b 匹配刚好6个字符的单词；^\\d{5,12}$ 匹配5到12个数字；如果想查找元字符本身如等，这时就要用到字符转义；用\\来取消这些字符特殊的意义；*，\\等；如果想要查找数字，字母或数字，空白就很简单了；[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)；[0-9]代表的含义就是和\\d一样的；表示匹配一位数字；[a-z0-9A-Z_]也就完全等同于\\w 修饰符修饰符用于执行区分大小写和全局匹配 RedExp对象方法其实个人觉得正则表达式如果不是到非必要的时候，只要会使用简单的就可以啦，复杂一点的会读就行；如果想了解更多复杂的功能，可以看这个人的；正则表达式30分钟入门教程","content":"<h2 id=\"认识一些元字符\"><a href=\"#认识一些元字符\" class=\"headerlink\" title=\"认识一些元字符\"></a>认识一些元字符</h2><p><code>\\b</code> 表示单词开头或者结尾，也就是单词的分界处；虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔符中的任何一个，它只匹配一个位置；例如：\\bhi\\b<br><code>*</code> 代表<em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配;.</em>连在一起就意味着任意数量的不包含换行的字符；例如：\\bhi\\b.<em>\\bLucy\\b 表示：一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。<br><code>\\d</code> 表示匹配是一个数字（0,或1，…);<br><code>\\s</code> 匹配任意的空白符，包括空格，制表符，换行符，中文全角空格等；<br><code>\\w</code> 匹配字母或数字或下划线或汉字等；<br><code>+</code> 匹配重复1次或更多次。<br><a id=\"more\"></a><br><img src=\"/images/zz-1.png\" alt=\"zz\"><br>如果我们同时使用元字符，就可以构造出更强大的表达式，例如：<br>0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d 匹配这样的字符串：以0开头，然后中间有两个数字，然后一个连接符“-” ,最后是8个数字；为了不写这么麻烦，我们也可以这样：0\\d{2}-\\d{8},这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)；<br>\\ba\\w</em>\\b 匹配以字符a开头的单词–先是某个单词开始出(\\b),然后是字母a，然后是任意数字的字母或者数字(\\w<em>),最后是单词结束处(\\b);<br>\\d+ 匹配一个或更多连续的数字。<br>\\b\\w{6}\\b 匹配刚好6个字符的单词；<br>^\\d{5,12}$ 匹配5到12个数字；<br>如果想查找元字符本身如</em>等，这时就要用到字符转义；用\\来取消这些字符特殊的意义；*，\\等；<br><img src=\"/images/zz-2.png\" alt=\"zz\"><br>如果想要查找数字，字母或数字，空白就很简单了；<br>[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)；<br>[0-9]代表的含义就是和\\d一样的；表示匹配一位数字；<br>[a-z0-9A-Z_]也就完全等同于\\w<br><img src=\"/images/zz-3.png\" alt=\"zz\"><br><img src=\"/images/zz-5.png\" alt=\"zz\"></p>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>修饰符用于执行区分大小写和全局匹配<br><img src=\"/images/zz-4.png\" alt=\"zz\"></p>\n<p>RedExp对象方法<br><img src=\"/images/zz-6.png\" alt=\"zz\"><br>其实个人觉得正则表达式如果不是到非必要的时候，只要会使用简单的就可以啦，复杂一点的会读就行；<br>如果想了解更多复杂的功能，可以看这个人的；<br><a href=\"http://www.jb51.net/tools/zhengze.html\" target=\"_blank\" rel=\"external\">正则表达式30分钟入门教程</a></p>\n","comments":true,"categories":[{"name":"前端那些微小事","slug":"前端那些微小事","permalink":"http://www.sulishibaobei.com/categories/前端那些微小事/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.sulishibaobei.com/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.sulishibaobei.com/tags/正则表达式/"},{"name":"Regex","slug":"Regex","permalink":"http://www.sulishibaobei.com/tags/Regex/"}]},{"title":"Angular 4 自定义组件封装遇见的一些事儿","date":"2017-09-08T03:05:53.000Z","path":"angular/style/component-120170908/","text":"你用Angular 吗？一.介绍说说封装Angular 组建过程中遇见的一些问题和感悟.用久了Angular,就会遇见很多坑，许多基于Angular开发的框架最喜欢做的事情就是封装组件,然后复用因为这是最省事的.二.基本构建组件思想 界面构建草图简要介绍上图：1.View 就是我们需要完成的界面,但是界面无非就是由若干个label,button,table,img,list等一些基本控件构成的,所有的前端页面构成都是一样,只是加上CSS排版确定最后的显示效果。2.五种基类，其实不止五种,只是列举。这里就需要我们将基类都封装成组件的形式,对外提供组件标签就可以使用.不管构建多少个页面,都可以用这几个基本组件完成.eg：一个button组件 button.component.html这个Button组件里面是还包裹一个label组件的. button.component.ts对外只用提供选择器，就可以使用Button了.3.可是为什么还要有中间的UIbuileder呢？是这样的，每次引选择器名是不是也很麻烦，看起来没有省力多少，封装的基本组件只需要对外抛出一个TYPEID，UIbuilder只要知道1是代表button组件，2代表label组件，UIbuilder将组件构建出来。 UIBuilder.html 构建组建图VIEW界面需要Button给我传一个1，需要label传一个2，需要什么传对于的id就行。此时的界面和组件是完全分离的，这样构件界面的时候几乎可以没有代码就出来一个页面啦。而且下次用的时候，基类是完全不用动的。三.样式控制。也许你会觉得这样构件出来的只有最简单的页面，那么样式呢？的确呀，这样就是很老土的界面，那么样式要怎么实现呢？其实Angular 提供了很多的方法的。1.一张样式表，定义所有的样式。相当于boostrap一样。 button样式定义都知道双花括号的定义,你只要在最外面将你需要的样式名传进来就可以啦.2.代码修改样式ElementRef ，Renderer2 有多少人知道这两个属性的。 代码修改样式这种都是可以在外部修改样式的,你的基组件不需要改动。 可能看起来费劲,但用起来好处很多，不用copy,copy了,而且你的思想也会到一个新的境界。其实，我用Angular有一段时间了,如果你也是,欢迎来交流。","content":"<p><img src=\"/images/fengjing-2.jpg\" alt=\"sf\"></p>\n<p><div class=\"image-caption\">你用Angular 吗？</div><br><a id=\"more\"></a><br>一.介绍<br>说说封装Angular 组建过程中遇见的一些问题和感悟.用久了Angular,就会遇见很多坑，许多基于Angular开发的框架最喜欢做的事情就是封装组件,然后复用因为这是最省事的.<br>二.基本构建组件思想<br><img src=\"/images/sf-2.png\" alt=\"sf\"></p>\n<p><div class=\"image-caption\">界面构建草图</div><br>简要介绍上图：<br>1.View 就是我们需要完成的界面,但是界面无非就是由若干个label,button,table,img,list等一些基本控件构成的,所有的前端页面构成都是一样,只是加上CSS排版确定最后的显示效果。<br>2.五种基类，其实不止五种,只是列举。这里就需要我们将基类都封装成组件的形式,对外提供组件标签就可以使用.不管构建多少个页面,都可以用这几个基本组件完成.<br>eg：一个button组件 </p>\n<p><img src=\"/images/sf-3.png\" alt=\"sf\"></p>\n<p><div class=\"image-caption\">button.component.html</div><br>这个Button组件里面是还包裹一个label组件的.</p>\n<p><img src=\"/images/sf-4.png\" alt=\"sf\"></p>\n<p><div class=\"image-caption\">button.component.ts</div><br>对外只用提供选择器，就可以使用Button了.<br>3.可是为什么还要有中间的UIbuileder呢？<br>是这样的，每次引选择器名是不是也很麻烦，看起来没有省力多少，<br>封装的基本组件只需要对外抛出一个TYPEID，UIbuilder只要知道1是代表button组件，2代表label组件，UIbuilder将组件构建出来。 </p>\n<p><img src=\"/images/sf-5.png\" alt=\"sf\"></p>\n<p><div class=\"image-caption\">UIBuilder.html 构建组建图</div><br>VIEW界面需要Button给我传一个1，需要label传一个2，需要什么传对于的id就行。此时的界面和组件是完全分离的，这样构件界面的时候几乎可以没有代码就出来一个页面啦。而且下次用的时候，基类是完全不用动的。<br>三.样式控制。<br>也许你会觉得这样构件出来的只有最简单的页面，那么样式呢？<br>的确呀，这样就是很老土的界面，那么样式要怎么实现呢？<br>其实Angular 提供了很多的方法的。<br>1.一张样式表，定义所有的样式。相当于boostrap一样。 </p>\n<p><img src=\"/images/sf-6.png\" alt=\"sf\"></p>\n<p><div class=\"image-caption\">button样式定义</div><br>都知道双花括号的定义,你只要在最外面将你需要的样式名传进来就可以啦.<br>2.代码修改样式<br>ElementRef ，Renderer2 有多少人知道这两个属性的。 </p>\n<p><img src=\"/images/sf-7.png\" alt=\"sf\"></p>\n<p><div class=\"image-caption\">代码修改样式</div><br>这种都是可以在外部修改样式的,你的基组件不需要改动。 可能看起来费劲,但用起来好处很多，不用copy,copy了,而且你的思想也会到一个新的境界。<br>其实，我用Angular有一段时间了,如果你也是,欢迎来交流。 </p>\n","comments":true,"categories":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/categories/Angular-2/"}],"tags":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/tags/Angular-2/"},{"name":"自定义","slug":"自定义","permalink":"http://www.sulishibaobei.com/tags/自定义/"},{"name":"component","slug":"component","permalink":"http://www.sulishibaobei.com/tags/component/"}]},{"title":"Flexible Box布局基础知识详解","date":"2017-09-08T02:08:53.000Z","path":"css/fb-120170908/","text":"1.基本概念，借用阮一峰老师的一张图：容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 2.容器的基本属性flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 2.1 flex-direction 属性决定主轴的方向 (及行排列) 默认值：row123.box&#123; flex-direction：row | row-reverse | column |column-reverse /*有四个值 分别的显示效果*/ &#125; html5实现代码： 123456&lt;div class=\"box\"&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;/div&gt; css3部分实现代码： 12345678910111213141516171819body&#123; margin: 0 auto; width: 1000px; &#125; .box&#123; background: gold; margin: 1px; display: flex; /*必须设置这个*/ flex-direction: row; /*一排的方式排列*/ &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 实现效果：如果css3改成 flex-direction: row-reverse;其他两个属性类推； 2.2 flex-wrap 定义如果一条轴线排不下，如何换行 默认：nowrap123.box&#123; flex-wrap：nowrap | wrap | wrap-reverse; &#125; html部分代码：1234567891011121314&lt;div class=\"box1\"&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;/div&gt; css 部分代码： 123456789101112131415.box1&#123; background: gold; margin: 1px; display: flex; flex-flow: wrap; &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 效果：这是换行的效果，其他效果可以尝试； 2.3 flex-flow 是flex-direction 和 flex-wrap的缩写；所以当独写上面的要写两个默认值为row norap 123.box&#123; flex-flow: flex-direction || flex-wrap &#125; 2.4 justify-content 属性定义了项目在主轴上的对齐方式123.box&#123; justify-content:flex-start | flex-end | center | space-between | space-around; &#125; flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。html5代码： 12345678910&lt;div class=\"box2\"&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;/div&gt; css3代码：123456789101112131415.box2&#123; background: gold; margin: 1px; display: flex; justify-content: center; /**可以换换其他的属性值*/ &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 效果图：其他的可以自己试试：flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2.5 align-items 定义项目在交叉轴上如何对齐（纵轴）123.box&#123; align-items:flex-start | flex-end |center | baseline |stretch &#125; html5代码： 1234567891011121314&lt;div class=\"box3\"&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item item-tall\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item item-tall\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item item-tall\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;/div&gt; css3代码： 1234567891011121314151617181920.box3&#123; background: gold; margin: 1px; display: flex; align-items:flex-end; /*可以换其他值看看*/ flex-wrap: wrap; &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; .item-tall&#123; height: 200px; /*交叉轴，高度不一*/ line-height: 200px; &#125; 效果：其他的可以自己试试：flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 2.6 align-content 属性定义了多根轴线(多行)的对齐方式，如果项目只有一根轴线，该属性起不来作用123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; &#125; html代码： 1234567891011121314&lt;div class=\"box3 box3-tall\"&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;div class=\"box-item\"&gt;1&lt;/div&gt; &lt;div class=\"box-item\"&gt;2&lt;/div&gt; &lt;div class=\"box-item\"&gt;3&lt;/div&gt; &lt;div class=\"box-item\"&gt;4&lt;/div&gt; &lt;/div&gt; css代码： 12345678910111213141516171819.box3&#123; background: gold; margin: 1px; display: flex; flex-wrap: wrap; align-content: space-around; &#125; .box-tall &#123; height: 300px; &#125; .box-item&#123; width: 100px; height: 100px; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; 效果：其他的可以自己试试：flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 3.容器里子元素的属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch通常我们定义flex:1;表示的就是这三个； 3.1 order 属性html代码：1234&lt;div class=\"box4\"&gt; &lt;div class=\"box-item1 \"&gt;1&lt;/div&gt; &lt;div class=\"box-item1 order\"&gt;2&lt;/div&gt; /*注意是第二个元素有Order类*/ &lt;/div&gt; css代码：123456789101112131415161718.box4&#123; background: gold; margin: 1px; display: flex; &#125; .box-item1&#123; flex: 1; line-height: 100px; background: #ccc; color: white; text-align: center; margin: 5px; &#125; .order&#123; background: blue; order: -1; &#125; 效果图：如果我这样设置： 12345.order&#123; background: blue; order: -1; flex-grow:2; /*多了这个*/ &#125; 其他的去试一试，大概就是这样","content":"<h2 id=\"1-基本概念，借用阮一峰老师的一张图：\"><a href=\"#1-基本概念，借用阮一峰老师的一张图：\" class=\"headerlink\" title=\"1.基本概念，借用阮一峰老师的一张图：\"></a>1.基本概念，借用阮一峰老师的一张图：</h2><p><img src=\"/images/fb-1.png\" alt=\"fb\"><br><a id=\"more\"></a><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<h2 id=\"2-容器的基本属性\"><a href=\"#2-容器的基本属性\" class=\"headerlink\" title=\"2.容器的基本属性\"></a>2.容器的基本属性</h2><p>flex-direction<br>flex-wrap<br>flex-flow<br>justify-content<br>align-items<br>align-content</p>\n<h3 id=\"2-1-flex-direction-属性决定主轴的方向-及行排列-默认值：row\"><a href=\"#2-1-flex-direction-属性决定主轴的方向-及行排列-默认值：row\" class=\"headerlink\" title=\"2.1 flex-direction  属性决定主轴的方向 (及行排列)  默认值：row\"></a>2.1 flex-direction  属性决定主轴的方向 (及行排列)  默认值：row</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.box&#123;</div><div class=\"line\">    flex-direction：row | row-reverse | column |column-reverse   /*有四个值  分别的显示效果*/</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/images/fb-2.png\" alt=\"fb\"><br>html5实现代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>css3部分实现代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span>&#123;</div><div class=\"line\">          <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</div><div class=\"line\">          <span class=\"attribute\">width</span>: <span class=\"number\">1000px</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">        <span class=\"selector-class\">.box</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">background</span>: gold;</div><div class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">1px</span>;</div><div class=\"line\">            <span class=\"attribute\">display</span>: flex;  <span class=\"comment\">/*必须设置这个*/</span></div><div class=\"line\">            <span class=\"attribute\">flex-direction</span>: row;  <span class=\"comment\">/*一排的方式排列*/</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"selector-class\">.box-item</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</div><div class=\"line\">            <span class=\"attribute\">color</span>: white;</div><div class=\"line\">            <span class=\"attribute\">text-align</span>: center;</div><div class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>实现效果：<br><img src=\"/images/fb-3.png\" alt=\"fb\"><br>如果css3改成   <code>flex-direction: row-reverse</code>;<br><img src=\"/images/fb-4.png\" alt=\"fb\"><br>其他两个属性类推；</p>\n<h3 id=\"2-2-flex-wrap-定义如果一条轴线排不下，如何换行-默认：nowrap\"><a href=\"#2-2-flex-wrap-定义如果一条轴线排不下，如何换行-默认：nowrap\" class=\"headerlink\" title=\"2.2 flex-wrap  定义如果一条轴线排不下，如何换行 默认：nowrap\"></a>2.2 flex-wrap  定义如果一条轴线排不下，如何换行 默认：nowrap</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.box&#123;</div><div class=\"line\">            flex-wrap：nowrap | wrap | wrap-reverse;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>html部分代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box1\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>css 部分代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box1</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">background</span>: gold;</div><div class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">1px</span>;</div><div class=\"line\">            <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">            <span class=\"attribute\">flex-flow</span>: wrap;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"selector-class\">.box-item</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</div><div class=\"line\">            <span class=\"attribute\">color</span>: white;</div><div class=\"line\">            <span class=\"attribute\">text-align</span>: center;</div><div class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>效果：<br><img src=\"/images/fb-5.png\" alt=\"fb\"><br>这是换行的效果，其他效果可以尝试；</p>\n<h3 id=\"2-3-flex-flow-是flex-direction-和-flex-wrap的缩写；所以当独写上面的要写两个\"><a href=\"#2-3-flex-flow-是flex-direction-和-flex-wrap的缩写；所以当独写上面的要写两个\" class=\"headerlink\" title=\"2.3 flex-flow 是flex-direction 和 flex-wrap的缩写；所以当独写上面的要写两个\"></a>2.3 flex-flow 是flex-direction 和 flex-wrap的缩写；所以当独写上面的要写两个</h3><p>默认值为row norap</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box</span>&#123;</div><div class=\"line\">     <span class=\"attribute\">flex-flow</span>: flex-direction || flex-wrap</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-4-justify-content-属性定义了项目在主轴上的对齐方式\"><a href=\"#2-4-justify-content-属性定义了项目在主轴上的对齐方式\" class=\"headerlink\" title=\"2.4 justify-content 属性定义了项目在主轴上的对齐方式\"></a>2.4 justify-content 属性定义了项目在主轴上的对齐方式</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box</span>&#123;</div><div class=\"line\">           <span class=\"attribute\">justify-content</span>:flex-start | flex-end | center | space-between | space-around;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔都相等。<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<br>html5代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box2\"</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>css3代码：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box2</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">background</span>: gold;</div><div class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">1px</span>;</div><div class=\"line\">            <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">            <span class=\"attribute\">justify-content</span>: center; <span class=\"comment\">/**可以换换其他的属性值*/</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"selector-class\">.box-item</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</div><div class=\"line\">            <span class=\"attribute\">color</span>: white;</div><div class=\"line\">            <span class=\"attribute\">text-align</span>: center;</div><div class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>效果图：<br><img src=\"/images/fb-6.png\" alt=\"fb\"><br>其他的可以自己试试：<br>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔都相等。<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p>\n<h3 id=\"2-5-align-items-定义项目在交叉轴上如何对齐（纵轴）\"><a href=\"#2-5-align-items-定义项目在交叉轴上如何对齐（纵轴）\" class=\"headerlink\" title=\"2.5 align-items 定义项目在交叉轴上如何对齐（纵轴）\"></a>2.5 align-items 定义项目在交叉轴上如何对齐（纵轴）</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box</span>&#123;</div><div class=\"line\">          <span class=\"attribute\">align-items</span>:flex-start | flex-end |center | baseline |stretch</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p>html5代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box3\"</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item item-tall\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item item-tall\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item item-tall\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>        </div><div class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>css3代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box3</span>&#123;</div><div class=\"line\">          <span class=\"attribute\">background</span>: gold;</div><div class=\"line\">          <span class=\"attribute\">margin</span>: <span class=\"number\">1px</span>;</div><div class=\"line\">          <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">          <span class=\"attribute\">align-items</span>:flex-end; <span class=\"comment\">/*可以换其他值看看*/</span></div><div class=\"line\">          <span class=\"attribute\">flex-wrap</span>: wrap;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"selector-class\">.box-item</span>&#123;</div><div class=\"line\">          <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">          <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">          <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">          <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</div><div class=\"line\">          <span class=\"attribute\">color</span>: white;</div><div class=\"line\">          <span class=\"attribute\">text-align</span>: center;</div><div class=\"line\">          <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"selector-class\">.item-tall</span>&#123;</div><div class=\"line\">          <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>; <span class=\"comment\">/*交叉轴，高度不一*/</span></div><div class=\"line\">          <span class=\"attribute\">line-height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p>效果：<br><img src=\"/images/fb-8.png\" alt=\"fb\"><br>其他的可以自己试试：<br>flex-start：交叉轴的起点对齐。<br>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>baseline: 项目的第一行文字的基线对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p>\n<h3 id=\"2-6-align-content-属性定义了多根轴线-多行-的对齐方式，如果项目只有一根轴线，该属性起不来作用\"><a href=\"#2-6-align-content-属性定义了多根轴线-多行-的对齐方式，如果项目只有一根轴线，该属性起不来作用\" class=\"headerlink\" title=\"2.6 align-content  属性定义了多根轴线(多行)的对齐方式，如果项目只有一根轴线，该属性起不来作用\"></a>2.6 align-content  属性定义了多根轴线(多行)的对齐方式，如果项目只有一根轴线，该属性起不来作用</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box</span> &#123;</div><div class=\"line\">         <span class=\"attribute\">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n<p>html代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box3 box3-tall\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>        </div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>css代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box3</span>&#123;</div><div class=\"line\">          <span class=\"attribute\">background</span>: gold;</div><div class=\"line\">          <span class=\"attribute\">margin</span>: <span class=\"number\">1px</span>;</div><div class=\"line\">          <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">          <span class=\"attribute\">flex-wrap</span>: wrap;</div><div class=\"line\">          <span class=\"attribute\">align-content</span>: space-around;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"selector-class\">.box-tall</span> &#123;</div><div class=\"line\">          <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">      <span class=\"selector-class\">.box-item</span>&#123;</div><div class=\"line\">          <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">          <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">          <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">          <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</div><div class=\"line\">          <span class=\"attribute\">color</span>: white;</div><div class=\"line\">          <span class=\"attribute\">text-align</span>: center;</div><div class=\"line\">          <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p>效果：<br><img src=\"/images/fb-8.png\" alt=\"fb\"><br>其他的可以自己试试：<br>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。</p>\n<h2 id=\"3-容器里子元素的属性\"><a href=\"#3-容器里子元素的属性\" class=\"headerlink\" title=\"3.容器里子元素的属性\"></a>3.容器里子元素的属性</h2><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch<br>通常我们定义flex:1;<br><img src=\"/images/fb-11.png\" alt=\"fb\"><br>表示的就是这三个；</p>\n<h3 id=\"3-1-order-属性\"><a href=\"#3-1-order-属性\" class=\"headerlink\" title=\"3.1 order 属性\"></a>3.1 order 属性</h3><p>html代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box4\"</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item1 \"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box-item1 order\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>        /*注意是第二个元素有Order类*/</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>css代码：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box4</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">background</span>: gold;</div><div class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">1px</span>;</div><div class=\"line\">            <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"selector-class\">.box-item1</span>&#123;</div><div class=\"line\">           <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">            <span class=\"attribute\">background</span>: <span class=\"number\">#ccc</span>;</div><div class=\"line\">            <span class=\"attribute\">color</span>: white;</div><div class=\"line\">            <span class=\"attribute\">text-align</span>: center;</div><div class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"selector-class\">.order</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">            <span class=\"attribute\">order</span>: -<span class=\"number\">1</span>;  </div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>效果图：<br><img src=\"/images/fb-9.png\" alt=\"fb\"><br>如果我这样设置：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.order</span>&#123;</div><div class=\"line\">            <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">            <span class=\"attribute\">order</span>: -<span class=\"number\">1</span>;</div><div class=\"line\">           <span class=\"attribute\">flex-grow</span>:<span class=\"number\">2</span>; <span class=\"comment\">/*多了这个*/</span></div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/images/fb-10.png\" alt=\"fb\"><br>其他的去试一试，大概就是这样</p>\n","comments":true,"categories":[{"name":"CSS","slug":"CSS","permalink":"http://www.sulishibaobei.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.sulishibaobei.com/tags/CSS/"},{"name":"弹性布局","slug":"弹性布局","permalink":"http://www.sulishibaobei.com/tags/弹性布局/"},{"name":"Flexible","slug":"Flexible","permalink":"http://www.sulishibaobei.com/tags/Flexible/"}]},{"title":"Angular 4+ HttpClient","date":"2017-09-08T01:08:53.000Z","path":"angular/http/http-220170908/","text":"Angular 4.3.0-rc.0 版本已经发布🐦。在这个版本中，我们等到了一个令人兴奋的新功能 - HTTPClient API 的改进版本；HttpClient 是已有 Angular HTTP API 的演进，它在一个单独的 @angular/common/http 包中。这是为了确保现有的代码库可以缓慢迁移到新的 API；大多数前端应用都需要通过 HTTP 协议与后端服务器通讯。现代浏览器支持使用两种不同的 API 发起 HTTP 请求：XMLHttpRequest 接口和 fetch() API；@angular/common/http中的HttpClient类，Angular 为应用程序提供了一个简化的 API 来实现 HTTP 功能。它基于浏览器提供的XMLHttpRequest接口。 HttpClient带来的其它优点包括：可测试性、强类型的请求和响应对象、发起请求与接收响应时的拦截器支持，以及更好的、基于可观察（Observable）对象的错误处理机制；1.如何使用httpClient; 123456789101112import &#123;NgModule&#125; from '@angular/core';import &#123;BrowserModule&#125; from '@angular/platform-browser';import &#123;HttpClientModule&#125; from '@angular/common/http';@NgModule(&#123; imports: [ BrowserModule, // Include it under 'imports' in your application module // after BrowserModule. HttpClientModule, ],&#125;)export class MyAppModule &#123;&#125; 注意：导入方式和HttpModule一样的，记得要在BrowserModule后面导入；区别是：在@angular/common/http 模块里面，而不是@angular/http中这样我们可以使用这些啦： 1234567891011class HttpClient &#123; request(first: string|HttpRequest&lt;any&gt;, url?: string, options: &#123;...&#125;): Observable&lt;any&gt; delete(url: string, options: &#123;...&#125;): Observable&lt;any&gt; get(url: string, options: &#123;...&#125;): Observable&lt;any&gt; head(url: string, options: &#123;...&#125;): Observable&lt;any&gt; jsonp&lt;T&gt;(url: string, callbackParam: string): Observable&lt;T&gt; options(url: string, options: &#123;...&#125;): Observable&lt;any&gt; patch(url: string, body: any|null, options: &#123;...&#125;): Observable&lt;any&gt; post(url: string, body: any|null, options: &#123;...&#125;): Observable&lt;any&gt; put(url: string, body: any|null, options: &#123;...&#125;): Observable&lt;any&gt;&#125; 2.发起一个请求来获取Json数据；首先创建一个json文件，其实就是上一篇的同一个json文件：{ “data”: [ { “id”: 1, “name”: “Windstorm” }, { “id”: 2, “name”: “Bombasto” }, { “id”: 3, “name”: “Magneta” }, { “id”: 4, “name”: “Tornado” } ]} 怎么调用Http请求呢？2.1 app.componment.ts; 1234567891011121314151617import &#123; Component,OnInit &#125; from '@angular/core';import &#123;HttpClient&#125; from '@angular/common/http'; /*注释1*/@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent implements OnInit &#123;constructor(private http:HttpClient)&#123;&#125; datas:string[]; ngOnInit()&#123; this.http.get('./assets/heroes.json').subscribe(data=&gt;&#123; /*注释2*/ this.datas=data['data']; console.log(this.datas) &#125;) &#125;&#125; 注意：注释1：组件中引入的是HttpClient,也是在单独的库，@angular/common/http中;之前的项目里面引入的一直都是http，这就是改版后的区别；注释2：现在 JSON 是默认的数据格式，我们不需要再进行显式的解析；this.http.get(‘xx’).subscribe();之前的还需要res.json()去手动转；还有一点要注意：我并没有去hero.service.ts里面去操作了，而是直接在组件中发请求获取数据，这样更加简单明了；12345&lt;div&gt; &lt;ul *ngFor=\"let data of datas\"&gt; &lt;li&gt;&#123;&#123;data.id&#125;&#125; &#123;&#123;data.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; html代码还是一样简单，并没有改变；这是相比较之前的Http简单的方式； 12345678get(url: string, options: &#123; headers?: HttpHeaders, observe?: HttpObserve, params?: HttpParams, reportProgress?: boolean, responseType?: 'arraybuffer'|'blob'|'json'|'text', withCredentials?: boolean,&#125;): Observable&lt;any&gt; 这是get方法详解，请注意，返回的都是observable对象，而不是使用promise了；3.响应体的检查3.1上面的代码中： 12 datas:string[]; //定义一个接口来描述这个类型的正确形态this.datas=data['data']; /*注释1*/ 注释1：我们取json对象data值时要data[‘data’]，而不是之前的data.data了；如果改成： this.datas=data.data;会报错：does not exist on type &#39;Object那是因为HttpClient把 JSON 格式的响应体解析成了一个Object，它并不知道这个对象的形态应该是什么。所以我们应该告诉你需要取得data是个什么类型；这也是更符合typescript语法的做法；4.如果将要获取的不是JSON文件如何？123 this.http.get('/assets/1.txt',&#123;responseType:'text'&#125;).subscribe( data=&gt;console.log(data)) 注意：这样我们就要指定需要获取的文本格式；控制台将会打印我的1.txt中的内容：www.sulishibaobei.com 5.如何带参查询数据 1234567const params = new HttpParams() .set('id', '1').set('name','Windstorm') this.cus=this.http.get('assets/heroes.json',&#123;params&#125;) .do(console.log) .map(data=&gt; console.log( _.values(data)) ); 引入：httpParams参数：import {HttpClient, HttpParams} from &#39;@angular/common/http&#39;;我们通过链式语法调用set()方法，构建了params对象；每当set()方法被调用时，都会包含新的值进来，并且防止之前对象不被修改；http://localhost:4200/assets/heroes.json?id=1&amp;name=Windstorm请求的链接地址将会是这样的形式；这个有点像http里添加url参数；还可以设置Headers；const headers = new HttpHeaders().set(&quot;X-CustomHeader&quot;, &quot;custom header value&quot;);还有其他的请求，之后会逐一分析；另外还有几点比较重要的：多行并发发送请求和顺序发送请求，避免发送重复请求； 12345import 'rxjs/add/operator/shareReplay';const httpGet = this.http .get(\"assets/heroes.json\") .map(data =&gt; _.values(data)) .shareReplay(); 这样即使你将 httpGet再赋值给另一个变量，或重复调用也不会再次请求了并行发送 HTTP 请求的一种方法是使用 RxJs 中的 forkjoin 操作符： 12345678910111213import 'rxjs/add/observable/forkJoin';Requests() &#123; const result = Observable.forkJoin( this.http.get('/assets/heroes.json'), this.http.get('/assets/heroes.json') ); result.subscribe( values =&gt; &#123; console.log(\"all values\", values) &#125; );&#125; 顺序发送请求 123456789sequentialRequests() &#123; const sequence$ = this.http.get&lt;Hero&gt;('/assets/heroes.json') .switchMap(hero =&gt; &#123; hero.id+= ' - TEST '; return this.http.put('/assets/heroes.json', hero) &#125;); sequence$.subscribe();&#125; 6.拦截器 （拦截所有的请求和响应这也是@angular/common/http的核心特性之一）它能声明一些拦截器，拦在应用和后端之间。当应用程序发起一个请求时，拦截器可以在请求被发往服务器之前先转换这个请求。并且在应用看到服务器发回来的响应之前，转换这个响应。这对于处理包括认证和记录日志在内的一系列工作都非常有用。6.1 如何写一个拦截器 1234567891011121314151617import &#123;Injectable&#125; from '@angular/core';import &#123;HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse&#125; from '@angular/common/http';import &#123;Observable&#125; from 'Rxjs/Observable';@Injectable()export class NoopInterceptor implements HttpInterceptor &#123; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; return next.handle(req).map(event =&gt; &#123; if (event instanceof HttpResponse) &#123; if (event.status === 401) &#123; // JWT expired, go to login &#125; &#125; return event; &#125; &#125; &#125; 1.intercept是一个方法，它把一个请求对象转换成一个返回这个响应的可观察对象（Observable）。从这个意义上说，每个拦截器都要完全自己处理这个请求；2.响应拦截器可以通过在 next.handle(req) 返回的流对象 (即 Observable 对象) 上应用附加的 Rx 操作符来转换响应事件流对象；内部可以做自己的处理操作；但是此时拦截器还未使用在组件上； 12345678910import &#123;NgModule&#125; from '@angular/core';import &#123;HTTP_INTERCEPTORS&#125; from '@angular/common/http';@NgModule(&#123; providers: [&#123; provide: HTTP_INTERCEPTORS, useClass: NoopInterceptor, multi: true, &#125;],&#125;)export class AppModule &#123;&#125; providers里面配置我们的信息；注意multi: true选项。这是必须的，因为它会告诉 Angular 这个 HTTP_INTERCEPTORS 表示的是一个数组，而不是单个的值；","content":"<p>Angular 4.3.0-rc.0 版本已经发布🐦。在这个版本中，我们等到了一个令人兴奋的新功能 - HTTPClient API 的改进版本；<br>HttpClient 是已有 Angular HTTP API 的演进，它在一个单独的 @angular/common/http 包中。这是为了确保现有的代码库可以缓慢迁移到新的 API；<br>大多数前端应用都需要通过 HTTP 协议与后端服务器通讯。现代浏览器支持使用两种不同的 API 发起 HTTP 请求：XMLHttpRequest 接口和 fetch() API；<br><a id=\"more\"></a><br>@angular/common/http中的HttpClient类，Angular 为应用程序提供了一个简化的 API 来实现 HTTP 功能。它基于浏览器提供的XMLHttpRequest接口。 HttpClient带来的其它优点包括：可测试性、强类型的请求和响应对象、发起请求与接收响应时的拦截器支持，以及更好的、基于可观察（Observable）对象的错误处理机制；<br>1.如何使用httpClient;</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;NgModule&#125; from <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;BrowserModule&#125; from <span class=\"string\">'@angular/platform-browser'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;HttpClientModule&#125; from <span class=\"string\">'@angular/common/http'</span>;</div><div class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</div><div class=\"line\">  imports: [</div><div class=\"line\">    BrowserModule,</div><div class=\"line\">    <span class=\"comment\">// Include it under 'imports' in your application module</span></div><div class=\"line\">    <span class=\"comment\">// after BrowserModule.</span></div><div class=\"line\">    HttpClientModule,</div><div class=\"line\">  ],</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> MyAppModule &#123;&#125;</div></pre></td></tr></table></figure>\n<p>注意：导入方式和HttpModule一样的，记得要在BrowserModule后面导入；区别是：在@angular/common/http 模块里面，而不是@angular/http中<br>这样我们可以使用这些啦：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> HttpClient &#123;</div><div class=\"line\">  request(first: <span class=\"built_in\">string</span>|HttpRequest&lt;<span class=\"built_in\">any</span>&gt;, url?: <span class=\"built_in\">string</span>, options: &#123;...&#125;): Observable&lt;<span class=\"built_in\">any</span>&gt;</div><div class=\"line\">  <span class=\"keyword\">delete</span>(url: <span class=\"built_in\">string</span>, options: &#123;...&#125;): Observable&lt;<span class=\"built_in\">any</span>&gt;</div><div class=\"line\">  <span class=\"keyword\">get</span>(url: <span class=\"built_in\">string</span>, options: &#123;...&#125;): Observable&lt;<span class=\"built_in\">any</span>&gt;</div><div class=\"line\">  head(url: <span class=\"built_in\">string</span>, options: &#123;...&#125;): Observable&lt;<span class=\"built_in\">any</span>&gt;</div><div class=\"line\">  jsonp&lt;T&gt;(url: <span class=\"built_in\">string</span>, callbackParam: <span class=\"built_in\">string</span>): Observable&lt;T&gt;</div><div class=\"line\">  options(url: <span class=\"built_in\">string</span>, options: &#123;...&#125;): Observable&lt;<span class=\"built_in\">any</span>&gt;</div><div class=\"line\">  patch(url: <span class=\"built_in\">string</span>, body: <span class=\"built_in\">any</span>|<span class=\"literal\">null</span>, options: &#123;...&#125;): Observable&lt;<span class=\"built_in\">any</span>&gt;</div><div class=\"line\">  post(url: <span class=\"built_in\">string</span>, body: <span class=\"built_in\">any</span>|<span class=\"literal\">null</span>, options: &#123;...&#125;): Observable&lt;<span class=\"built_in\">any</span>&gt;</div><div class=\"line\">  put(url: <span class=\"built_in\">string</span>, body: <span class=\"built_in\">any</span>|<span class=\"literal\">null</span>, options: &#123;...&#125;): Observable&lt;<span class=\"built_in\">any</span>&gt;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.发起一个请求来获取Json数据；<br>首先创建一个json文件，其实就是上一篇的同一个json文件：<br>{<br>  “data”: [<br>    { “id”: 1, “name”: “Windstorm” },<br>    { “id”: 2, “name”: “Bombasto” },<br>    { “id”: 3, “name”: “Magneta” },<br>    { “id”: 4, “name”: “Tornado” }<br>  ]<br>}</p>\n<p>怎么调用Http请求呢？<br>2.1 app.componment.ts;</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; Component,OnInit &#125; from <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;HttpClient&#125; from <span class=\"string\">'@angular/common/http'</span>;  <span class=\"comment\">/*注释1*/</span></div><div class=\"line\"><span class=\"meta\">@Component</span>(&#123;</div><div class=\"line\">  selector: <span class=\"string\">'app-root'</span>,</div><div class=\"line\">  templateUrl: <span class=\"string\">'./app.component.html'</span>,</div><div class=\"line\">  styleUrls: [<span class=\"string\">'./app.component.css'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> AppComponent  <span class=\"keyword\">implements</span> OnInit &#123;</div><div class=\"line\"><span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> http:HttpClient</span>)&#123;&#125; </div><div class=\"line\"> datas:<span class=\"built_in\">string</span>[];</div><div class=\"line\">  ngOnInit()&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.http.get(<span class=\"string\">'./assets/heroes.json'</span>).subscribe(data=&gt;&#123;  <span class=\"comment\">/*注释2*/</span></div><div class=\"line\">         <span class=\"keyword\">this</span>.datas=data[<span class=\"string\">'data'</span>];</div><div class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.datas)</div><div class=\"line\">    &#125;) </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意：<br>注释1：组件中引入的是HttpClient,也是在单独的库，@angular/common/http中;之前的项目里面引入的一直都是http，这就是改版后的区别；<br>注释2：现在 JSON 是默认的数据格式，我们不需要再进行显式的解析；this.http.get(‘xx’).subscribe();之前的还需要res.json()去手动转；<br>还有一点要注意：我并没有去hero.service.ts里面去操作了，而是直接在组件中发请求获取数据，这样更加简单明了；<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>  *<span class=\"attr\">ngFor</span>=<span class=\"string\">\"let data of datas\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;&#123;data.id&#125;&#125;  &#123;&#123;data.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>html代码还是一样简单，并没有改变；<br>这是相比较之前的Http简单的方式；</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">get</span>(url: <span class=\"built_in\">string</span>, options: &#123;</div><div class=\"line\">  headers?: HttpHeaders,</div><div class=\"line\">  observe?: HttpObserve,</div><div class=\"line\">  params?: HttpParams,</div><div class=\"line\">  reportProgress?: <span class=\"built_in\">boolean</span>,</div><div class=\"line\">  responseType?: <span class=\"string\">'arraybuffer'</span>|<span class=\"string\">'blob'</span>|<span class=\"string\">'json'</span>|<span class=\"string\">'text'</span>,</div><div class=\"line\">  withCredentials?: <span class=\"built_in\">boolean</span>,</div><div class=\"line\">&#125;): Observable&lt;<span class=\"built_in\">any</span>&gt;</div></pre></td></tr></table></figure>\n<p>这是get方法详解，请注意，返回的都是observable对象，而不是使用promise了；<br>3.响应体的检查<br>3.1上面的代码中：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"> datas:<span class=\"built_in\">string</span>[];   <span class=\"comment\">//定义一个接口来描述这个类型的正确形态</span></div><div class=\"line\"><span class=\"keyword\">this</span>.datas=data[<span class=\"string\">'data'</span>]; <span class=\"comment\">/*注释1*/</span></div></pre></td></tr></table></figure>\n<p>注释1：我们取json对象data值时要data[‘data’]，而不是之前的data.data了；如果改成：<br> <code>this.datas=data.data;</code><br>会报错：<code>does not exist on type &#39;Object</code><br>那是因为HttpClient把 JSON 格式的响应体解析成了一个Object，它并不知道这个对象的形态应该是什么。所以我们应该告诉你需要取得data是个什么类型；这也是更符合typescript语法的做法；<br>4.如果将要获取的不是JSON文件如何？<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">this</span>.http.get(<span class=\"string\">'/assets/1.txt'</span>,&#123;responseType:<span class=\"string\">'text'</span>&#125;).subscribe(</div><div class=\"line\">      data=&gt;<span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>注意：这样我们就要指定需要获取的文本格式；<br>控制台将会打印我的1.txt中的内容：www.sulishibaobei.com<br> 5.如何带参查询数据</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> params = <span class=\"keyword\">new</span> HttpParams()</div><div class=\"line\">  .set(<span class=\"string\">'id'</span>, <span class=\"string\">'1'</span>).set(<span class=\"string\">'name'</span>,<span class=\"string\">'Windstorm'</span>)</div><div class=\"line\">  <span class=\"keyword\">this</span>.cus=<span class=\"keyword\">this</span>.http.get(<span class=\"string\">'assets/heroes.json'</span>,&#123;params&#125;)</div><div class=\"line\">  .do(<span class=\"built_in\">console</span>.log)</div><div class=\"line\">  .map(data=&gt;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log( _.values(data))</div><div class=\"line\">  );</div></pre></td></tr></table></figure>\n<p>引入：httpParams参数：<br><code>import {HttpClient, HttpParams} from &#39;@angular/common/http&#39;;</code><br>我们通过链式语法调用set()方法，构建了params对象；每当set()方法被调用时，都会包含新的值进来，并且防止之前对象不被修改；<br><a href=\"http://localhost:4200/assets/heroes.json?id=1&amp;name=Windstorm\" target=\"_blank\" rel=\"external\">http://localhost:4200/assets/heroes.json?id=1&amp;name=Windstorm</a><br>请求的链接地址将会是这样的形式；这个有点像http里添加url参数；<br>还可以设置Headers；<br><code>const headers = new HttpHeaders().set(&quot;X-CustomHeader&quot;, &quot;custom header value&quot;);</code><br>还有其他的请求，之后会逐一分析；<br>另外还有几点比较重要的：多行并发发送请求和顺序发送请求，避免发送重复请求； </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'rxjs/add/operator/shareReplay'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> httpGet = <span class=\"keyword\">this</span>.http</div><div class=\"line\">    .get(<span class=\"string\">\"assets/heroes.json\"</span>)</div><div class=\"line\">    .map(data =&gt; _.values(data))</div><div class=\"line\">    .shareReplay();</div></pre></td></tr></table></figure>\n<p>这样即使你将 httpGet再赋值给另一个变量，或重复调用也不会再次请求了<br>并行发送 HTTP 请求的一种方法是使用 RxJs 中的 forkjoin 操作符：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'rxjs/add/observable/forkJoin'</span>;</div><div class=\"line\">Requests() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> result = Observable.forkJoin(</div><div class=\"line\">        <span class=\"keyword\">this</span>.http.get(<span class=\"string\">'/assets/heroes.json'</span>),</div><div class=\"line\">        <span class=\"keyword\">this</span>.http.get(<span class=\"string\">'/assets/heroes.json'</span>)</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">   result.subscribe(</div><div class=\"line\">        values =&gt; &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"all values\"</span>, values)</div><div class=\"line\">        &#125;</div><div class=\"line\">    );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>顺序发送请求</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">sequentialRequests() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> sequence$ = <span class=\"keyword\">this</span>.http.get&lt;Hero&gt;(<span class=\"string\">'/assets/heroes.json'</span>)</div><div class=\"line\">        .switchMap(hero =&gt; &#123;</div><div class=\"line\">            hero.id+= <span class=\"string\">' - TEST '</span>;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http.put(<span class=\"string\">'/assets/heroes.json'</span>, hero)</div><div class=\"line\">        &#125;);</div><div class=\"line\">        </div><div class=\"line\">    sequence$.subscribe();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>6.拦截器  （拦截所有的请求和响应这也是@angular/common/http的核心特性之一）<br>它能声明一些拦截器，拦在应用和后端之间。当应用程序发起一个请求时，拦截器可以在请求被发往服务器之前先转换这个请求。并且在应用看到服务器发回来的响应之前，转换这个响应。这对于处理包括认证和记录日志在内的一系列工作都非常有用。<br>6.1 如何写一个拦截器</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;Injectable&#125; from <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse&#125; from <span class=\"string\">'@angular/common/http'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;Observable&#125; from <span class=\"string\">'Rxjs/Observable'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Injectable</span>()</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> NoopInterceptor <span class=\"keyword\">implements</span> HttpInterceptor &#123;</div><div class=\"line\">   intercept(req: HttpRequest&lt;<span class=\"built_in\">any</span>&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;<span class=\"built_in\">any</span>&gt;&gt; &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> next.handle(req).map(event =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (event <span class=\"keyword\">instanceof</span> HttpResponse) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (event.status === <span class=\"number\">401</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// JWT expired, go to login</span></div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> event;</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>1.intercept是一个方法，它把一个请求对象转换成一个返回这个响应的可观察对象（Observable）。从这个意义上说，每个拦截器都要完全自己处理这个请求；<br>2.响应拦截器可以通过在 next.handle(req) 返回的流对象 (即 Observable 对象) 上应用附加的 Rx 操作符来转换响应事件流对象；<br>内部可以做自己的处理操作；<br>但是此时拦截器还未使用在组件上；</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;NgModule&#125; from <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;HTTP_INTERCEPTORS&#125; from <span class=\"string\">'@angular/common/http'</span>;</div><div class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</div><div class=\"line\">  providers: [&#123;</div><div class=\"line\">    provide: HTTP_INTERCEPTORS,</div><div class=\"line\">    useClass: NoopInterceptor,</div><div class=\"line\">    multi: <span class=\"literal\">true</span>,</div><div class=\"line\">  &#125;],</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> AppModule &#123;&#125;</div></pre></td></tr></table></figure>\n<p>providers里面配置我们的信息；<br>注意multi: true选项。这是必须的，因为它会告诉 Angular 这个 HTTP_INTERCEPTORS 表示的是一个数组，而不是单个的值；</p>\n","comments":true,"categories":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/categories/Angular-2/"}],"tags":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/tags/Angular-2/"},{"name":"httpClient","slug":"httpClient","permalink":"http://www.sulishibaobei.com/tags/httpClient/"}]},{"title":"bootstrap简单图文环绕效果","date":"2017-09-08T01:08:53.000Z","path":"bootstrap/bt-120170908/","text":"一.下载bootstrap-3.3.7二.在html页面引入css,js;eg:123&lt;link src=\"bootstrap-3.3.7-dist/css/bootstrap.min.css\"&gt;&lt;script type=\"text/javascript\" src=\"jquery.min.js\"&gt;&lt;/ script&gt; &lt;script type=\"text/javascript\" src=\"bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/ script&gt; 注意：因为会用到jquery，所以引入了jquery .js;三.body部分的代码是这样的：123456&lt;body style=\"margin: 10px;padding: 0px\"&gt; &lt;div class=\"left\"&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;/div&gt;&lt;body/&gt; 简单解析下： body里包含两个div ,一个在左边排列(用于放图片)，一个在右边排列(用于放文字);都用class名进行区分啦，left和right;简单的给两个div添加点样式： .left { float : left ; max-width : 43% ; padding-left : 5px ; } .right{ margin-left : 5px ; } 现在还看不出什么效果;给第一个div里添加图片;&lt; img src=”index.jpg” class=”img-responsive” alt=”图像”&gt; 给第二个div添加文字，里面的文字是采用Boostrap的样式; &lt;div class=\"container\"&gt; &lt;h1&gt;图文环绕&lt;/h1&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 col-md-offset-3\" style=\" box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\" style=\" box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;风雨中走过却不安世事的心&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;我还是很喜欢你，像风走了三千米不问归期 我希望有个如你一般的人如山间清爽的风如古城温暖的光从清晨到夜晚由山野到书房只要最后是你就好 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-sm-offset-3\" style=\"box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;我觉得这个世界美好无比。晴时满树花开，雨天一湖涟漪，阳光席卷城市，微风穿越指间，入夜每个电台播放的情歌，沿途每条山路铺开的影子，全部是你不经意写的一字一句，留我年复一年朗读。这世界是你的遗嘱，而我是你唯一的遗物。 &lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;一个人的记忆就是座城市，时间腐蚀着一切建筑，把高楼和道路全部沙化。如果你不往前走，就会被沙子掩埋。所以我们泪流满面，步步回头，可是只能往前走 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"clearfix visible-xs\"&gt;&lt;/div&gt; &lt;div class=\"col-xs-6 col-md-offset-3\" style=\" box-shadow:inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;你燃烧，我陪你焚成灰烬。你熄灭，我陪你低落尘埃。你出生，我陪你徒步人海。你沉默，我陪你一言不发，你欢笑，我陪你山呼海啸。你衰老，我陪你满目疮痍。你逃避，我陪你隐入夜晚。你离开，我只能等待。 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-sm-offset-3\" style=\"box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"&gt; &lt;p&gt;我希望买的鞋子是你渴望的颜色。我希望拨通电话时你恰好在想我。我希望说早安你也刚起床。我希望写的书是你欣赏的故事。我希望关灯的刹那你正泛起困意。我希望买的水果你永远觉得是甜的。我希望点的歌都是你喜欢唱的。我希望我希望的是你希望的。 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"clearfix visible-xs\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 采用的是bootstrap的架构： container&gt; row&gt; column&nbsp;将css样式也写在标签上，所以有点看起来复杂，其实很简单，这几段文字的结构都一样。看看运行效果：拖动页面试试你可以通过控制台随意拖动页面的宽度，看看文字的适配程度。源码另外有两个免费网站模板也可以看看，在同一个github路径下","content":"<p>一.下载bootstrap-3.3.7<br>二.在html页面引入css,js;<br>eg:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bootstrap-3.3.7-dist/css/bootstrap.min.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jquery.min.js\"</span>&gt;</span><span class=\"xml\"><span class=\"tag\">&lt;/ <span class=\"attr\">script</span>&gt;</span> </span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bootstrap-3.3.7-dist/js/bootstrap.min.js\"</span>&gt;</span><span class=\"xml\"><span class=\"tag\">&lt;/ <span class=\"attr\">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>注意：因为会用到jquery，所以引入了jquery .js;<br>三.body部分的代码是这样的：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">style</span>=<span class=\"string\">\"margin: 10px;padding: 0px\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span>  </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"right\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>/&gt;</span></div></pre></td></tr></table></figure></p>\n<p>简单解析下：<br>  body里包含两个div ,一个在左边排列(用于放图片)，一个在右边排列(用于放文字);都用class名进行区分啦，left和right;<br>简单的给两个div添加点样式： </p>\n<pre><code class=\"css\"><span class=\"selector-class\">.left</span>  { \n  <span class=\"attribute\">float </span>:  left ; \n  <span class=\"attribute\">max-width </span>:  <span class=\"number\">43%</span> ; \n  <span class=\"attribute\">padding-left </span>:  <span class=\"number\">5px</span> ;  \n     } \n <span class=\"selector-class\">.right</span>{ \n <span class=\"attribute\">margin-left </span>:  <span class=\"number\">5px</span> ;\n     }\n</code></pre>\n<p>现在还看不出什么效果;<br>给第一个div里添加图片;<br><code>&lt; img src=”index.jpg” class=”img-responsive” alt=”图像”&gt; </code><br>给第二个div添加文字，里面的文字是采用Boostrap的样式; </p>\n<pre><code class=\"html\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span>\n                <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>图文环绕<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n                <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span>\n                  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-xs-6 col-md-offset-3\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\" box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"</span>&gt;</span>\n                        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span>\n                            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-md-6\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\" box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"</span>&gt;</span>\n                                <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&amp;nbsp;&amp;nbsp;&amp;nbsp;风雨中走过却不安世事的心<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n                            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n                      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n                               <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&amp;nbsp;&amp;nbsp;&amp;nbsp;我还是很喜欢你，像风走了三千米不问归期 我希望有个如你一般的人如山间清爽的风如古城温暖的光从清晨到夜晚由山野到书房只要最后是你就好 <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n                 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n                <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-xs-6 col-sm-offset-3\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"</span>&gt;</span>\n                      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&amp;nbsp;&amp;nbsp;&amp;nbsp;我觉得这个世界美好无比。晴时满树花开，雨天一湖涟漪，阳光席卷城市，微风穿越指间，入夜每个电台播放的情歌，沿途每条山路铺开的影子，全部是你不经意写的一字一句，留我年复一年朗读。这世界是你的遗嘱，而我是你唯一的遗物。\n                      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n                      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&amp;nbsp;&amp;nbsp;一个人的记忆就是座城市，时间腐蚀着一切建筑，把高楼和道路全部沙化。如果你不往前走，就会被沙子掩埋。所以我们泪流满面，步步回头，可是只能往前走 <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n               <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n               <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"clearfix visible-xs\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n                  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-xs-6 col-md-offset-3\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\" box-shadow:inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"</span>&gt;</span>\n                   <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&amp;nbsp;&amp;nbsp;&amp;nbsp;你燃烧，我陪你焚成灰烬。你熄灭，我陪你低落尘埃。你出生，我陪你徒步人海。你沉默，我陪你一言不发，你欢笑，我陪你山呼海啸。你衰老，我陪你满目疮痍。你逃避，我陪你隐入夜晚。你离开，我只能等待。 <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n               <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n             <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-xs-6 col-sm-offset-3\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"box-shadow: inset 1px -1px 1px #ccc, inset -1px 1px 1px #ccc;\"</span>&gt;</span>\n                 <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我希望买的鞋子是你渴望的颜色。我希望拨通电话时你恰好在想我。我希望说早安你也刚起床。我希望写的书是你欣赏的故事。我希望关灯的刹那你正泛起困意。我希望买的水果你永远觉得是甜的。我希望点的歌都是你喜欢唱的。我希望我希望的是你希望的。\n                  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>\n             <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n             <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"clearfix visible-xs\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n</code></pre>\n<p>采用的是bootstrap的架构： container&gt; row&gt; column&nbsp;<br>将css样式也写在标签上，所以有点看起来复杂，其实很简单，这几段文字的结构都一样。<br>看看运行效果：<br><img src=\"/images/bt-1.png\" alt=\"bt\"><br>拖动页面试试<br><img src=\"/images/bt-2.png\" alt=\"bt\"><br>你可以通过控制台随意拖动页面的宽度，看看文字的适配程度。<br><a href=\"https://github.com/sulishibaobei/bootstrap/tree/master/bootstrap%20by%20around\" target=\"_blank\" rel=\"external\">源码</a><br>另外有两个免费网站模板也可以看看，在同一个github路径下</p>\n","comments":true,"categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://www.sulishibaobei.com/categories/Bootstrap/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://www.sulishibaobei.com/tags/bootstrap/"},{"name":"图文环绕","slug":"图文环绕","permalink":"http://www.sulishibaobei.com/tags/图文环绕/"}]},{"title":"angular4 中自定义pagination组件","date":"2017-09-08T01:08:53.000Z","path":"angular/pg-120170908/","text":"你用Angular 吗?一.介绍一个基于angular4 开发的可以分页的组件。组件的好处就是可以复用，复用…..作为一个前端码农，开始的分页功能实现是我用jquery写的，其他同事用的时候都要将我的代码拷贝过去，于是我被鄙视了。为了不继续被鄙视就开始了尝试。二.基本功能1.根据规定的每页数据条数，分页显示数据2.上下页操作数据直接上界面图可能清晰点： 项目截图根据图片进行讲解下：根据你总数据条数:totalNum; 每页显示条数:pageSize,通过组件会自动给你分页显示。eg：总数41 条数据,每页显示10条数据，则是分成5页。如果想每页显示7条，则会分成6页。三.简要代码架构目录图： 项目目录有两个组件：pagination和page;&nbsp; pagination是用来显示前面数据的，page是用来下面分页的。pagination.html示例代码： 数据显示部分代码ngb-xxx不用在意，是用的ng-bootstrap，只是为了让界面好看点。其实就是一个简单的table用来显示数据。*ngFor用来取数据，懂Angular 的人应该都会，这不是重点就不介绍了。&lt;page&gt;&lt;/page&gt;&nbsp;这里是引入page组件。但是传入了一些属性值；关于模板语法，依赖注入，自定义事件就不介绍了。只要知道这里是：pagination组件向page组件传入了几个值：pageSize(页面显示数据条数)，totalNum(总数据条数),curPage(当前页码 ），totalPage(总页码),pageData(每页显示数据)其中pageSize和pageData是一样的，只是后面为了操作，多传了一个值；那么：pageSize等值都是哪里来的呢，当然是pagination.ts里定义的： pagination.ts代码代码中的page就是你获得到得数据，自然totalNum就会等于数据的长度。依次算出来就好了。 pagination组件算是完成了，现在就来看看page是怎么接收到数据并进行操作的。page.html页面的代码： page.ts 分页数据的html其实很简单：就一个a标签显示条数，页数的，三个button,一个显示上一页，一个页数，一个下一页。每个按钮都绑定了一个changePage事件；看一下实现部分的代码： page.ts分页实现部分代码@Input是接收pagination.html组件传过来的数据。@Output是定义pagination.html页面定义的changeCurPage事件。通过三个if else判断，对传多来的数据进行处理。其实就分为：数据只够显示一页；数据显示到最后一页；数据刷新到中间页码；这三种情况下的操作。好了，基本就完成了。有些东西也是借助网友的想法，但是思路大致都是这样。现在我改变条数和数据量看看： &nbsp; 项目截图详情代码及效果：https://github.com/sulishibaobei/pagination","content":"<p><img src=\"/images/fengjing-3.jpg\" alt=\"fengjing\"></p>\n<p><div class=\"image-caption\">你用Angular 吗?</div><br><a id=\"more\"></a><br><br>一.介绍<br>一个基于angular4 开发的可以分页的组件。组件的好处就是可以复用，复用…..作为一个前端码农，开始的分页功能实现是我用jquery写的，其他同事用的时候都要将我的代码拷贝过去，于是我被鄙视了。为了不继续被鄙视就开始了尝试。<br>二.基本功能<br>1.根据规定的每页数据条数，分页显示数据<br>2.上下页操作数据<br>直接上界面图可能清晰点：<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-2fe57ab69ccdcb87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\" data-original-src=\"http://upload-images.jianshu.io/upload_images/4116930-2fe57ab69ccdcb87.png?imageMogr2/auto-orient/strip\" data-image-slug=\"2fe57ab69ccdcb87\" data-width=\"1338\" data-height=\"655\"> </p>\n<p><div class=\"image-caption\">项目截图</div><br>根据图片进行讲解下：根据你总数据条数:totalNum; 每页显示条数:pageSize,通过组件会自动给你分页显示。<br>eg：总数41 条数据,每页显示10条数据，则是分成5页。如果想每页显示7条，则会分成6页。<br>三.简要代码<br>架构目录图：<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-fed7af4e2c9f5530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\" data-original-src=\"http://upload-images.jianshu.io/upload_images/4116930-fed7af4e2c9f5530.png?imageMogr2/auto-orient/strip\" data-image-slug=\"fed7af4e2c9f5530\" data-width=\"360\" data-height=\"351\"> </p>\n<p><div class=\"image-caption\">项目目录</div><br>有两个组件：pagination和page;&nbsp; pagination是用来显示前面数据的，page是用来下面分页的。<br>pagination.html示例代码：<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-7fc90a6263bba71b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\" data-original-src=\"http://upload-images.jianshu.io/upload_images/4116930-7fc90a6263bba71b.png?imageMogr2/auto-orient/strip\" data-image-slug=\"7fc90a6263bba71b\" data-width=\"1517\" data-height=\"603\"> </p>\n<p><div class=\"image-caption\">数据显示部分代码</div><br>ngb-xxx不用在意，是用的ng-bootstrap，只是为了让界面好看点。其实就是一个简单的table用来显示数据。*ngFor用来取数据，懂Angular 的人应该都会，这不是重点就不介绍了。<br>&lt;page&gt;&lt;/page&gt;&nbsp;<br>这里是引入page组件。但是传入了一些属性值；关于模板语法，依赖注入，自定义事件就不介绍了。只要知道这里是：pagination组件向page组件传入了几个值：pageSize(页面显示数据条数)，totalNum(总数据条数),curPage(当前页码 ），totalPage(总页码),pageData(每页显示数据)<br>其中pageSize和pageData是一样的，只是后面为了操作，多传了一个值；<br>那么：pageSize等值都是哪里来的呢，当然是pagination.ts里定义的：<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-a003c8ca2a6946ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\" data-original-src=\"http://upload-images.jianshu.io/upload_images/4116930-a003c8ca2a6946ae.png?imageMogr2/auto-orient/strip\" data-image-slug=\"a003c8ca2a6946ae\" data-width=\"948\" data-height=\"296\"> </p>\n<p><div class=\"image-caption\">pagination.ts代码</div><br>代码中的page就是你获得到得数据，自然totalNum就会等于数据的长度。依次算出来就好了。 pagination组件算是完成了，现在就来看看page是怎么接收到数据并进行操作的。<br>page.html页面的代码：<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-bdee3bc2c0eaf98c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\" data-original-src=\"http://upload-images.jianshu.io/upload_images/4116930-bdee3bc2c0eaf98c.png?imageMogr2/auto-orient/strip\" data-image-slug=\"bdee3bc2c0eaf98c\" data-width=\"1753\" data-height=\"404\"> </p>\n<p><div class=\"image-caption\">page.ts 分页数据的html</div><br>其实很简单：就一个a标签显示条数，页数的，三个button,一个显示上一页，一个页数，一个下一页。每个按钮都绑定了一个changePage事件；<br>看一下实现部分的代码：<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-012ecce551a391ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\" data-original-src=\"http://upload-images.jianshu.io/upload_images/4116930-012ecce551a391ef.png?imageMogr2/auto-orient/strip\" data-image-slug=\"012ecce551a391ef\" data-width=\"1664\" data-height=\"1269\"> </p>\n<p><div class=\"image-caption\">page.ts分页实现部分代码</div><br>@Input是接收pagination.html组件传过来的数据。@Output是定义pagination.html页面定义的changeCurPage事件。<br>通过三个if else判断，对传多来的数据进行处理。其实就分为：数据只够显示一页；数据显示到最后一页；数据刷新到中间页码；这三种情况下的操作。<br>好了，基本就完成了。有些东西也是借助网友的想法，但是思路大致都是这样。现在我改变条数和数据量看看：<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-a5a797d4493a0cb9.png\" alt=\"\" data-original-src=\"http://upload-images.jianshu.io/upload_images/4116930-a5a797d4493a0cb9.png\" data-image-slug=\"a5a797d4493a0cb9\"> </p>\n<p><div class=\"image-caption\">&nbsp; 项目截图</div><br>详情代码及效果：<a href=\"https://github.com/sulishibaobei/pagination\" target=\"_blank\" rel=\"external\">https://github.com/sulishibaobei/pagination</a></p>\n","comments":true,"categories":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/categories/Angular-2/"}],"tags":[{"name":"Angular2+","slug":"Angular2","permalink":"http://www.sulishibaobei.com/tags/Angular2/"},{"name":"分页组件","slug":"分页组件","permalink":"http://www.sulishibaobei.com/tags/分页组件/"}]},{"title":"Angular 4+ Http","date":"2017-09-08T01:08:53.000Z","path":"angular/http/http-120170908/","text":"HTTP: 使应用能够对远端服务器发起相应的Http调用；你要知道：HttpModule并不是Angular的核心模块，它是Angualr用来进行Web访问的一种可选方式，并位于一个名叫@angual/http的独立附属模块中；也就是说：使用http之前要引入此模块; 1.基本使用：12345678910111213141516import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123;HttpModule&#125; from '@angular/http'; /*引入它*/import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, HttpModule /*导入*/ ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 注意，现在HttpModule已经是根模块AppModule的imports数组的一部分了; 2.介绍模拟web api 发送请求注意：是在你没有真实的远程服务请求地址时，自己模拟一个web服务，用于测试代码；倘若有真实的远程服务器，则不需要这个； 2.1 引入InMemoryWebApiModule，这是Angular提供的一个辅助服务，负责与远程服务器对话 — 替换成了内存 Web API服务，类似于后端服务；import { InMemoryWebApiModule } from ‘angular-in-memory-web-api’;注意：导入这个，如果出现错误，可能是你的node-module 文件库里面没有此库，这时候打开你的package.json文件：“dependencies”里面配置这样一句：“angular-in-memory-web-api”: “^0.3.2” 重新运行npm install; 2.2 向内存服务中注入数据，如果没有数据是不能运行的；import { InMemoryDataService } from ‘./in-memory-data.service’;注意几点： 1234567891011121314in-memory-data.service.ts 文件是你自己创建的，用来存放实例数据的；in-memory-data.service.ts 这样写：import &#123; InMemoryDbService &#125; from 'angular-in-memory-web-api';export class InMemoryDataService implements InMemoryDbService&#123; createDb() &#123; const heroes = [ &#123; id: 0, name: 'Zero' &#125;, &#123; id: 1, name: 'Mr. Nice' &#125;, &#123; id: 2, name: 'Narco' &#125;, &#123; id: 3, name: 'Bombasto' &#125;, ]; return &#123;heroes&#125;; &#125;&#125; 这里相当于自己创建了一个内部数据库； 2.3导入的文件如何在app.module.ts中注入：12345678910111213141516171819import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123;HttpModule&#125; from '@angular/http';import &#123; InMemoryWebApiModule &#125; from 'angular-in-memory-web-api';import &#123; InMemoryDataService &#125; from './in-memory-data.service';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, HttpModule, InMemoryWebApiModule.forRoot(InMemoryDataService), /*这样注入*/ ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 这里现在就是全部代码； 3.如何发起http请求；3.1创建一个服务；1234import &#123;Injectable&#125; from '@angular/core';@Injectable()export class HeroService&#123;&#125; angular 中所有创建服务的模式都是这样，我们创建了一个HeroService的文件，下载要在app.module.ts中注入它； 123import &#123;HeroService&#125; from './hero.service'; providers: [HeroService], bootstrap: [AppComponent] 注意：1.providers 是专门用来注入服务的； 可以在app.module.ts里的providers中注入服务，也可以在你的子模块和组件中注入，前者是共享的服务，一次注入，整个项目都有效，如果在子模块中或者子组件中注入，这只是你属于当前模块或当前组件下有效，其他的组件需要使用，都得自己重新注入；一般情况下：返回的是一个能解析的promise(承诺)3.2 引入http ; 12import &#123;Http&#125; from '@angular/http';constructor(private http:Http)&#123; &#125; 一定要在构造里创建它； 3.3 尝试获取内存数据库里面的信息；123456789101112131415import &#123;Injectable&#125; from '@angular/core';import &#123;Http&#125; from '@angular/http';import 'rxjs/add/operator/toPromise';import &#123;Hero&#125; from './hero';@Injectable()export class HeroService&#123; constructor(private http:Http)&#123; /*注释1*/ private heroUrl='api/heroes'; /*注释2*/ getHeroes(): Promise&lt;Hero[]&gt;&#123; return this.http.get(this.heroUrl) /*注释3*/ .toPromise() /*注释4*/ .then(response =&gt;response.json().data as Hero[])/*注释5*/ .catch((error: any) =&gt; Promise.reject(error || \"Server error\")); &#125; &#125; 现在我写了一个getHeroes()的方法：解析几点：注释1：http请求肯定需要Url地址，这里需要导入数据库里面的名；api/heroes 其实就是你内存数据库 web api里面return {heroes};根据你返回的值，调用相应的api地址；注释2：使用的是http承诺（promise），一定要有返回值，返回的是一个可以解析成英雄列表的Observable对象 ,也就是我们的Hero；也就是需要导入这个import {Hero} from &#39;./hero&#39;;hero.ts文件包含： 1234export class Hero&#123; id:number; name:string;&#125; Observable（可观察对象）是一个管理异步数据流的强力方式，后续会学习；注释3：.toPromise会将我们得到的Observable对象转化成promise对象；但是Angular中的observable对象并没有一个topromise操作符，这里就需要借助其他工具，import &#39;rxjs/add/operator/toPromise&#39;;更多详细的可以看rxjs库操作符；注释4：在 then 回调中提取出数据，这也是angular中一大特点，默认 JSON 解析,这个由json方法返回的对象只有一个data属性。这个data属性保存了英雄数组，这个数组才是调用者真正想要的。 所以我们取得这个数组，并且把它作为承诺的值进行解析注意：web api 返回的是带有data属性的对象，而你真是的api可以返回其他值的；注释5：错误处理,有异常很正常，我们可以将他们传给错误处理器；现在我们只是将错误记录到控制台，真实案例中，可以将错误进行处理； 4.如何将获得的数据显示在界面；4.1 组件中调用Hero.service.ts；12345678910111213141516171819202122import &#123; Component &#125; from '@angular/core';import &#123;HeroService&#125; from './hero.service';import &#123;Hero&#125; from './hero';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; /*注释1*/ hero:Hero[]; /*注释2*/ constructor(private service:HeroService)&#123; this.getHeroes(); &#125; getHeroes()&#123;/*注释3*/ this.service.getHeroes().then( hero=&gt;&#123; this.hero=hero; console.log(this.hero); &#125;/*注释4*/ ).catch((error: any) =&gt; Promise.reject(error || 'client error')) &#125;&#125; 注释1： 用来接收返回的对象；注释2： 对引入的hero.service.ts服务初始化；注释3： 返回的是promise对象，用then方法去解析得到的值；注释4： 预期会犯错，抛出异常；现在可以看看控制台打印的hero对象：如何显示在我们的html上呢？123&lt;ul *ngFor=\"let a of hero\"&gt; &lt;li&gt;&#123;&#123;a.id&#125;&#125; : &#123;&#123;a.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 简单的写了这样一段：这里注意：多对数组或对象形式用*ngFor遍历；运行localhost:4200,这样就可以让数据正常显示啦；这里介绍的是采用promise的形式调用http的方法，原理就是：hero.service中，http.get()返回的Observable后面串联了一个toPromise操作符。 该操作符把Observable转换成了Promise，并且我们把那个承诺返回给了调用者； 5.http promise还能做什么？5.1 尝试通过id获取英雄；hero.service.ts中添加这段代码： 123456789getHero(id:number):Promise&lt;Hero&gt;&#123; const url = `$&#123;this.heroUrl&#125;/$&#123;id&#125;`; return this.http.get(url) .toPromise() .then(response =&gt; response.json().data as Hero, ) .catch((error: any) =&gt; Promise.reject(error || 'Server error')); &#125; 和获取所有英雄的方法类似，这个的步骤是先获取所有的英雄，并从中过滤出与id匹配的那一个；匹配api/hero/:id 模式，有点像路由； 5.2 组件中如何调用；123456789detailhero:Hero;getHero(id:number)&#123; this.service.getHero(id).then( hero=&gt;&#123; this.detailhero=hero; console.log(this.detailhero); &#125; ).catch((error: any) =&gt; Promise.reject(error || 'client error')) &#125; 方法都类似，只是你需要传入想查询的id;constructor中运行此方法，比如我想知道第二个英雄的详情：this.getHero(2);看看控制台输出：看看html代码：注意：单个对象用*ngIf ； 6.http promise还有什么请求方式？1234567891011121314151617181920212223242526272829request(url: string | Request, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `get` http method. */ get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `post` http method */ post(url: string, body: any, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `put` http method. */ put(url: string, body: any, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `delete` http method. */ delete(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `patch` http method. */ patch(url: string, body: any, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `head` http method. */ head(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;; /** * Performs a request with `options` http method. */ options(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;; 6.1 我们来添加一个英雄；hero.service.ts中加入这一段： 12345678910/*注释1*/ private headers = new Headers(&#123;'Content-Type': 'application/json'&#125;); addHero(name:string):Promise&lt;Hero&gt;&#123; return this.http.post(this.heroUrl,JSON.stringify(&#123;name:name&#125;),&#123;headers:this.headers&#125;) .toPromise() .then( res=&gt; res.json().data as Hero ) .catch((error: any) =&gt; Promise.reject(error || 'Server error')); &#125; 注释1： 1import &#123;Http,Headers&#125; from '@angular/http'; 需要引入Headers，然后new 一个实例；但是这个参数是可选的；组件中怎么接收： 12345678910addhero:Hero; addHero(name:string)&#123; this.service.addHero(name).then( hero=&gt;&#123; this.addhero=hero; console.log(this.addhero); this.hero.push(this.addhero); /*将添加的数据Push进hero数组*/ &#125; ).catch((error: any) =&gt; Promise.reject(error || 'client error')) &#125; 一样的代码，就不过多解释；我们的英雄在哪里添加呢？肯定是要有一个input输入框的： 1234&lt;div&gt; add:&lt;input #heroName/&gt; &lt;button (click)=\"addHero(heroName.value);heroName.value=''\"&gt;add&lt;/button&gt;&lt;/div&gt; 添加之后，可以看到控制台会有输出：但是界面显示的还是这些：Angular会自动检测数据的变换，当有数据变换时，会实时更新还有一些其他方法，自己去尝试下；hero.service.ts: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; Injectable &#125; from '@angular/core';import &#123; Http, Headers,Response&#125; from '@angular/http';import 'rxjs/add/operator/toPromise';import &#123; Hero &#125; from './hero';@Injectable()export class HeroService &#123; constructor(private http: Http) &#123; &#125; private heroUrl = 'api/heroes'; getHeroes(): Promise&lt;Hero[]&gt; &#123; return this.http.get(this.heroUrl) .toPromise() .then( this.extractData ) /*注释1*/ .catch((error: any) =&gt; Promise.reject(error || 'Server error'));/*注释2*/ &#125; getHero(id: number): Promise&lt;Hero&gt; &#123; const url = `$&#123;this.heroUrl&#125;/$&#123;id&#125;`; return this.http.get(url) .toPromise() .then(this.extractData) .catch(this.handleError); &#125; private headers = new Headers(&#123; 'Content-Type': 'application/json' &#125;); addHero(name: string): Promise&lt;Hero&gt; &#123; return this.http.post(this.heroUrl, JSON.stringify(&#123; name: name &#125;), &#123; headers: this.headers &#125;) .toPromise() .then(this.extractData) .catch(this.handleError); &#125; /** * * @param res 接收数据的方法 */ private extractData(res: Response) &#123; /*注释2*/ let body = res.json(); return body.data|| &#123;&#125;; /*注释3*/ &#125; /** * * @param error 处理错误的方法 */ private handleError(error: Response | any) &#123; return Promise.reject(error || 'Server error'); &#125;&#125; 注释1：将then()和catch()里面的部分提取出来，每次使用只需要调用方法即可；注释2：接收的Response记得将Response在Http对象中引入；注释3：这里接收的data其实是一个any型; 7. Observable对象Http服务中的每个方法都返回一个 HTTP Response对象的Observable实例；Observable 就是一个拥有以下特性的函数： 它接收一个 observer 对象作为参数，该对象中包含 next、error 和 complete 方法 它返回一个函数，用于在销毁 Observable 时，执行清理操作在 RxJS 中，返回的是 Subcription 对象，该对象中包含一个 unsubscribe 方法。一个 Observable 对象设置观察者 (observer)，并将它与生产者关联起来。该生产者可能是 DOM 元素产生的 click 或 input 事件，也可能是更复杂的事件，如 HTTP。当 Observable 对象产生新值的时候，我们可以通过调用 next() 方法来通知对应的观察者。若出现异常，则会调用观察者的 error() 方法。当我们订阅 Observable 对象后，只要有新的值，都会通知对应的观察者。但在以下两种情况下，新的值不会再通知对应的观察者：已调用 observer 对象的 complete() 方法消费者对数据不再感兴趣，执行取消订阅操作此外在执行最终的 subscribe() 订阅操作前，我们传递的值可以经过一系列的链式处理操作。执行对应操作的东西叫操作符，每个操作符执行完后会返回一个新的 Observable 对象，然后继续我们的处理流程。那么我们可以直接返回Observable给组件吗？我们可以看看，之前getHero()那一段如果直接改成返回Observable对象会如何；1234getHeroes():Observable&lt;Hero[]&gt;&#123; /*注释1*/ return this.http.get(this.heroUrl) .map(this.extractData); &#125; 注释1：不用调用toPromise()方法，自然也不用then()去取数据，而是直接返回Observable对象之后调用RXJS中的map操作符来从返回的数据中提取数据；所以你要引入：12import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/add/operator/map'; 操作符之后会讲到，注意和之前的promise方法对比；组件中怎么接收数据Observable对象呢？12345678getHeroes()&#123; this.service.getHeroes().subscribe( /*注释1*/ hero=&gt;&#123; this.hero=hero; console.log(this.hero); &#125; ) &#125; 这样显示的效果也是一样的；注释1：调用 subscribe() 方法，来获取最终的值，采取订阅的方式，而不是用then(); 8. Observabel和Promise 有什么不同8.1 两个都可以用于web API http的调用，但Observable是可以中途取消的，而Promise一旦触发就不能被取消；123setTimeout(() =&gt; &#123; this.service.getHero().unsubscribe(); &#125;, 1000); 8.2 因为Promise只能发起一次请求，只要接收到数据，就会算完成，所以Promise只能发射一个值就算结束，Observable可以连续发送好几个值，在服务器对第一个请求作出回应之前，再开始另一个不同的请求；1234567891011this.heroes = this.searchTerms .debounceTime(300) .distinctUntilChanged() .switchMap(term =&gt; term ? this.service.search(term) : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;);this.heroes.subscribe(value =&gt; console.log(value)); 这个后面代码操作符这块有详解； 8.3 Observable提供了很多的工具函数，最最最常用的filter和map；详细看看这两个map和filter； map() 操作符返回一个新的 Observable 对象 filter() 操作符执行过滤操作，然后又返回一个新的 Observable 对象最后我们通过调用 subscribe() 方法，来获取最终的值Filter:过滤器12345678getHeroes()&#123; this.service.getHeroes().filter(hero =&gt; hero.length &gt;= 2) .subscribe( hero=&gt;&#123; this.hero=hero; &#125; ) &#125; Map的用法上面有介绍；但是，使用承诺的方式能让调用方法更容易写，并且承诺已经在 JavaScript 程序员中被广泛接受了。再来看看Observable操作符：根据名字搜索用户：12345search(term: string): Observable&lt;Hero[]&gt; &#123; return this.http .get(`api/heroes/?name=$&#123;term&#125;`) .map(response =&gt; response.json().data as Hero[]); &#125; 看看组件代码：123456789 import &#123; Observable &#125; from 'rxjs/Observable'; /*注释1*/import &#123; Subject &#125; from 'rxjs/Subject'; /*注释2*/// Observable class extensionsimport 'rxjs/add/observable/of'; /*注释3*/// Observable operatorsimport 'rxjs/add/operator/catch'; /*注释4*/import 'rxjs/add/operator/debounceTime'; /*注释5*/import 'rxjs/add/operator/distinctUntilChanged'; /*注释6*/import 'rxjs/add/operator/switchMap'; /*注释6*/ 引入这些操作符：注释1：引入RXJS的可观察对象；注释2：Suject是一个可观察事件流中的生产者，通过调用Next()对象，可以将新观察的对象放入可观察流中；注释3：是Rxjs为Observable对象提供的扩展，注释4：异常操作符，拦截失败的可观察对象。注释5：相当于settimeout(),延迟；注释6：distinctUntilChanged确保只在过滤条件变化时才发送请求， 这样就不会重复请求同一个搜索词了；注释7：switchMap()会为每个从debounce和distinctUntilChanged中通过的搜索词调用搜索服务。 它会取消并丢弃以前的搜索可观察对象，只保留最近的；使用这个每触发一次事件都会引起一次Http()的调用，即使你使用延迟，但同一时间还是会有多个Http请求，并且返回的顺序不一定是请求发起的顺序；看看Http()方法调用：123456789101112131415161718 heroes: Observable&lt;Hero[]&gt;; private searchTerms=new Subject&lt;string&gt;(); // searchTerms生成一个产生字符串的Observable /*每当调用search()时都会调用next()来把新的字符串放进该主题的可观察流中*/ search(term:string):void&#123; this.searchTerms.next(term); &#125; ngOnInit(): void &#123; this.heroes = this.searchTerms .debounceTime(300) .distinctUntilChanged() .switchMap(term =&gt; term ? this.service.search(term) : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;);&#125; 看看代码：123456 &lt;div&gt; search :&lt;input #searchBox (keyup)=\"search(searchBox.value)\"/&gt; &lt;div *ngFor=\"let b of heroes | async\"&gt; &#123;&#123;b.name&#125;&#125; &lt;/div&gt;&lt;/div&gt; 为什么使用一个async管道呢？因为得到的是Observable对象，不是数组，*ngFor不能遍历可观察对象；效果：看完这个，大概知道：Observable（可观察对象）是基于推送（Push）运行时执行（lazy）的多值集合；关于操作符，我有话要说：大部分RxJS操作符都不包括在Angular的Observable基本实现中，基本实现只包括Angular本身所需的功能，也就是，你需要的大多操作符都需要从rxjs中引入； 9.上述的例子，其实说的都是关于web api,内存服务器的，占用内存的东西，速率都有点慢，如果你要从本地获取文件记住不要用这个；可以换用json文件获取： 创建一个heroes.json，记得放在assets文件下：{ “data”: [ { “id”: 1, “name”: “Windstorm” }, { “id”: 2, “name”: “Bombasto” }, { “id”: 3, “name”: “Magneta” }, { “id”: 4, “name”: “Tornado” } ]}我们app.module.ts里面的： InMemoryWebApiModule.forRoot(InMemoryDataService),不用引入，引入之后会默认使用web api；然后hero.service.ts中这样private heroesUrl = ‘assets/heroes.json’;其他的都是一样的；这种方式对于请求静态的本地数据是比较有用的；如果是请求真是的远程服务器地址，url换成远程地址就可以；","content":"<p>HTTP: 使应用能够对远端服务器发起相应的Http调用；<br>你要知道：HttpModule并不是Angular的核心模块，它是Angualr用来进行Web访问的一种可选方式，并位于一个名叫@angual/http的独立附属模块中；也就是说：使用http之前要引入此模块;<br><a id=\"more\"></a></p>\n<h2 id=\"1-基本使用：\"><a href=\"#1-基本使用：\" class=\"headerlink\" title=\"1.基本使用：\"></a>1.基本使用：</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserModule &#125; from <span class=\"string\">'@angular/platform-browser'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; NgModule &#125; from <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;HttpModule&#125; from <span class=\"string\">'@angular/http'</span>;  <span class=\"comment\">/*引入它*/</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppComponent &#125; from <span class=\"string\">'./app.component'</span>;</div><div class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</div><div class=\"line\">  declarations: [</div><div class=\"line\">    AppComponent</div><div class=\"line\">  ],</div><div class=\"line\">  imports: [</div><div class=\"line\">    BrowserModule,</div><div class=\"line\">    HttpModule  <span class=\"comment\">/*导入*/</span></div><div class=\"line\">  ],</div><div class=\"line\">  providers: [],</div><div class=\"line\">  bootstrap: [AppComponent]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> AppModule &#123; &#125;</div></pre></td></tr></table></figure>\n<p>注意，现在HttpModule已经是根模块AppModule的imports数组的一部分了;</p>\n<h2 id=\"2-介绍模拟web-api-发送请求\"><a href=\"#2-介绍模拟web-api-发送请求\" class=\"headerlink\" title=\"2.介绍模拟web api 发送请求\"></a>2.介绍模拟web api 发送请求</h2><p>注意：是在你没有真实的远程服务请求地址时，自己模拟一个web服务，用于测试代码；倘若有真实的远程服务器，则不需要这个；</p>\n<h3 id=\"2-1-引入InMemoryWebApiModule，\"><a href=\"#2-1-引入InMemoryWebApiModule，\" class=\"headerlink\" title=\"2.1 引入InMemoryWebApiModule，\"></a>2.1 引入InMemoryWebApiModule，</h3><p>这是Angular提供的一个辅助服务，负责与远程服务器对话 — 替换成了内存 Web API服务，类似于后端服务；<b>import { InMemoryWebApiModule } from ‘angular-in-memory-web-api’;</b><br>注意：导入这个，如果出现错误，可能是你的node-module 文件库里面没有此库，这时候打开你的package.json文件：<b>“dependencies”</b>里面配置这样一句：<b>“angular-in-memory-web-api”: “^0.3.2”</b> 重新运行<b>npm install</b>;</p>\n<h3 id=\"2-2-向内存服务中注入数据，如果没有数据是不能运行的；\"><a href=\"#2-2-向内存服务中注入数据，如果没有数据是不能运行的；\" class=\"headerlink\" title=\"2.2 向内存服务中注入数据，如果没有数据是不能运行的；\"></a>2.2 向内存服务中注入数据，如果没有数据是不能运行的；</h3><p><b>import { InMemoryDataService }  from ‘./in-memory-data.service’;</b><br>注意几点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">in</span>-memory-data.service.ts 文件是你自己创建的，用来存放实例数据的；</div><div class=\"line\"><span class=\"keyword\">in</span>-memory-data.service.ts 这样写：</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; InMemoryDbService &#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular-in-memory-web-api'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InMemoryDataService</span>  <span class=\"title\">implements</span> <span class=\"title\">InMemoryDbService</span></span>&#123;</div><div class=\"line\">   createDb() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> heroes = [</div><div class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">0</span>,  <span class=\"attr\">name</span>: <span class=\"string\">'Zero'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">'Mr. Nice'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">'Narco'</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">'Bombasto'</span> &#125;,</div><div class=\"line\">    ];</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;heroes&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里相当于自己创建了一个内部数据库；</p>\n<h3 id=\"2-3导入的文件如何在app-module-ts中注入：\"><a href=\"#2-3导入的文件如何在app-module-ts中注入：\" class=\"headerlink\" title=\"2.3导入的文件如何在app.module.ts中注入：\"></a>2.3导入的文件如何在app.module.ts中注入：</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/platform-browser'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; NgModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;HttpModule&#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/http'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; InMemoryWebApiModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular-in-memory-web-api'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; InMemoryDataService &#125;  <span class=\"keyword\">from</span> <span class=\"string\">'./in-memory-data.service'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app.component'</span>;</div><div class=\"line\">@NgModule(&#123;</div><div class=\"line\">  <span class=\"attr\">declarations</span>: [</div><div class=\"line\">    AppComponent</div><div class=\"line\">  ],</div><div class=\"line\">  <span class=\"attr\">imports</span>: [</div><div class=\"line\">    BrowserModule,</div><div class=\"line\">    HttpModule,</div><div class=\"line\">    InMemoryWebApiModule.forRoot(InMemoryDataService),  <span class=\"comment\">/*这样注入*/</span></div><div class=\"line\">  ],</div><div class=\"line\">  <span class=\"attr\">providers</span>: [],</div><div class=\"line\">  <span class=\"attr\">bootstrap</span>: [AppComponent]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>\n<p>这里现在就是全部代码；</p>\n<h2 id=\"3-如何发起http请求；\"><a href=\"#3-如何发起http请求；\" class=\"headerlink\" title=\"3.如何发起http请求；\"></a>3.如何发起http请求；</h2><h3 id=\"3-1创建一个服务；\"><a href=\"#3-1创建一个服务；\" class=\"headerlink\" title=\"3.1创建一个服务；\"></a>3.1创建一个服务；</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;Injectable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\">@Injectable()</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeroService</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>angular 中所有创建服务的模式都是这样，我们创建了一个HeroService的文件，下载要在app.module.ts中注入它；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;HeroService&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./hero.service'</span>;</div><div class=\"line\">  providers: [HeroService],</div><div class=\"line\">  <span class=\"attr\">bootstrap</span>: [AppComponent]</div></pre></td></tr></table></figure>\n<p>注意：<br>1.providers 是专门用来注入服务的；</p>\n<ol>\n<li>可以在app.module.ts里的providers中注入服务，也可以在你的子模块和组件中注入，<br>前者是共享的服务，一次注入，整个项目都有效，如果在子模块中或者子组件中注入，这只是你属于当前模块或当前组件下有效，其他的组件需要使用，都得自己重新注入；<br>一般情况下：返回的是一个能解析的promise(承诺)<h3 id=\"3-2-引入http\"><a href=\"#3-2-引入http\" class=\"headerlink\" title=\"3.2 引入http  ;\"></a>3.2 引入http  ;</h3></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;Http&#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/http'</span>;</div><div class=\"line\"><span class=\"keyword\">constructor</span>(private http:Http)&#123; &#125;</div></pre></td></tr></table></figure>\n<p>一定要在构造里创建它；</p>\n<h3 id=\"3-3-尝试获取内存数据库里面的信息；\"><a href=\"#3-3-尝试获取内存数据库里面的信息；\" class=\"headerlink\" title=\"3.3 尝试获取内存数据库里面的信息；\"></a>3.3 尝试获取内存数据库里面的信息；</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;Injectable&#125; from <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;Http&#125; from <span class=\"string\">'@angular/http'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'rxjs/add/operator/toPromise'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;Hero&#125; from <span class=\"string\">'./hero'</span>;</div><div class=\"line\"><span class=\"meta\">@Injectable</span>()</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroService&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> http:Http</span>)&#123; </div><div class=\"line\"> <span class=\"comment\">/*注释1*/</span>  <span class=\"keyword\">private</span> heroUrl=<span class=\"string\">'api/heroes'</span>;</div><div class=\"line\"> <span class=\"comment\">/*注释2*/</span>     getHeroes(): Promise&lt;Hero[]&gt;&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http.get(<span class=\"keyword\">this</span>.heroUrl)</div><div class=\"line\"> <span class=\"comment\">/*注释3*/</span>             .toPromise()</div><div class=\"line\"> <span class=\"comment\">/*注释4*/</span>             .then(response =&gt;response.json().data as Hero[])</div><div class=\"line\"><span class=\"comment\">/*注释5*/</span>              .catch((error: <span class=\"built_in\">any</span>) =&gt; Promise.reject(error || <span class=\"string\">\"Server error\"</span>));</div><div class=\"line\">                          &#125;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>现在我写了一个getHeroes()的方法：<br>解析几点：<br>注释1：http请求肯定需要Url地址，这里需要导入数据库里面的名；api/heroes 其实就是你内存数据库 web api里面<code>return {heroes};</code><br>根据你返回的值，调用相应的api地址；<br>注释2：使用的是http承诺（promise），一定要有返回值，返回的是一个可以解析成英雄列表的Observable对象 ,也就是我们的Hero；也就是需要导入这个<code>import {Hero} from &#39;./hero&#39;;</code><br>hero.ts文件包含：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hero</span></span>&#123;</div><div class=\"line\">    id:number;</div><div class=\"line\">    name:string;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Observable（可观察对象）是一个管理异步数据流的强力方式，后续会学习；<br>注释3：.toPromise会将我们得到的Observable对象转化成promise对象；<br>但是Angular中的observable对象并没有一个topromise操作符，这里就需要借助其他工具，<code>import &#39;rxjs/add/operator/toPromise&#39;;</code><br>更多详细的可以看rxjs库操作符；<br>注释4：在 then 回调中提取出数据，这也是angular中一大特点，默认 JSON 解析,这个由json方法返回的对象只有一个data属性。<br>这个data属性保存了英雄数组，这个数组才是调用者真正想要的。 所以我们取得这个数组，并且把它作为承诺的值进行解析<br>注意：web api 返回的是带有data属性的对象，而你真是的api可以返回其他值的；<br>注释5：错误处理,有异常很正常，我们可以将他们传给错误处理器；现在我们只是将错误记录到控制台，真实案例中，可以将错误进行处理；</p>\n<h2 id=\"4-如何将获得的数据显示在界面；\"><a href=\"#4-如何将获得的数据显示在界面；\" class=\"headerlink\" title=\"4.如何将获得的数据显示在界面；\"></a>4.如何将获得的数据显示在界面；</h2><h3 id=\"4-1-组件中调用Hero-service-ts；\"><a href=\"#4-1-组件中调用Hero-service-ts；\" class=\"headerlink\" title=\"4.1 组件中调用Hero.service.ts；\"></a>4.1 组件中调用Hero.service.ts；</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;HeroService&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./hero.service'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;Hero&#125;  <span class=\"keyword\">from</span> <span class=\"string\">'./hero'</span>;</div><div class=\"line\">@Component(&#123;</div><div class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">'app-root'</span>,</div><div class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">'./app.component.html'</span>,</div><div class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">'./app.component.css'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppComponent</span> </span>&#123;</div><div class=\"line\"> <span class=\"comment\">/*注释1*/</span> hero:Hero[];</div><div class=\"line\"> <span class=\"comment\">/*注释2*/</span> <span class=\"keyword\">constructor</span>(private service:HeroService)&#123;</div><div class=\"line\">             <span class=\"keyword\">this</span>.getHeroes();</div><div class=\"line\">            &#125;</div><div class=\"line\">          getHeroes()&#123;</div><div class=\"line\"><span class=\"comment\">/*注释3*/</span>     <span class=\"keyword\">this</span>.service.getHeroes().then(</div><div class=\"line\">               <span class=\"function\"><span class=\"params\">hero</span>=&gt;</span>&#123;</div><div class=\"line\">                 <span class=\"keyword\">this</span>.hero=hero;</div><div class=\"line\">                  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.hero);</div><div class=\"line\">                    &#125;</div><div class=\"line\"><span class=\"comment\">/*注释4*/</span>     ).catch(<span class=\"function\">(<span class=\"params\">error: any</span>) =&gt;</span> <span class=\"built_in\">Promise</span>.reject(error || <span class=\"string\">'client error'</span>))</div><div class=\"line\">           &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注释1： 用来接收返回的对象；<br>注释2： 对引入的hero.service.ts服务初始化；<br>注释3： 返回的是promise对象，用then方法去解析得到的值；<br>注释4： 预期会犯错，抛出异常；<br>现在可以看看控制台打印的hero对象：<br><img src=\"/images/http-1.png\" alt=\"http\"><br>如何显示在我们的html上呢？<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">\"let a of hero\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;&#123;a.id&#125;&#125; : &#123;&#123;a.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>简单的写了这样一段：这里注意：多对数组或对象形式用*ngFor遍历；<br>运行localhost:4200,这样就可以让数据正常显示啦；<br><img src=\"/images/http-2.png\" alt=\"http\"><br>这里介绍的是采用promise的形式调用http的方法，原理就是：hero.service中，http.get()返回的Observable后面串联了一个toPromise操作符。 该操作符把Observable转换成了Promise，并且我们把那个承诺返回给了调用者；</p>\n<h2 id=\"5-http-promise还能做什么？\"><a href=\"#5-http-promise还能做什么？\" class=\"headerlink\" title=\"5.http promise还能做什么？\"></a>5.http promise还能做什么？</h2><h3 id=\"5-1-尝试通过id获取英雄；\"><a href=\"#5-1-尝试通过id获取英雄；\" class=\"headerlink\" title=\"5.1 尝试通过id获取英雄；\"></a>5.1 尝试通过id获取英雄；</h3><p>hero.service.ts中添加这段代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">getHero(id:<span class=\"built_in\">number</span>):Promise&lt;Hero&gt;&#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> url = <span class=\"string\">`<span class=\"subst\">$&#123;this.heroUrl&#125;</span>/<span class=\"subst\">$&#123;id&#125;</span>`</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http.get(url)</div><div class=\"line\">        .toPromise()</div><div class=\"line\">        .then(response =&gt;</div><div class=\"line\">                response.json().data as Hero,  </div><div class=\"line\">         )</div><div class=\"line\">        .catch((error: <span class=\"built_in\">any</span>) =&gt; Promise.reject(error || <span class=\"string\">'Server error'</span>));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>和获取所有英雄的方法类似，这个的步骤是先获取所有的英雄，并从中过滤出与id匹配的那一个；<br>匹配api/hero/:id 模式，有点像路由；</p>\n<h3 id=\"5-2-组件中如何调用；\"><a href=\"#5-2-组件中如何调用；\" class=\"headerlink\" title=\"5.2 组件中如何调用；\"></a>5.2 组件中如何调用；</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">detailhero:Hero;</div><div class=\"line\">getHero(id:<span class=\"built_in\">number</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.service.getHero(id).then(</div><div class=\"line\">       hero=&gt;&#123;</div><div class=\"line\">         <span class=\"keyword\">this</span>.detailhero=hero;</div><div class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.detailhero);</div><div class=\"line\">        &#125;</div><div class=\"line\">   ).catch((error: <span class=\"built_in\">any</span>) =&gt; Promise.reject(error || <span class=\"string\">'client error'</span>))</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>方法都类似，只是你需要传入想查询的id;<br>constructor中运行此方法，比如我想知道第二个英雄的详情：<code>this.getHero(2);</code><br>看看控制台输出：<br><img src=\"/images/http-3.png\" alt=\"http\"><br>看看html代码：<code><p *ngif=\"detailhero\"></p></code><br>注意：单个对象用*ngIf ；</p>\n<h2 id=\"6-http-promise还有什么请求方式？\"><a href=\"#6-http-promise还有什么请求方式？\" class=\"headerlink\" title=\"6.http promise还有什么请求方式？\"></a>6.http promise还有什么请求方式？</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">request(url: string | Request, options?: RequestOptionsArgs): Observable&lt;Response&gt;;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Performs a request with `get` http method.</div><div class=\"line\">     */</div><div class=\"line\">    get(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Performs a request with `post` http method</div><div class=\"line\">     */</div><div class=\"line\">    post(url: string, <span class=\"attr\">body</span>: any, options?: RequestOptionsArgs): Observable&lt;Response&gt;;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Performs a request with `put` http method.</div><div class=\"line\">     */</div><div class=\"line\">    put(url: string, <span class=\"attr\">body</span>: any, options?: RequestOptionsArgs): Observable&lt;Response&gt;;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Performs a request with `delete` http method.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">delete</span>(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Performs a request with `patch` http method.</div><div class=\"line\">     */</div><div class=\"line\">    patch(url: string, <span class=\"attr\">body</span>: any, options?: RequestOptionsArgs): Observable&lt;Response&gt;;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Performs a request with `head` http method.</div><div class=\"line\">     */</div><div class=\"line\">    head(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Performs a request with `options` http method.</div><div class=\"line\">     */</div><div class=\"line\">    options(url: string, options?: RequestOptionsArgs): Observable&lt;Response&gt;;</div></pre></td></tr></table></figure>\n<h3 id=\"6-1-我们来添加一个英雄；\"><a href=\"#6-1-我们来添加一个英雄；\" class=\"headerlink\" title=\"6.1 我们来添加一个英雄；\"></a>6.1 我们来添加一个英雄；</h3><p>hero.service.ts中加入这一段：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*注释1*/</span> private headers = <span class=\"keyword\">new</span> Headers(&#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span>&#125;);</div><div class=\"line\">      addHero(name:string):<span class=\"built_in\">Promise</span>&lt;Hero&gt;&#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http.post(<span class=\"keyword\">this</span>.heroUrl,<span class=\"built_in\">JSON</span>.stringify(&#123;<span class=\"attr\">name</span>:name&#125;),&#123;<span class=\"attr\">headers</span>:<span class=\"keyword\">this</span>.headers&#125;)</div><div class=\"line\">          .toPromise()</div><div class=\"line\">          .then(</div><div class=\"line\">              <span class=\"function\"><span class=\"params\">res</span>=&gt;</span></div><div class=\"line\">                  res.json().data <span class=\"keyword\">as</span> Hero</div><div class=\"line\">          )</div><div class=\"line\">          .catch(<span class=\"function\">(<span class=\"params\">error: any</span>) =&gt;</span> <span class=\"built_in\">Promise</span>.reject(error || <span class=\"string\">'Server error'</span>));</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p>注释1：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;Http,Headers&#125; from <span class=\"string\">'@angular/http'</span>;</div></pre></td></tr></table></figure>\n<p>需要引入Headers，然后new 一个实例；<br>但是这个参数是可选的；<br>组件中怎么接收：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">addhero:Hero;</div><div class=\"line\">  addHero(name:string)&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.service.addHero(name).then(</div><div class=\"line\">        <span class=\"function\"><span class=\"params\">hero</span>=&gt;</span>&#123;</div><div class=\"line\">          <span class=\"keyword\">this</span>.addhero=hero;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.addhero);</div><div class=\"line\">          <span class=\"keyword\">this</span>.hero.push(<span class=\"keyword\">this</span>.addhero);  <span class=\"comment\">/*将添加的数据Push进hero数组*/</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    ).catch(<span class=\"function\">(<span class=\"params\">error: any</span>) =&gt;</span> <span class=\"built_in\">Promise</span>.reject(error || <span class=\"string\">'client error'</span>))</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>一样的代码，就不过多解释；<br>我们的英雄在哪里添加呢？<br>肯定是要有一个input输入框的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    add:<span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">heroName</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"addHero(heroName.value);heroName.value=''\"</span>&gt;</span>add<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>添加之后，可以看到控制台会有输出：<br><img src=\"/images/http-4.png\" alt=\"http\"><br>但是界面显示的还是这些：<br><img src=\"/images/http-5.png\" alt=\"http\"><br>Angular会自动检测数据的变换，当有数据变换时，会实时更新<br>还有一些其他方法，自己去尝试下；<br>hero.service.ts:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; Injectable &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; Http, Headers,Response&#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/http'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'rxjs/add/operator/toPromise'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; Hero &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./hero'</span>;</div><div class=\"line\">@Injectable()</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeroService</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(private http: Http) &#123; &#125;</div><div class=\"line\">    private heroUrl = <span class=\"string\">'api/heroes'</span>;</div><div class=\"line\">    getHeroes(): <span class=\"built_in\">Promise</span>&lt;Hero[]&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http.get(<span class=\"keyword\">this</span>.heroUrl)</div><div class=\"line\">            .toPromise()</div><div class=\"line\">            .then( <span class=\"keyword\">this</span>.extractData )  <span class=\"comment\">/*注释1*/</span></div><div class=\"line\">            .catch(<span class=\"function\">(<span class=\"params\">error: any</span>) =&gt;</span> <span class=\"built_in\">Promise</span>.reject(error || <span class=\"string\">'Server error'</span>));<span class=\"comment\">/*注释2*/</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    getHero(id: number): <span class=\"built_in\">Promise</span>&lt;Hero&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> url = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.heroUrl&#125;</span>/<span class=\"subst\">$&#123;id&#125;</span>`</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http.get(url)</div><div class=\"line\">            .toPromise()</div><div class=\"line\">            .then(<span class=\"keyword\">this</span>.extractData)</div><div class=\"line\">            .catch(<span class=\"keyword\">this</span>.handleError);</div><div class=\"line\">    &#125;</div><div class=\"line\">    private headers = <span class=\"keyword\">new</span> Headers(&#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span> &#125;);</div><div class=\"line\">    addHero(name: string): <span class=\"built_in\">Promise</span>&lt;Hero&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http.post(<span class=\"keyword\">this</span>.heroUrl, <span class=\"built_in\">JSON</span>.stringify(&#123; <span class=\"attr\">name</span>: name &#125;), &#123; <span class=\"attr\">headers</span>: <span class=\"keyword\">this</span>.headers &#125;)</div><div class=\"line\">            .toPromise()</div><div class=\"line\">            .then(<span class=\"keyword\">this</span>.extractData)</div><div class=\"line\">            .catch(<span class=\"keyword\">this</span>.handleError);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">    *</div><div class=\"line\">    * @param res 接收数据的方法</div><div class=\"line\">    */</div><div class=\"line\">    private extractData(res: Response)  &#123;  <span class=\"comment\">/*注释2*/</span></div><div class=\"line\">        <span class=\"keyword\">let</span> body = res.json();</div><div class=\"line\">        <span class=\"keyword\">return</span> body.data|| &#123;&#125;; <span class=\"comment\">/*注释3*/</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * </div><div class=\"line\">     * @param error 处理错误的方法</div><div class=\"line\">     */</div><div class=\"line\">    private handleError(error: Response | any) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error || <span class=\"string\">'Server error'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注释1：将then()和catch()里面的部分提取出来，每次使用只需要调用方法即可；<br>注释2：接收的Response记得将Response在Http对象中引入；<br>注释3：这里接收的data其实是一个any型;</p>\n<h2 id=\"7-Observable对象\"><a href=\"#7-Observable对象\" class=\"headerlink\" title=\"7. Observable对象\"></a>7. Observable对象</h2><p>Http服务中的每个方法都返回一个 HTTP Response对象的Observable实例；<br>Observable 就是一个拥有以下特性的函数：<br>    它接收一个 observer 对象作为参数，该对象中包含 next、error 和 complete 方法<br>    它返回一个函数，用于在销毁 Observable 时，执行清理操作<br>在 RxJS 中，返回的是 Subcription 对象，该对象中包含一个 unsubscribe 方法。<br>一个 Observable 对象设置观察者 (observer)，并将它与生产者关联起来。该生产者可能是 DOM 元素产生的 click 或 input 事件，也可能是更复杂的事件，如 HTTP。<br>当 Observable 对象产生新值的时候，我们可以通过调用 next() 方法来通知对应的观察者。若出现异常，则会调用观察者的 error() 方法。当我们订阅 Observable 对象后，只要有新的值，都会通知对应的观察者。但在以下两种情况下，新的值不会再通知对应的观察者：已调用 observer 对象的 complete() 方法消费者对数据不再感兴趣，执行取消订阅操作<br>此外在执行最终的 subscribe() 订阅操作前，我们传递的值可以经过一系列的链式处理操作。执行对应操作的东西叫操作符，每个操作符执行完后会返回一个新的 Observable 对象，然后继续我们的处理流程。<br>那么我们可以直接返回Observable给组件吗？<br>我们可以看看，之前getHero()那一段如果直接改成返回Observable对象会如何；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">getHeroes():Observable&lt;Hero[]&gt;&#123;  <span class=\"comment\">/*注释1*/</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http.get(<span class=\"keyword\">this</span>.heroUrl)</div><div class=\"line\">        .map(<span class=\"keyword\">this</span>.extractData); </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>注释1：不用调用toPromise()方法，自然也不用then()去取数据，而是直接返回Observable对象之后<br>调用RXJS中的map操作符来从返回的数据中提取数据；<br>所以你要引入：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; Observable &#125;  <span class=\"keyword\">from</span> <span class=\"string\">'rxjs/Observable'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'rxjs/add/operator/map'</span>;</div></pre></td></tr></table></figure></p>\n<p>操作符之后会讲到，注意和之前的promise方法对比；<br>组件中怎么接收数据Observable对象呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">getHeroes()&#123;</div><div class=\"line\">   <span class=\"keyword\">this</span>.service.getHeroes().subscribe(    <span class=\"comment\">/*注释1*/</span></div><div class=\"line\">     hero=&gt;&#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.hero=hero;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.hero);</div><div class=\"line\">     &#125;</div><div class=\"line\">   )</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>这样显示的效果也是一样的；<br>注释1：调用 subscribe() 方法，来获取最终的值，采取订阅的方式，而不是用then();</p>\n<h2 id=\"8-Observabel和Promise-有什么不同\"><a href=\"#8-Observabel和Promise-有什么不同\" class=\"headerlink\" title=\"8. Observabel和Promise 有什么不同\"></a>8. Observabel和Promise 有什么不同</h2><h3 id=\"8-1-两个都可以用于web-API-http的调用，但Observable是可以中途取消的，而Promise一旦触发就不能被取消；\"><a href=\"#8-1-两个都可以用于web-API-http的调用，但Observable是可以中途取消的，而Promise一旦触发就不能被取消；\" class=\"headerlink\" title=\"8.1 两个都可以用于web API http的调用，但Observable是可以中途取消的，而Promise一旦触发就不能被取消；\"></a>8.1 两个都可以用于web API http的调用，但Observable是可以中途取消的，而Promise一旦触发就不能被取消；</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.service.getHero().unsubscribe();</div><div class=\"line\">     &#125;, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"8-2-因为Promise只能发起一次请求，只要接收到数据，就会算完成，所以Promise只能发射一个值就算结束，Observable可以连续发送好几个值，在服务器对第一个请求作出回应之前，再开始另一个不同的请求；\"><a href=\"#8-2-因为Promise只能发起一次请求，只要接收到数据，就会算完成，所以Promise只能发射一个值就算结束，Observable可以连续发送好几个值，在服务器对第一个请求作出回应之前，再开始另一个不同的请求；\" class=\"headerlink\" title=\"8.2 因为Promise只能发起一次请求，只要接收到数据，就会算完成，所以Promise只能发射一个值就算结束，Observable可以连续发送好几个值，在服务器对第一个请求作出回应之前，再开始另一个不同的请求；\"></a>8.2 因为Promise只能发起一次请求，只要接收到数据，就会算完成，所以Promise只能发射一个值就算结束，Observable可以连续发送好几个值，在服务器对第一个请求作出回应之前，再开始另一个不同的请求；</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.heroes = <span class=\"keyword\">this</span>.searchTerms</div><div class=\"line\">    .debounceTime(<span class=\"number\">300</span>)        </div><div class=\"line\">    .distinctUntilChanged()  </div><div class=\"line\">    .switchMap(<span class=\"function\"><span class=\"params\">term</span> =&gt;</span> term   </div><div class=\"line\">      ? <span class=\"keyword\">this</span>.service.search(term)</div><div class=\"line\">      : Observable.of&lt;Hero[]&gt;([]))</div><div class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error);</div><div class=\"line\">      <span class=\"keyword\">return</span> Observable.of&lt;Hero[]&gt;([]);</div><div class=\"line\">    &#125;);</div><div class=\"line\"><span class=\"keyword\">this</span>.heroes.subscribe(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"built_in\">console</span>.log(value));</div></pre></td></tr></table></figure>\n<p>这个后面代码操作符这块有详解；</p>\n<h3 id=\"8-3-Observable提供了很多的工具函数，最最最常用的filter和map；详细看看这两个map和filter；\"><a href=\"#8-3-Observable提供了很多的工具函数，最最最常用的filter和map；详细看看这两个map和filter；\" class=\"headerlink\" title=\"8.3 Observable提供了很多的工具函数，最最最常用的filter和map；详细看看这两个map和filter；\"></a>8.3 Observable提供了很多的工具函数，最最最常用的filter和map；详细看看这两个map和filter；</h3><p> map() 操作符返回一个新的 Observable 对象<br> filter() 操作符执行过滤操作，然后又返回一个新的 Observable 对象<br>最后我们通过调用 subscribe() 方法，来获取最终的值<br>Filter:过滤器<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">getHeroes()&#123;</div><div class=\"line\">    this.service.getHeroes().filter(hero =&gt; hero.length &gt;= 2)</div><div class=\"line\">    .subscribe(</div><div class=\"line\">        hero=&gt;&#123;</div><div class=\"line\">           this.hero=hero;</div><div class=\"line\">        &#125;</div><div class=\"line\">    )</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>Map的用法上面有介绍；<br>但是，使用承诺的方式能让调用方法更容易写，并且承诺已经在 JavaScript 程序员中被广泛接受了。<br>再来看看Observable操作符：<br>根据名字搜索用户：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(term: string): Observable<span class=\"tag\">&lt;<span class=\"name\">Hero[]</span>&gt;</span> &#123;</div><div class=\"line\">        return this.http</div><div class=\"line\">               .get(`api/heroes/?name=$&#123;term&#125;`)</div><div class=\"line\">               .map(response =&gt; response.json().data as Hero[]);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p> 看看组件代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> import &#123; Observable &#125; from 'rxjs/Observable';  /*注释1*/</div><div class=\"line\">import &#123; Subject &#125;  from 'rxjs/Subject';  /*注释2*/</div><div class=\"line\">// Observable class extensions</div><div class=\"line\">import 'rxjs/add/observable/of';  /*注释3*/</div><div class=\"line\">// Observable operators</div><div class=\"line\">import 'rxjs/add/operator/catch';  /*注释4*/</div><div class=\"line\">import 'rxjs/add/operator/debounceTime';  /*注释5*/</div><div class=\"line\">import 'rxjs/add/operator/distinctUntilChanged';  /*注释6*/</div><div class=\"line\">import 'rxjs/add/operator/switchMap'; /*注释6*/</div></pre></td></tr></table></figure></p>\n<p>引入这些操作符：<br>注释1：引入RXJS的可观察对象；<br>注释2：Suject是一个可观察事件流中的生产者，通过调用Next()对象，可以将新观察的对象放入可观察流中；<br>注释3：是Rxjs为Observable对象提供的扩展，<br>注释4：异常操作符，拦截失败的可观察对象。<br>注释5：相当于settimeout(),延迟；<br>注释6：distinctUntilChanged确保只在过滤条件变化时才发送请求， 这样就不会重复请求同一个搜索词了；<br>注释7：switchMap()会为每个从debounce和distinctUntilChanged中通过的搜索词调用搜索服务。 它会取消并丢弃以前的搜索可观察对象，只保留最近的；使用这个每触发一次事件都会引起一次Http()的调用，即使你使用延迟，但同一时间还是会有多个Http请求，并且返回的顺序不一定是请求发起的顺序；<br>看看Http()方法调用：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"> heroes: Observable&lt;Hero[]&gt;;</div><div class=\"line\">  <span class=\"keyword\">private</span> searchTerms=<span class=\"keyword\">new</span> Subject&lt;<span class=\"built_in\">string</span>&gt;();   <span class=\"comment\">// searchTerms生成一个产生字符串的Observable</span></div><div class=\"line\">  <span class=\"comment\">/*每当调用search()时都会调用next()来把新的字符串放进该主题的可观察流中*/</span></div><div class=\"line\">  search(term:<span class=\"built_in\">string</span>):<span class=\"built_in\">void</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.searchTerms.next(term);</div><div class=\"line\">  &#125;</div><div class=\"line\">   ngOnInit(): <span class=\"built_in\">void</span> &#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.heroes = <span class=\"keyword\">this</span>.searchTerms</div><div class=\"line\">    .debounceTime(<span class=\"number\">300</span>)        </div><div class=\"line\">    .distinctUntilChanged()  </div><div class=\"line\">    .switchMap(term =&gt; term   </div><div class=\"line\">      ? <span class=\"keyword\">this</span>.service.search(term)</div><div class=\"line\">      : Observable.of&lt;Hero[]&gt;([]))</div><div class=\"line\">    .catch(error =&gt; &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error);</div><div class=\"line\">      <span class=\"keyword\">return</span> Observable.of&lt;Hero[]&gt;([]);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>看看代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  search :<span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">searchBox</span> (<span class=\"attr\">keyup</span>)=<span class=\"string\">\"search(searchBox.value)\"</span>/&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">div</span>  *<span class=\"attr\">ngFor</span>=<span class=\"string\">\"let b of heroes | async\"</span>&gt;</span></div><div class=\"line\">        &#123;&#123;b.name&#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>为什么使用一个async管道呢？因为得到的是Observable对象，不是数组，*ngFor不能遍历可观察对象；<br>效果：<br><img src=\"/images/http-6.png\" alt=\"http\"><br>看完这个，大概知道：<br>Observable（可观察对象）是基于推送（Push）运行时执行（lazy）的多值集合；<br>关于操作符，我有话要说：<br>大部分RxJS操作符都不包括在Angular的Observable基本实现中，基本实现只包括Angular本身所需的功能，也就是，你需要的大多操作符都需要从rxjs中引入；</p>\n<h2 id=\"9-上述的例子，其实说的都是关于web-api-内存服务器的，占用内存的东西，速率都有点慢，如果你要从本地获取文件记住不要用这个；\"><a href=\"#9-上述的例子，其实说的都是关于web-api-内存服务器的，占用内存的东西，速率都有点慢，如果你要从本地获取文件记住不要用这个；\" class=\"headerlink\" title=\"9.上述的例子，其实说的都是关于web api,内存服务器的，占用内存的东西，速率都有点慢，如果你要从本地获取文件记住不要用这个；\"></a>9.上述的例子，其实说的都是关于web api,内存服务器的，占用内存的东西，速率都有点慢，如果你要从本地获取文件记住不要用这个；</h2><p>可以换用json文件获取：<br> 创建一个heroes.json，记得放在assets文件下：<br>{<br>  “data”: [<br>    { “id”: 1, “name”: “Windstorm” },<br>    { “id”: 2, “name”: “Bombasto” },<br>    { “id”: 3, “name”: “Magneta” },<br>    { “id”: 4, “name”: “Tornado” }<br>  ]<br>}<br>我们app.module.ts里面的：<br>   <code>InMemoryWebApiModule.forRoot(InMemoryDataService),</code><br>不用引入，引入之后会默认使用web api；<br>然后hero.service.ts中这样<br>private heroesUrl = ‘assets/heroes.json’;<br>其他的都是一样的；<br>这种方式对于请求静态的本地数据是比较有用的；如果是请求真是的远程服务器地址，url换成远程地址就可以；</p>\n","comments":true,"categories":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/categories/Angular-2/"}],"tags":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/tags/Angular-2/"},{"name":"http","slug":"http","permalink":"http://www.sulishibaobei.com/tags/http/"}]},{"title":"webpack初略学习","date":"2017-09-07T01:11:53.000Z","path":"webpack/wp-120170907/","text":"熟话说浓缩就是精华，哈哈，所以就这么简单粗暴的介绍下吧，写下的都是精华。 已经不是第一次听说webpack，但是我的起步有点晚，现在才看。开门见山~~ 1. 什么是webpack？webpack是当下最热门的前端资源模块化管理和打包工具（就是一个打包器），可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源，还可以将需要加载的模块进行代码分离，等到实际需要的时候再进行异步加载。通过loader的转换，任何资源都可以视作模块，如COMMONJS模块 ,AMD模块，JS CSS ,JSON 等 ，它会根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 2.为什么要有webpack等打包器？1.平常的模块加载方式都是在&lt;script&gt;标签里引入，这种情况是在全局作用模式window下的，这样做的弊端就是只能按&lt;script&gt;的书写顺序进行加载，而且全局作用域下容易产生冲突，引入数量比较多的文件情况下难以管理。2.而且，如果单独请求每个模块会造成请求次数过多，导致应用启动缓慢，但是，将所有文件压缩成一个文件，一次请求加载所有模块会导致流量的浪费，初始化过程缓慢。3.所以编译的时候对所有的代码进行静态分析，分析出各个模块的类型及依赖关系，然后将他们提交给适配的加载器处理，所以webpack就应运而生。 3.COMMONJS模块，AMD模块，CMD模块，UMD模块几种常用模块？Commonjs：允许模块通过require方法同步加载所需依赖的其他模式，然后通过exports或module.exports来导出需要暴露的接口。 1234eg： require(\"module\"); require(\"./script.js\"); export.doStuff= function ()&#123;&#125;; module.exports=someValue; 优点：各个模块可以进行重用，npm中已经有许多可供使用的包。缺点：只能是同步加载的，同步就意味着阻塞加载，所以不适合在浏览器环境中，因为浏览器的资源是同步加载的，不能非阻塞的并行加载多个模块。应用实例：nodejsAmd模块：它是在声明模块的时候就指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行依赖前置。 123eg: define(\"module\", [\"dep1\", \"dep2\"], function (d1, d2)&#123; return someExportedValue; &#125;); require([ \"module\", \"../file\"], function (module, file) &#123; /* ... */ &#125;); 优点：适合异步加载模块，在浏览器环境中，并且可以并行运行多个模块。和commonjs相反。缺点：提前加好所有依赖，代码要复杂很多。应用实例：requirejs，curlCmd模块：和AMD类似，并和Commonjs也有很大的兼容性。 1234eg: define( function (require, exports, module)&#123; var $ = require('jquery'); var Spinning = require('./spinning'); exports.doSomething = ... module.exports = ... &#125;) 优点：容易在nodejs中运行你的代码缺点：依赖spm打包，模块的加载逻辑比较重、应用实例：Sea.jsUmd模块：主要解决模块定义的跨平台问题 123eg: import \"jquery\"; export function doStuff() &#123;&#125; module \"localModule\" &#123;&#125; 优点：容易进行静态分析，面向未来的ES标准；缺点：原生浏览器不支持。 4.如何使用webpack？假装你的电脑里面已经安装了Node.js, 然后输入：npm install webpack -g ,可以通过webpack -h来查看安装信息。(1)假装创建一个项目test,进入项目路径，创建一个index.html页面，代码如下图：(2)然后再创建一个名为：bundle.js的文件，在上图的index.html中引入它。此文件里面什么代码都不需要写。(3)在创建一个名为entry.js的文件，不需要在index.html页面引入哟，此文件里面用来写内容。document.write( “hello world”); (4)然后将entry.js打包进bundle.js文件中，webpack会分析入口文件，解析包含依赖关系的各个文件，然后打包到bundle.js中 webpack entry.js bundle.js webpack打包的原理就是给每一个模块都分配一个唯一的id并通过这个id索引和访问模块，启动时，会先执行entry.js里面的代码，其他模块会在运行require的时候执行。(5)此时打开bundle.js文件查看，你就可以发现里面已经 有代码了:(6)运行inde.html页面，在浏览器中就可以看到Hello world.但是webpack本身是只能处理javascript模块的，如果碰到css,json等其他模块文件，就需要使用loader转换。 loader就是一个装换器，一个可以输入任何资源但是最终都会帮你转成js模块的工具。总的来说loader有以下几点：1.管道方式链式调用（允许多个文件转换，最后必定输出js文件）。2.loader可以同步或异步执行3.倘若在nodejs环境下，可以做任何事情4.loader加载时可以接受传参。5.可以通过文件扩展名来绑定不同类型的文件。6.loader是通过Npm发布和安装。7.通过定义package.json来指定，同样也可以导出一个loader来使用，命名规则是：xxx-loader。一般是什么功能就命名什么。 下面就直接来试试：(1)在项目里面在新建一个名为：style.css的文件：输入body{ background:green}(2)修改entry.js;加入这一句require(“!style-loader!css-loader!./style.css”)(3)安装Loader.npm install css-loader style-loader先用css-loader读取它，再用style-loader将它插入页面中。(4)重新打包:webpack entry.js bundle.js(5)刷新index.html页面可以看到效果。如果有错误，cmd打包时就会显示，index.html运行时，fireug也会显示的。loader转换器还可以通过配置文件来执行哟(1)通过往package.json里面新增配置项来完成。deDependencies(2)在新配置个webpack.config.js文件 12345678910111213141516171819var webpack = require('webpack')module.exports = &#123; resolve: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;, resolveLoader: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;, entry: './entry.js', output: &#123; path: __dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style!css'&#125; ] &#125;, plugins:[ new webpack.BannerPlugin('This file is created by yu') ]&#125; (3)直接运行webpack ，刷新index.html 就可以查看效果","content":"<p>熟话说浓缩就是精华，哈哈，所以就这么简单粗暴的介绍下吧，写下的都是精华。 已经不是第一次听说webpack，但是我的起步有点晚，现在才看。开门见山~~ </p>\n<h2 id=\"1-什么是webpack？\"><a href=\"#1-什么是webpack？\" class=\"headerlink\" title=\"1. 什么是webpack？\"></a>1. 什么是webpack？</h2><p>webpack是当下最热门的前端资源模块化管理和打包工具（就是一个打包器），可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源，还可以将需要加载的模块进行代码分离，等到实际需要的时候再进行异步加载。通过loader的转换，任何资源都可以视作模块，如COMMONJS模块 ,AMD模块，JS CSS ,JSON 等 ，它会根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p>\n<a id=\"more\"></a>\n<h2 id=\"2-为什么要有webpack等打包器？\"><a href=\"#2-为什么要有webpack等打包器？\" class=\"headerlink\" title=\"2.为什么要有webpack等打包器？\"></a>2.为什么要有webpack等打包器？</h2><p>1.平常的模块加载方式都是在&lt;script&gt;标签里引入，这种情况是在全局作用模式window下的，这样做的弊端就是只能按&lt;script&gt;的书写顺序进行加载，而且全局作用域下容易产生冲突，引入数量比较多的文件情况下难以管理。<br>2.而且，如果单独请求每个模块会造成请求次数过多，导致应用启动缓慢，但是，将所有文件压缩成一个文件，一次请求加载所有模块会导致流量的浪费，初始化过程缓慢。<br>3.所以编译的时候对所有的代码进行静态分析，分析出各个模块的类型及依赖关系，然后将他们提交给适配的加载器处理，所以webpack就应运而生。 </p>\n<h2 id=\"3-COMMONJS模块，AMD模块，CMD模块，UMD模块几种常用模块？\"><a href=\"#3-COMMONJS模块，AMD模块，CMD模块，UMD模块几种常用模块？\" class=\"headerlink\" title=\"3.COMMONJS模块，AMD模块，CMD模块，UMD模块几种常用模块？\"></a>3.COMMONJS模块，AMD模块，CMD模块，UMD模块几种常用模块？</h2><p>Commonjs：允许模块通过require方法同步加载所需依赖的其他模式，然后通过exports或module.exports来导出需要暴露的接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">eg： <span class=\"built_in\">require</span>(<span class=\"string\">\"module\"</span>);</div><div class=\"line\">     <span class=\"built_in\">require</span>(<span class=\"string\">\"./script.js\"</span>);</div><div class=\"line\">      <span class=\"keyword\">export</span>.doStuff= <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">      <span class=\"built_in\">module</span>.exports=someValue;</div></pre></td></tr></table></figure>\n<p>优点：各个模块可以进行重用，npm中已经有许多可供使用的包。<br>缺点：只能是同步加载的，同步就意味着阻塞加载，所以不适合在浏览器环境中，因为浏览器的资源是同步加载的，不能非阻塞的并行加载多个模块。<br>应用实例：nodejs<br>Amd模块：它是在声明模块的时候就指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行依赖前置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">eg:  define(<span class=\"string\">\"module\"</span>, [<span class=\"string\">\"dep1\"</span>, <span class=\"string\">\"dep2\"</span>],  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d1, d2</span>)</span>&#123;  <span class=\"keyword\">return</span>  someExportedValue; &#125;);</div><div class=\"line\">     <span class=\"built_in\">require</span>([ <span class=\"string\">\"module\"</span>, <span class=\"string\">\"../file\"</span>],</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">module, file</span>) </span>&#123;  <span class=\"comment\">/*   ...   */</span>  &#125;);</div></pre></td></tr></table></figure>\n<p>优点：适合异步加载模块，在浏览器环境中，并且可以并行运行多个模块。和commonjs相反。<br>缺点：提前加好所有依赖，代码要复杂很多。<br>应用实例：requirejs，curl<br>Cmd模块：和AMD类似，并和Commonjs也有很大的兼容性。  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">eg: define( <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require, exports, module</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span>  $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery'</span>);</div><div class=\"line\">   <span class=\"keyword\">var</span>  Spinning = <span class=\"built_in\">require</span>(<span class=\"string\">'./spinning'</span>);</div><div class=\"line\"> exports.doSomething  = ... module.exports = ... &#125;)</div></pre></td></tr></table></figure>\n<p>优点：容易在nodejs中运行你的代码<br>缺点：依赖spm打包，模块的加载逻辑比较重、<br>应用实例：Sea.js<br>Umd模块：主要解决模块定义的跨平台问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">eg:  <span class=\"keyword\">import</span> <span class=\"string\">\"jquery\"</span>;</div><div class=\"line\">  <span class=\"keyword\">export</span>   <span class=\"function\"><span class=\"keyword\">function</span>  <span class=\"title\">doStuff</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">  <span class=\"built_in\">module</span>  <span class=\"string\">\"localModule\"</span> &#123;&#125;</div></pre></td></tr></table></figure>\n<p>优点：容易进行静态分析，面向未来的ES标准；<br>缺点：原生浏览器不支持。                  </p>\n<h2 id=\"4-如何使用webpack？\"><a href=\"#4-如何使用webpack？\" class=\"headerlink\" title=\"4.如何使用webpack？\"></a>4.如何使用webpack？</h2><p>假装你的电脑里面已经安装了Node.js, 然后输入：npm install webpack -g  ,可以通过webpack -h来查看安装信息。<br>(1)假装创建一个项目test,进入项目路径，创建一个index.html页面，代码如下图：<br><img src=\"/images/webpack-1.png\" alt=\"webpack\"><br>(2)然后再创建一个名为：bundle.js的文件，在上图的index.html中引入它。此文件里面什么代码都不需要写。<br>(3)在创建一个名为entry.js的文件，不需要在index.html页面引入哟，此文件里面用来写内容。<br><b>document.write( “hello world”); </b><br>(4)然后将entry.js打包进bundle.js文件中，webpack会分析入口文件，解析包含依赖关系的各个文件，然后打包到bundle.js中<br> <b>webpack entry.js bundle.js </b><br>webpack打包的原理就是给每一个模块都分配一个唯一的id并通过这个id索引和访问模块，启动时，会先执行entry.js里面的代码，其他模块会在运行require的时候执行。<br>(5)此时打开bundle.js文件查看，你就可以发现里面已经 有代码了:<br><img src=\"/images/webpack-2.png\" alt=\"webpack\"><br>(6)运行inde.html页面，在浏览器中就可以看到Hello world.<br>但是webpack本身是只能处理javascript模块的，如果碰到css,json等其他模块文件，就需要使用loader转换。 loader就是一个装换器，一个可以输入任何资源但是最终都会帮你转成js模块的工具。<br><strong>总的来说loader有以下几点：</strong><br>1.管道方式链式调用（允许多个文件转换，最后必定输出js文件）。<br>2.loader可以同步或异步执行<br>3.倘若在nodejs环境下，可以做任何事情<br>4.loader加载时可以接受传参。<br>5.可以通过文件扩展名来绑定不同类型的文件。<br>6.loader是通过Npm发布和安装。7.通过定义package.json来指定，同样也可以导出一个loader来使用，命名规则是：xxx-loader。一般是什么功能就命名什么。 </p>\n<p><strong>下面就直接来试试：</strong><br>(1)在项目里面在新建一个名为：style.css的文件：输入<b>body{ background:green}</b><br>(2)修改entry.js;加入这一句<b>require(“!style-loader!css-loader!./style.css”)</b><br>(3)安装Loader.<b>npm install css-loader style-loader</b>先用css-loader读取它，再用style-loader将它插入页面中。<br>(4)重新打包:<b>webpack entry.js bundle.js</b><br>(5)刷新index.html页面可以看到效果。<br>如果有错误，cmd打包时就会显示，index.html运行时，fireug也会显示的。<br>loader转换器还可以通过配置文件来执行哟<br>(1)通过往package.json里面新增配置项来完成。deDependencies<br><img src=\"/images/webpack-3.png\" alt=\"webpack\"><br>(2)在新配置个webpack.config.js文件</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"><span class=\"built_in\">module</span>.exports  = &#123;</div><div class=\"line\">    <span class=\"attr\">resolve</span>: &#123; <span class=\"attr\">fallback</span>: path.join(__dirname,  <span class=\"string\">\"node_modules\"</span>) &#125;,</div><div class=\"line\">    <span class=\"attr\">resolveLoader</span>: &#123; <span class=\"attr\">fallback</span>: path.join(__dirname,  <span class=\"string\">\"node_modules\"</span>) &#125;,</div><div class=\"line\">    <span class=\"attr\">entry</span>:  <span class=\"string\">'./entry.js'</span>,</div><div class=\"line\">    <span class=\"attr\">output</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">path</span>: __dirname,</div><div class=\"line\">        <span class=\"attr\">filename</span>:  <span class=\"string\">'bundle.js'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">module</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">loaders</span>: [</div><div class=\"line\">            &#123;<span class=\"attr\">test</span>:  <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'style!css'</span>&#125;</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">plugins</span>:[</div><div class=\"line\">          <span class=\"keyword\">new</span>  webpack.BannerPlugin(<span class=\"string\">'This file is created by yu'</span>)</div><div class=\"line\">    ]</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>(3)直接运行webpack ，刷新index.html 就可以查看效果 </p>\n","comments":true,"categories":[{"name":"前端那些打包工具","slug":"前端那些打包工具","permalink":"http://www.sulishibaobei.com/categories/前端那些打包工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://www.sulishibaobei.com/tags/webpack/"},{"name":"CMD,COMMONJS","slug":"CMD-COMMONJS","permalink":"http://www.sulishibaobei.com/tags/CMD-COMMONJS/"},{"name":"模块","slug":"模块","permalink":"http://www.sulishibaobei.com/tags/模块/"}]},{"title":"nodejs+websocket实时聊天系统","date":"2017-09-07T01:08:53.000Z","path":"wb/wb-120170907/","text":"介绍下websocket： webSocket协议本质上是一个基于tcp的协议; 建立一个websocket连接，大体的过程： 1.客户端浏览器首先向服务器发起一个http请求，这个请求和平常的请求有什么不同呢？ 多了一点附加头信息：”upgrade:web Socket” 表明我这申请的是一个websocket的http请求； 2.服务器收到请求后，解析这些附加的头信息，然后产生应答信息返回给客户端，这样，连接就建立了； 3.双方就可以通过这个连接通道自由的信息传递，这个连接会一直存在，直到一方自动关闭连接； 客户端到服务端：12345678GET /demo HTTP/1.1Host: example.comConnection: UpgradeSec-WebSocket-Key2: 12998 5 Y3 1 .P00Upgrade: WebSocketSec-WebSocket-Key1: 4@1 46546xW%0l 1 5Origin: http://example.com[8-byte security key] 服务端到客户端：123456HTTP/1.1 101 WebSocket Protocol HandshakeUpgrade: WebSocketConnection: UpgradeWebSocket-Origin: http://example.comWebSocket-Location: ws://example.com/demo[16-byte hash response] 从客户端到服务端请求的信息里面包含：‘Sec-webSocket-key1”,”Sec-WebSocket-key2”和“[8-byte security key]”这样的信息；这是客户端浏览器需要向服务端提供的握手信息，服务端解析这些头信息，并且在握手的过程中依据这些信息生成一个16位的安全密钥并返回给客户端，以表明服务器端获取了客户端的请求；大致步骤： 逐个字符读取 Sec-WebSocket-Key1 头信息中的值，将数值型字符连接到一起放到一个临时字符串里，同时统计所有空格的数量； 将在第 1 步里生成的数字字符串转换成一个整型数字，然后除以第 1 步里统计出来的空格数量，将得到的浮点数转换成整数型； 将第 2 步里生成的整型值转换为符合网络传输的网络字节数组； 对 Sec-WebSocket-Key2 头信息同样进行第 1 到第 3 步的操作，得到另外一个网络字节数组； 将 [8-byte security key] 和在第 3，第 4 步里生成的网络字节数组合并成一个 16 字节的数组； 对第 5 步生成的字节数组使用 MD5 算法生成一个哈希值，这个哈希值就作为安全密钥返回给客户端，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接 123456789101112131415161718var wsServer = 'ws://localhost:8888/Demo'; //连接地址var websocket = new WebSocket(wsServer); //建立连接websocket.onopen = function (evt) &#123; onOpen(evt) &#125;; //4个事件websocket.onclose = function (evt) &#123; onClose(evt) &#125;; websocket.onmessage = function (evt) &#123; onMessage(evt) &#125;; websocket.onerror = function (evt) &#123; onError(evt) &#125;; function onOpen(evt) &#123; console.log(\"Connected to WebSocket server.\"); &#125; function onClose(evt) &#123; console.log(\"Disconnected\"); &#125; function onMessage(evt) &#123; console.log('Retrieved data from server: ' + evt.data); &#125; function onError(evt) &#123; console.log('Error occured: ' + evt.data); &#125; 浏览器的支持情况： 浏览器 支持情况 Chrome Supported in version 4+ Firefox Supported in version 4+ Internet Explorer Supported in version 10+ Opera Supported in version 10+ Safari Supported in version 5+ 正文来了：基于websocket制作的简单聊天系统；简单的界面，大致效果就是这样的： 实现逻辑代码：1234567891011121314151617181920212223242526var ws = new WebSocket('ws://127.0.0.1:8082'); ws.onopen = function (e) &#123; console.log(\"连接服务器成功\"); &#125; ws.onmessage = function (e) &#123; value1.removeAttribute(\"readOnly\"); var time = new Date(); mess.innerHTML += time.toUTCString() + \":\" + e.data + \"&amp;lt;br&amp;gt;\"; document.getElementById(\"send\").onclick = function (e) &#123; ws.send(input.value + \"说:\" + value1.value); value1.value = \" \"; &#125; document.onkeydown = function (e) &#123; e = e || window.event; if (e.keyCode == 13) &#123; document.getElementById(\"send\").onclick(); return false; &#125; &#125; &#125; ws.onclose = function (e) &#123; console.log(\"服务器关闭\"); &#125; ws.onerror = function () &#123; console.log(\"连接出错\"); &#125; 连接地址：ws://127.0.0.1:8082&nbsp; 那是哪里来的呢？（注意http请求则是写成http://xxx,https请求则是https://xxx；ws当然是ws://xxx);wbsocket只是客服端，地址当然是从我们的服务端给的呀；服务端的搭建采用了一个这样的库： nodejs-websocket npm isntall -g nodejs-websocket 在js页面引入它 1234567891011121314151617 var ws = require(\"nodejs-websocket\" ); ``` 3. 创建一个服务 ```javascript var server = ws.createServer(function (conn) &#123; conn.on('text', function (str) &#123; &#125;) conn.on(\"close\", function (code, reason) &#123; console.log(\"关闭连接\"); &#125;) conn.on(\"error\", function (code, reason) &#123; console.log(\"异常关闭\"); &#125;);&#125;).listen(8082);console.log(\"websocket连接完毕\") websocket连接算是建立啦！下面展示下具体代码：client.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"bootstrap-3.3.7-dist/css/bootstrap.min.css\" /&gt; &lt;script src=\"jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;style&gt; .kuang &#123; width: 600px; min-height: 50px; max-height: 296px; border: 1px solid; float: left; display: block; position: relative; overflow-y: scroll; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"jumbotron bg-dark\"&gt; &lt;h1 class=\"jumbotron-heading\"&gt;WebSocket chat,欢迎使用:&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"input-group text-left\"&gt; &lt;label&gt;输入用户名：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" /&gt; &lt;button id=\"conn\"&gt;连接&lt;/button&gt; &lt;button id=\"close\"&gt;断开&lt;/button&gt; &lt;/div&gt; &lt;div class=\"input-group text-muted\"&gt; &lt;div class=\"kuang\" id=\"mess\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;hr class=\"featurette-divider\"&gt; &lt;div class=\"input-group text-left\"&gt; &lt;input type=\"text\" class=\"value\" id=\"value1\" /&gt; &lt;button id=\"send\"&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var input = document.getElementById(\"name\"); var conn = document.getElementById(\"conn\"); var close = document.getElementById(\"close\"); var mess = document.getElementById(\"mess\"); var value1 = document.getElementById(\"value1\"); var pattern = /^[\\u4e00-\\u9fa5]&#123;2,10&#125;$/; close.disabled = true; if (window.WebSocket) &#123; conn.onclick = function () &#123; if (!pattern.test(input.value)) &#123; alert(\"名称不能为空且必须为中文\"); return; &#125; var ws = new WebSocket('ws://127.0.0.1:8082'); conn.disabled = true; close.disabled = false; ws.onopen = function (e) &#123; console.log(\"连接服务器成功\"); ws.send(input.value); input.setAttribute(\"readOnly\", 'true'); value1.setAttribute(\"readOnly\", 'true'); &#125; ws.onmessage = function (e) &#123; value1.removeAttribute(\"readOnly\"); var time = new Date(); mess.innerHTML += time.toUTCString() + \":\" + e.data + \"&lt;br&gt;\"; document.getElementById(\"send\").onclick = function (e) &#123; ws.send(input.value + \"说:\" + value1.value); value1.value = \" \"; &#125; document.onkeydown = function (e) &#123; e = e || window.event; if (e.keyCode == 13) &#123; document.getElementById(\"send\").onclick(); return false; &#125; &#125; &#125; ws.onclose = function (e) &#123; console.log(\"服务器关闭\"); &#125; ws.onerror = function () &#123; console.log(\"连接出错\"); &#125; close.onclick = function () &#123; ws.onclose(); ws.send(input.value + 'close' + \"了连接\"); input.removeAttribute(\"readOnly\"); conn.disabled = false; close.disabled = true; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var ws = require(\"nodejs-websocket\");console.log(\"开始建立连接...\");var str1 = null, str2 = null, clientReady = false, serverReady = false;var a = [];var server = ws.createServer(function (conn) &#123; conn.on('text', function (str) &#123; a.push(str); if (!clientReady) &#123; if (a[0] === str) &#123; str1 = conn; clientReady = true; str1.sendText(\"欢迎你\" + str); &#125; &#125; else if (!serverReady) &#123; if (str.indexOf('close') &amp;gt;= 0) &#123; a.splice(2,1); clientReady = false; str1=null; return; &#125; if (a[1] === str) &#123; str2 = conn; serverReady = true; str2.sendText(\"欢迎你\" + str); str1.sendText(str + \"在线啦，你们可以聊天啦\"); return; &#125; &#125; else if (clientReady &amp;amp;&amp;amp; serverReady) &#123; str2.sendText(str); str1.sendText(str); if (str.indexOf('close') &amp;gt;= 0) &#123; a.splice(2, a.length); var len = a.length; for (var i = 0; i &amp;lt; len; i++) &#123; // 定位该元素位置 if (str.indexOf(a[i])&amp;gt;=0) &#123; a.splice(i,1); if(i==0)&#123; str1=str2; &#125; serverReady = false; str2=null; return; &#125; &#125; &#125; &#125; &#125;) conn.on(\"close\", function (code, reason) &#123; console.log(\"关闭连接\"); clientReady = false; serverReady = false; &#125;) conn.on(\"error\", function (code, reason) &#123; console.log(\"异常关闭\"); &#125;);&#125;).listen(8082);console.log(\"websocket连接完毕\") 实现双人聊天，client.html开启两个窗口就行！详细代码在github","content":"<h2 id=\"介绍下websocket：\"><a href=\"#介绍下websocket：\" class=\"headerlink\" title=\"介绍下websocket：\"></a>介绍下websocket：</h2><p>  webSocket协议本质上是一个基于tcp的协议; </p>\n<h2 id=\"建立一个websocket连接，大体的过程：\"><a href=\"#建立一个websocket连接，大体的过程：\" class=\"headerlink\" title=\"建立一个websocket连接，大体的过程：\"></a>建立一个websocket连接，大体的过程：</h2><p> 1.客户端浏览器首先向服务器发起一个http请求，这个请求和平常的请求有什么不同呢？<br> 多了一点附加头信息：”upgrade:web Socket” 表明我这申请的是一个websocket的http请求；<br> 2.服务器收到请求后，解析这些附加的头信息，然后产生应答信息返回给客户端，这样，连接就建立了；<br> 3.双方就可以通过这个连接通道自由的信息传递，这个连接会一直存在，直到一方自动关闭连接； </p>\n<a id=\"more\"></a>\n<h3 id=\"客户端到服务端：\"><a href=\"#客户端到服务端：\" class=\"headerlink\" title=\"客户端到服务端：\"></a>客户端到服务端：</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /demo HTTP/<span class=\"number\">1.1</span></div><div class=\"line\">Host: example.com</div><div class=\"line\">Connection: Upgrade</div><div class=\"line\">Sec-WebSocket-Key2: <span class=\"number\">12998</span> <span class=\"number\">5</span> Y3 <span class=\"number\">1</span> .P00</div><div class=\"line\">Upgrade: WebSocket</div><div class=\"line\">Sec-WebSocket-Key1: <span class=\"number\">4</span>@<span class=\"number\">1</span> <span class=\"number\">46546</span>xW%<span class=\"number\">0</span>l <span class=\"number\">1</span> <span class=\"number\">5</span></div><div class=\"line\">Origin: http:<span class=\"comment\">//example.com</span></div><div class=\"line\">[<span class=\"number\">8</span>-byte security key]</div></pre></td></tr></table></figure>\n<h3 id=\"服务端到客户端：\"><a href=\"#服务端到客户端：\" class=\"headerlink\" title=\"服务端到客户端：\"></a>服务端到客户端：</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">101</span> WebSocket Protocol Handshake</div><div class=\"line\">Upgrade: WebSocket</div><div class=\"line\">Connection: Upgrade</div><div class=\"line\">WebSocket-Origin: http:<span class=\"comment\">//example.com</span></div><div class=\"line\">WebSocket-Location: ws:<span class=\"comment\">//example.com/demo</span></div><div class=\"line\">[<span class=\"number\">16</span>-byte hash response]</div></pre></td></tr></table></figure>\n<p>从客户端到服务端请求的信息里面包含：‘Sec-webSocket-key1”,”Sec-WebSocket-key2”和“[8-byte security key]”这样的信息；这是客户端浏览器需要向服务端提供的握手信息，服务端解析这些头信息，并且在握手的过程中依据这些信息生成一个16位的安全密钥并返回给客户端，以表明服务器端获取了客户端的请求；<br><strong>大致步骤：</strong> </p>\n<ol>\n<li>逐个字符读取 Sec-WebSocket-Key1 头信息中的值，将数值型字符连接到一起放到一个临时字符串里，同时统计所有空格的数量；</li>\n<li>将在第 1 步里生成的数字字符串转换成一个整型数字，然后除以第 1 步里统计出来的空格数量，将得到的浮点数转换成整数型；</li>\n<li>将第 2 步里生成的整型值转换为符合网络传输的网络字节数组；</li>\n<li>对 Sec-WebSocket-Key2 头信息同样进行第 1 到第 3 步的操作，得到另外一个网络字节数组；</li>\n<li>将 [8-byte security key] 和在第 3，第 4 步里生成的网络字节数组合并成一个 16 字节的数组；</li>\n<li>对第 5 步生成的字节数组使用 MD5 算法生成一个哈希值，这个哈希值就作为安全密钥返回给客户端，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  wsServer = <span class=\"string\">'ws://localhost:8888/Demo'</span>;  <span class=\"comment\">//连接地址</span></div><div class=\"line\"><span class=\"keyword\">var</span>  websocket = <span class=\"keyword\">new</span> WebSocket(wsServer);   <span class=\"comment\">//建立连接</span></div><div class=\"line\">websocket.onopen = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123; onOpen(evt) &#125;;  <span class=\"comment\">//4个事件</span></div><div class=\"line\">websocket.onclose = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123; onClose(evt) &#125;; </div><div class=\"line\">websocket.onmessage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123; onMessage(evt) &#125;; </div><div class=\"line\">websocket.onerror = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123; onError(evt) &#125;; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onOpen</span>(<span class=\"params\">evt</span>) </span>&#123; </div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Connected to WebSocket server.\"</span>); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onClose</span>(<span class=\"params\">evt</span>) </span>&#123; </div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Disconnected\"</span>); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onMessage</span>(<span class=\"params\">evt</span>) </span>&#123; </div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Retrieved data from server: '</span> + evt.data); </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onError</span>(<span class=\"params\">evt</span>) </span>&#123; </div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Error occured: '</span> + evt.data); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>浏览器的支持情况： </p>\n<table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th>支持情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Chrome</td>\n<td>Supported in version 4+</td>\n</tr>\n<tr>\n<td>Firefox</td>\n<td>Supported in version 4+</td>\n</tr>\n<tr>\n<td>Internet Explorer</td>\n<td>Supported in version 10+</td>\n</tr>\n<tr>\n<td>Opera</td>\n<td>Supported in version 10+</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>Supported in version 5+</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"正文来了：基于websocket制作的简单聊天系统；\"><a href=\"#正文来了：基于websocket制作的简单聊天系统；\" class=\"headerlink\" title=\"正文来了：基于websocket制作的简单聊天系统；\"></a>正文来了：基于websocket制作的简单聊天系统；</h2><h3 id=\"简单的界面，大致效果就是这样的：\"><a href=\"#简单的界面，大致效果就是这样的：\" class=\"headerlink\" title=\"简单的界面，大致效果就是这样的：\"></a>简单的界面，大致效果就是这样的：</h3><p><img src=\"/images/websocket-1.png\" alt=\"websocket\"></p>\n<h3 id=\"实现逻辑代码：\"><a href=\"#实现逻辑代码：\" class=\"headerlink\" title=\"实现逻辑代码：\"></a>实现逻辑代码：</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">'ws://127.0.0.1:8082'</span>);</div><div class=\"line\">    ws.onopen = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"连接服务器成功\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">                ws.onmessage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">                    value1.removeAttribute(<span class=\"string\">\"readOnly\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">var</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">                    mess.innerHTML += time.toUTCString() + <span class=\"string\">\":\"</span> + e.data + <span class=\"string\">\"&amp;lt;br&amp;gt;\"</span>;</div><div class=\"line\">                    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"send\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">                        ws.send(input.value + <span class=\"string\">\"说:\"</span> + value1.value);</div><div class=\"line\">                        value1.value = <span class=\"string\">\" \"</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"built_in\">document</span>.onkeydown = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">                        e = e || <span class=\"built_in\">window</span>.event;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (e.keyCode == <span class=\"number\">13</span>) &#123;</div><div class=\"line\">                            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"send\"</span>).onclick();</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                ws.onclose = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"服务器关闭\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ws.onerror = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"连接出错\"</span>);</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n<p>连接地址：ws://127.0.0.1:8082&nbsp; 那是哪里来的呢？（注意http请求则是写成<a href=\"http://xxx,https请求则是https://xxx；ws当然是ws://xxx);wbsocket只是客服端，地址当然是从我们的服务端给的呀；\" target=\"_blank\" rel=\"external\">http://xxx,https请求则是https://xxx；ws当然是ws://xxx);wbsocket只是客服端，地址当然是从我们的服务端给的呀；</a><br>服务端的搭建采用了一个这样的库： <code>nodejs-websocket</code> </p>\n<ol>\n<li><code>npm isntall -g nodejs-websocket</code></li>\n<li><p>在js页面引入它 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">var</span> ws = <span class=\"built_in\">require</span>(<span class=\"string\">\"nodejs-websocket\"</span> );  </div><div class=\"line\"> <span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\"> 3. 创建一个服务 </div><div class=\"line\"></div><div class=\"line\">`<span class=\"string\">``</span>javascript </div><div class=\"line\"> <span class=\"keyword\">var</span> server = ws.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">conn</span>) </span>&#123;</div><div class=\"line\">    conn.on(<span class=\"string\">'text'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    conn.on(<span class=\"string\">\"close\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, reason</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"关闭连接\"</span>);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    conn.on(<span class=\"string\">\"error\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, reason</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异常关闭\"</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;).listen(<span class=\"number\">8082</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"websocket连接完毕\"</span>)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"websocket连接算是建立啦！\"><a href=\"#websocket连接算是建立啦！\" class=\"headerlink\" title=\"websocket连接算是建立啦！\"></a>websocket连接算是建立啦！</h3><p>下面展示下具体代码：<br><code>client.html</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"bootstrap-3.3.7-dist/css/bootstrap.min.css\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jquery.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bootstrap-3.3.7-dist/js/bootstrap.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></div><div class=\"line\">        <span class=\"selector-class\">.kuang</span> &#123;</div><div class=\"line\">            <span class=\"attribute\">width</span>: <span class=\"number\">600px</span>;</div><div class=\"line\">            <span class=\"attribute\">min-height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">            <span class=\"attribute\">max-height</span>: <span class=\"number\">296px</span>;</div><div class=\"line\">            <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid;</div><div class=\"line\">            <span class=\"attribute\">float</span>: left;</div><div class=\"line\">            <span class=\"attribute\">display</span>: block;</div><div class=\"line\">            <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">            <span class=\"attribute\">overflow-y</span>: scroll;</div><div class=\"line\">        &#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></div><div class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"jumbotron  bg-dark\"</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">class</span>=<span class=\"string\">\"jumbotron-heading\"</span>&gt;</span>WebSocket chat,欢迎使用:<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"input-group text-left\"</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>输入用户名：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"name\"</span> /&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"conn\"</span>&gt;</span>连接<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"close\"</span>&gt;</span>断开<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"input-group text-muted\"</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"kuang\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mess\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">hr</span> <span class=\"attr\">class</span>=<span class=\"string\">\"featurette-divider\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"input-group text-left\"</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"value\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"value1\"</span> /&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"send\"</span>&gt;</span>发送<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">        <span class=\"keyword\">var</span> input = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"name\"</span>);</div><div class=\"line\">        <span class=\"keyword\">var</span> conn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"conn\"</span>);</div><div class=\"line\">        <span class=\"keyword\">var</span> close = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"close\"</span>);</div><div class=\"line\">        <span class=\"keyword\">var</span> mess = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mess\"</span>);</div><div class=\"line\">        <span class=\"keyword\">var</span> value1 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"value1\"</span>);</div><div class=\"line\">        <span class=\"keyword\">var</span> pattern = <span class=\"regexp\">/^[\\u4e00-\\u9fa5]&#123;2,10&#125;$/</span>;</div><div class=\"line\">        close.disabled = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.WebSocket) &#123;</div><div class=\"line\">            conn.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!pattern.test(input.value)) &#123;</div><div class=\"line\">                    alert(<span class=\"string\">\"名称不能为空且必须为中文\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">'ws://127.0.0.1:8082'</span>);</div><div class=\"line\">                conn.disabled = <span class=\"literal\">true</span>;</div><div class=\"line\">                close.disabled = <span class=\"literal\">false</span>;</div><div class=\"line\">                ws.onopen = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"连接服务器成功\"</span>);</div><div class=\"line\">                    ws.send(input.value);</div><div class=\"line\">                    input.setAttribute(<span class=\"string\">\"readOnly\"</span>, <span class=\"string\">'true'</span>);</div><div class=\"line\">                    value1.setAttribute(<span class=\"string\">\"readOnly\"</span>, <span class=\"string\">'true'</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ws.onmessage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">                    value1.removeAttribute(<span class=\"string\">\"readOnly\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">var</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">                    mess.innerHTML += time.toUTCString() + <span class=\"string\">\":\"</span> + e.data + <span class=\"string\">\"&lt;br&gt;\"</span>;</div><div class=\"line\">                    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"send\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">                        ws.send(input.value + <span class=\"string\">\"说:\"</span> + value1.value);</div><div class=\"line\">                        value1.value = <span class=\"string\">\" \"</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    <span class=\"built_in\">document</span>.onkeydown = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">                        e = e || <span class=\"built_in\">window</span>.event;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (e.keyCode == <span class=\"number\">13</span>) &#123;</div><div class=\"line\">                            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"send\"</span>).onclick();</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                ws.onclose = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"服务器关闭\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ws.onerror = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"连接出错\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\"> </div><div class=\"line\">                close.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                    ws.onclose();</div><div class=\"line\">                    ws.send(input.value + <span class=\"string\">'close'</span> + <span class=\"string\">\"了连接\"</span>);</div><div class=\"line\">                    input.removeAttribute(<span class=\"string\">\"readOnly\"</span>);</div><div class=\"line\">                    conn.disabled = <span class=\"literal\">false</span>;</div><div class=\"line\">                    close.disabled = <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><code>server.js</code> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"built_in\">require</span>(<span class=\"string\">\"nodejs-websocket\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"开始建立连接...\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"literal\">null</span>, str2 = <span class=\"literal\">null</span>, clientReady = <span class=\"literal\">false</span>, serverReady = <span class=\"literal\">false</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> a = [];</div><div class=\"line\"><span class=\"keyword\">var</span> server = ws.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">conn</span>) </span>&#123;</div><div class=\"line\">    conn.on(<span class=\"string\">'text'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">          a.push(str);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!clientReady) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[<span class=\"number\">0</span>] === str) &#123;</div><div class=\"line\">                str1 = conn;</div><div class=\"line\">                clientReady = <span class=\"literal\">true</span>;</div><div class=\"line\">                str1.sendText(<span class=\"string\">\"欢迎你\"</span> + str);</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!serverReady) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (str.indexOf(<span class=\"string\">'close'</span>) &amp;gt;= <span class=\"number\">0</span>) &#123;    </div><div class=\"line\">                     a.splice(<span class=\"number\">2</span>,<span class=\"number\">1</span>);</div><div class=\"line\">                     clientReady = <span class=\"literal\">false</span>;</div><div class=\"line\">                     str1=<span class=\"literal\">null</span>;   </div><div class=\"line\">                     <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (a[<span class=\"number\">1</span>] === str) &#123;</div><div class=\"line\">                str2 = conn;</div><div class=\"line\">                serverReady = <span class=\"literal\">true</span>;</div><div class=\"line\">                str2.sendText(<span class=\"string\">\"欢迎你\"</span> + str);</div><div class=\"line\">                str1.sendText(str + <span class=\"string\">\"在线啦，你们可以聊天啦\"</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125; </div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (clientReady &amp;amp;&amp;amp; serverReady) &#123;</div><div class=\"line\">                str2.sendText(str);</div><div class=\"line\">                str1.sendText(str);</div><div class=\"line\">                <span class=\"keyword\">if</span> (str.indexOf(<span class=\"string\">'close'</span>) &amp;gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                    a.splice(<span class=\"number\">2</span>, a.length);</div><div class=\"line\">                    <span class=\"keyword\">var</span> len = a.length;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; len; i++) &#123;</div><div class=\"line\">                        <span class=\"comment\">// 定位该元素位置</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (str.indexOf(a[i])&amp;gt;=<span class=\"number\">0</span>) &#123;     </div><div class=\"line\">                           a.splice(i,<span class=\"number\">1</span>);</div><div class=\"line\">                           <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)&#123;</div><div class=\"line\">                               str1=str2;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           serverReady = <span class=\"literal\">false</span>; </div><div class=\"line\">                           str2=<span class=\"literal\">null</span>;</div><div class=\"line\">                           <span class=\"keyword\">return</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                      </div><div class=\"line\">                    &#125; </div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;       </div><div class=\"line\">    &#125;)</div><div class=\"line\">    conn.on(<span class=\"string\">\"close\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, reason</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"关闭连接\"</span>);</div><div class=\"line\">        clientReady = <span class=\"literal\">false</span>;</div><div class=\"line\">        serverReady = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    conn.on(<span class=\"string\">\"error\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, reason</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异常关闭\"</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;).listen(<span class=\"number\">8082</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"websocket连接完毕\"</span>)</div></pre></td></tr></table></figure>\n<p>实现双人聊天，client.html开启两个窗口就行！<br>详细代码在<a href=\"https://github.com/sulishibaobei/websocket\" target=\"_blank\" rel=\"external\">github</a></p>\n","comments":true,"categories":[{"name":"html5","slug":"html5","permalink":"http://www.sulishibaobei.com/categories/html5/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.sulishibaobei.com/tags/nodejs/"},{"name":"websocket","slug":"websocket","permalink":"http://www.sulishibaobei.com/tags/websocket/"}]},{"title":"git 打卡的第一天","date":"2017-09-07T01:08:53.000Z","path":"git/git-120170907/","text":"因为某种原因，所以不得不重新巩固下前端的基础知识，从最基本的学习还得额外的学习新知识，倍感压力之大。 昨天初略学习下git，算是自己学习的一个新知识。简单记录下，希望四海八荒的大神看过来，有错的请指导。 git下载安装git下载安装地址下载好之后记得配置环境变量。git的作用主要是将项目保存到git目录中 git介绍主要分为三个块：[1] working directory(工作目录） 本地上存放项目的目录。[2] staging area 暂存放区域 更新暂未提交的项目。[3] git directory git上存放项目的地方。1.一般我们使用git都会将一些修改的文件保存在暂存区域，然后一并提交更新到git目录中。2.安装好git之后，网页打开github，注册信息。登陆进去，接下来配置信息。3.打开右上角，如下图点击settings。然后点击SSH and GPG keys ,配置SSH。打开cmd或者git bash。找不到git.bash的就在开始那里搜索或者在你安装的git文件里面打开git.bash.exe就一样。4.在命令行输入：ssh-keygen -t rsa -C “你注册github时的邮箱名” 然后会提示你生产的key在id_rsa.pub文件中找。5.在电脑中一个叫.ssh的文件里，然后复制黏贴在右边的key框里面，title就随便打。 此时git的安装目录就为你的根目录。 配置用户信息：git config --global user.name &quot;你注册时的用户名&quot;;git config --global user.email &quot;你的邮箱&quot;;git里面提供了一个git config的命令专门用来配置或者读取相应的工作环境变量。这些变量可以存放在三个地方：etc/gitconfig文件， git config –system读写的就是此文件；~/.gitconfig文件，git config –global 读写的就是此文件；配置好信息后，可以通过git config –list 命令查看&nbsp;&nbsp; 如果git config user.name就是具体的查看某个环境变量的设定。若不知道如何使用git命令，可以git help看看。 git使用。 新建一个git 仓库，也可以导入一个本地项目。进入仓库 复制这个地址 然后打开cmd或者git.bash.exe， 输入git clone git@github.com:sulishibaobei/a.github.io.git （上面复制的这串地址) 就会在你的本地建立一个名为a.github.io的仓库，进入仓库，将你需要上传的代码拷贝进去 123git add *（*是上传所有的本件，若是想具体的就写文件名）git commit -m \"version\" 提交文件git push 这三步就完成git项目的提交。 可以用git status命令查看当前文件的状态。 所有的文件都可以先add到暂存区域，然后最后再一起commit。","content":"<p>因为某种原因，所以不得不重新巩固下前端的基础知识，从最基本的学习还得额外的学习新知识，倍感压力之大。 昨天初略学习下git，算是自己学习的一个新知识。简单记录下，希望四海八荒的大神看过来，有错的请指导。</p>\n<h2 id=\"git下载安装\"><a href=\"#git下载安装\" class=\"headerlink\" title=\"git下载安装\"></a>git下载安装</h2><p><a href=\"https://git-for-windows.github.io/\" target=\"_blank\" rel=\"external\">git下载安装地址</a>下载好之后记得配置环境变量。<br><strong>git的作用主要是将项目保存到git目录中</strong><br><a id=\"more\"></a></p>\n<h2 id=\"git介绍\"><a href=\"#git介绍\" class=\"headerlink\" title=\"git介绍\"></a>git介绍</h2><p><strong>主要分为三个块：</strong><br>[1] working directory(工作目录）  本地上存放项目的目录。<br>[2] staging area 暂存放区域    更新暂未提交的项目。<br>[3] git directory  git上存放项目的地方。<br>1.一般我们使用git都会将一些修改的文件保存在暂存区域，然后一并提交更新到git目录中。<br>2.安装好git之后，网页打开github，注册信息。登陆进去，接下来配置信息。<br>3.打开右上角，如下图点击settings。然后点击SSH and GPG keys ,配置SSH。打开cmd或者git bash。找不到git.bash的就在开始那里搜索或者在你安装的git文件里面打开git.bash.exe就一样。<br>4.在命令行输入：<font color=\"red\">ssh-keygen -t rsa -C “你注册github时的邮箱名” </font>然后会提示你生产的key在id_rsa.pub文件中找。<br><img src=\"/images/git-1.png\" alt=\"git\"><br>5.在电脑中一个叫.ssh的文件里，然后复制黏贴在右边的key框里面，title就随便打。<br><img src=\"/images/git-2.png\" alt=\"git\"><br><img src=\"/images/git-3.png\" alt=\"git\"><br> 此时git的安装目录就为你的根目录。</p>\n<h2 id=\"配置用户信息：\"><a href=\"#配置用户信息：\" class=\"headerlink\" title=\"配置用户信息：\"></a>配置用户信息：</h2><p><code>git config --global user.name &quot;你注册时的用户名&quot;;</code><br><code>git config  --global user.email &quot;你的邮箱&quot;;</code><br>git里面提供了一个git config的命令专门用来配置或者读取相应的工作环境变量。<br>这些变量可以存放在三个地方：etc/gitconfig文件， git config –system读写的就是此文件；~/.gitconfig文件，git config –global 读写的就是此文件；<br>配置好信息后，可以通过git config –list 命令查看&nbsp;&nbsp; 如果git config user.name就是具体的查看某个环境变量的设定。<br><strong>若不知道如何使用git命令，可以git help看看。</strong> </p>\n<h2 id=\"git使用。\"><a href=\"#git使用。\" class=\"headerlink\" title=\"git使用。\"></a>git使用。</h2><p><img src=\"/images/git-4.png\" alt=\"git\"><br> 新建一个git 仓库，也可以导入一个本地项目。进入仓库<br> 复制这个地址<br><img src=\"/images/git-5.png\" alt=\"git\"><br> 然后打开cmd或者git.bash.exe，<br> 输入<code>git clone git@github.com:sulishibaobei/a.github.io.git</code> （上面复制的这串地址)<br> 就会在你的本地建立一个名为a.github.io的仓库，进入仓库，将你需要上传的代码拷贝进去 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add *（*是上传所有的本件，若是想具体的就写文件名）</div><div class=\"line\">git commit  -m <span class=\"string\">\"version\"</span>  提交文件</div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p> 这三步就完成git项目的提交。<br> 可以用git status命令查看当前文件的状态。<br> 所有的文件都可以先add到暂存区域，然后最后再一起commit。 </p>\n","comments":true,"categories":[{"name":"Git","slug":"Git","permalink":"http://www.sulishibaobei.com/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.sulishibaobei.com/tags/git/"},{"name":"环境变量配置","slug":"环境变量配置","permalink":"http://www.sulishibaobei.com/tags/环境变量配置/"},{"name":"基本git操作","slug":"基本git操作","permalink":"http://www.sulishibaobei.com/tags/基本git操作/"}]},{"title":"滑稽的下午--Angular 2+管道的使用","date":"2017-09-07T01:08:53.000Z","path":"angular/pipe/pipe-120170907/","text":"注:所有的angular 2+ 其实就包含了4,是向上兼容的； 让一个component组件里的时间显示当前时间并自动刷新。过程:1.首先获取当前时间 new Date();2.弄个定时器隔一秒刷新呀； app.component.ts中这样写到： 123456789101112131415161718InitialTime= new Date(); // 获取当前时间 data:string; getTime(m)&#123; // 判断获取的分钟数是否小于10，小于10只会显示一位数，前面自动补0 if (m&amp;lt;10 )&#123; m =\"0\"+ m; this .data= this .InitialTime.getHours()+\":\"+m; // 显示时间(小时+分钟) eg 17:15 &#125; else &#123; this .data= this .InitialTime.getHours()+\":\"+ this .InitialTime.getMinutes(); // 显示时间(小时+分钟) eg 17:15 &#125; &#125; constructor()&#123; this .getTime( this .InitialTime.getMinutes()); // 运行上面方法让时间显示 setInterval(()=&amp;gt;&#123; // 设置定时器，隔1秒刷新一次，好实时监控时间 this .InitialTime= new Date(); this .getTime( this .InitialTime.getMinutes()); &#125;, 1000 ); &#125; app.component.html中这样写： 1&amp;lt;span class=\"time\"&amp;gt; &#123;&#123; date &#125;&#125;&amp;lt;/span&amp;gt; 然后变成我想要的效果了，可是代码我自己都嫌长，而且还是用传统js方法写的。后来就想不是angular里面有Pipe管道吗，是不是可以试试。app.component.ts是这样写的。 1234567time:any=Date.now(); // 获取当前时间 constructor()&#123; setInterval(() =&amp;gt;&#123; // 设置定时器，隔1秒刷新一次，好实时监控时间 // this.birthday = new Date(); this .time=Date.now(); // Date里面自带方法 &#125;,1000 ); &#125; app.component.html是这样写的： 1&amp;lt;span class=\"time\"&amp;gt; &#123;&#123;time | date:\"HH:mm\" &#125;&#125;&amp;lt;/span&amp;gt; 注：|是管道标示符。angular里面提供了内置的datePipe管道可以供我们使用 HH：mm 表示输出小时和分钟；yy:MM:dd&nbsp; 表示输出年月日 详情可以看看官网的管道介绍里面关于DatePipe Api的介绍。 同样的效果，代码量就大大减少，所以学习还是在完成的基础上多尝试。耶~~~ 后续会有详细的关于管道学习的更多文章","content":"<p>注:所有的angular 2+ 其实就包含了4,是向上兼容的；</p>\n<p><img src=\"/images/pipe-1.png\" alt=\"pipe\"><br>让一个component组件里的时间显示当前时间并自动刷新。<br><strong>过程:</strong><br>1.首先获取当前时间 new Date();<br>2.弄个定时器隔一秒刷新呀；</p>\n<a id=\"more\"></a>\n<p> <code>app.component.ts中这样写到：</code></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">InitialTime= <span class=\"keyword\">new</span>  <span class=\"built_in\">Date</span>();  <span class=\"comment\">// 获取当前时间  </span></div><div class=\"line\">data:string;</div><div class=\"line\"> getTime(m)&#123;   <span class=\"comment\">// 判断获取的分钟数是否小于10，小于10只会显示一位数，前面自动补0 </span></div><div class=\"line\">      <span class=\"keyword\">if</span> (m&amp;lt;<span class=\"number\">10</span> )&#123;</div><div class=\"line\">        m =<span class=\"string\">\"0\"</span>+ m;</div><div class=\"line\">         <span class=\"keyword\">this</span> .data= <span class=\"keyword\">this</span> .InitialTime.getHours()+<span class=\"string\">\":\"</span>+m;   <span class=\"comment\">// 显示时间(小时+分钟) eg   17:15 </span></div><div class=\"line\">   &#125;</div><div class=\"line\">     <span class=\"keyword\">else</span>  &#123;</div><div class=\"line\">         <span class=\"keyword\">this</span> .data= <span class=\"keyword\">this</span> .InitialTime.getHours()+<span class=\"string\">\":\"</span>+ <span class=\"keyword\">this</span> .InitialTime.getMinutes();     <span class=\"comment\">// 显示时间(小时+分钟) eg   17:15 </span></div><div class=\"line\">   &#125; </div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span> .getTime( <span class=\"keyword\">this</span> .InitialTime.getMinutes()); <span class=\"comment\">// 运行上面方法让时间显示 </span></div><div class=\"line\">    setInterval(()=&amp;gt;&#123;  <span class=\"comment\">// 设置定时器，隔1秒刷新一次，好实时监控时间 </span></div><div class=\"line\">              <span class=\"keyword\">this</span> .InitialTime= <span class=\"keyword\">new</span>  <span class=\"built_in\">Date</span>();</div><div class=\"line\">               <span class=\"keyword\">this</span> .getTime( <span class=\"keyword\">this</span>  .InitialTime.getMinutes());                              </div><div class=\"line\">             &#125;, <span class=\"number\">1000</span> );                </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><code>app.component.html中这样写：</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&amp;lt;span class=\"time\"&amp;gt; &#123;&#123; date &#125;&#125;&amp;lt;/span&amp;gt;</div></pre></td></tr></table></figure>\n<p>然后变成我想要的效果了，可是代码我自己都嫌长，而且还是用传统js方法写的。后来就想不是angular里面有Pipe管道吗，是不是可以试试。<br><code>app.component.ts是这样写的。</code> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">time:any=<span class=\"built_in\">Date</span>.now();  <span class=\"comment\">// 获取当前时间 </span></div><div class=\"line\"> <span class=\"keyword\">constructor</span>()&#123;</div><div class=\"line\">    setInterval(() =&amp;gt;&#123;  <span class=\"comment\">// 设置定时器，隔1秒刷新一次，好实时监控时间 </span></div><div class=\"line\">          <span class=\"comment\">//   this.birthday = new Date();       </span></div><div class=\"line\">           <span class=\"keyword\">this</span> .time=<span class=\"built_in\">Date</span>.now();   <span class=\"comment\">// Date里面自带方法                   </span></div><div class=\"line\">              &#125;,<span class=\"number\">1000</span> );  </div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p><code>app.component.html是这样写的：</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&amp;lt;span class=\"time\"&amp;gt; &#123;&#123;time | date:\"HH:mm\" &#125;&#125;&amp;lt;/span&amp;gt;</div></pre></td></tr></table></figure>\n<p><strong>注：</strong><br>|是管道标示符。angular里面提供了内置的datePipe管道可以供我们使用<br>  HH：mm 表示输出小时和分钟；yy:MM:dd&nbsp; 表示输出年月日<br>  详情可以看看官网的管道介绍里面关于DatePipe Api的介绍。<br>  同样的效果，代码量就大大减少，所以学习还是在完成的基础上多尝试。耶~~~<br>  后续会有详细的关于管道学习的<a href=\"\">更多文章</a></p>\n","comments":true,"categories":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/categories/Angular-2/"}],"tags":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/tags/Angular-2/"},{"name":"pipe","slug":"pipe","permalink":"http://www.sulishibaobei.com/tags/pipe/"},{"name":"管道","slug":"管道","permalink":"http://www.sulishibaobei.com/tags/管道/"},{"name":"日期","slug":"日期","permalink":"http://www.sulishibaobei.com/tags/日期/"}]},{"title":"Css3雪碧图","date":"2017-09-07T01:08:53.000Z","path":"css/sp-120170907/","text":"Css雪碧图： CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。原理：CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。如何生成雪碧图？安装gulp插件： npm install –g gulp安装制作雪碧图需要的插件 npm install –g gulp.spritesmith最好全局和本地各装一遍； 新建一个Gulpfile.js文件，将下列代码放进去： 12345678910111213var gulp=require('gulp'); //引入这两个gulp gulp.spritesmith spritesmith=require('gulp.spritesmith'); gulp.task('default',function()&#123; //新建名为sprite的任务 gulp.src('images/*.png') //需要合成的图片路径 *为通配符 表示这个文件夹下面所有后缀为.png的文件都会被应用 .pipe(spritesmith(&#123; imgName:'sprite.png',//合成后需要保存图片的路径 cssName:'sprite.css', //合成后需要保存的css的路径 padding:5, //表示两个图片间的空隙 algorithm:'binary-tree', // Algorithm 有四个可选值分别为top-down、left-right、diagonal、alt-diagonal、binary-tree // cssTemplate:'dist/handlebarsStr.css' //生成的css模板文件，可以是函数也可以是字符串 &#125;)) .pipe(gulp.dest('dist/')) //将生成的文件放到dist文件夹下 &#125;) 或者:进入项目 npm init 输入需要的信息,创建一个package.json文件: 12345678910111213141516 &#123; \"name\": \"package.json\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"Gulpfile.js\", \"dependencies\": &#123; \"gulp\": \"^3.9.1\", \"gulp.spritesmith\": \"^6.5.1\" &#125;, \"devDependencies\": &#123;&#125;, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;amp;&amp;amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 这里提几点需要注意的：需要一个Gulpfile.js（首字母小写也可以） ，运行时执行 gulp default（defaullt是你新建的任务名，不是固定的，你写成其他也行）imgName:’sprite.png’//合成后需要保存图片的路径cssName:’sprite.css’这两个文件需要你先创建，里面的文件都要预先创建;我这里是放在dist下面就要在dis下面创建这两个文件合成的雪碧图；css样式： 123456789101112131415161718192021222324252627282930313233343536373839404142.icon-1 &#123; background-image: url(sprite.png); background-position: 0px 0px; width: 33px; height: 33px;&#125;.icon-2 &#123; background-image: url(sprite.png); background-position: -38px 0px; width: 33px; height: 33px;&#125;.icon-3 &#123; background-image: url(sprite.png); background-position: 0px -38px; width: 33px; height: 33px;&#125;.icon-4 &#123; background-image: url(sprite.png); background-position: -38px -38px; width: 33px; height: 33px;&#125;.icon-5 &#123; background-image: url(sprite.png); background-position: -76px 0px; width: 33px; height: 33px;&#125;.icon-6 &#123; background-image: url(sprite.png); background-position: -76px -38px; width: 33px; height: 33px;&#125;.icon-7 &#123; background-image: url(sprite.png); background-position: 0px -76px; width: 33px; height: 33px;&#125; algorithm：四个参数只是决定图片的排列顺序；top-down：具体的参数可以看这里：好了,雪碧图就合成啦；下面会讲讲如何使用雪碧图；创建一个文件：index.html引入生成的css1&lt;link rel=”stylesheet” type=”text/css” href=”./dist/sprite.css” /&gt; 写基本架构：class=”icon-1” 这里是css里生成的样式名；按顺序写好就行; 123456789101112131415161718192021222324252627282930&lt;ul class=\"sprite\"&gt; &lt;li&gt; &lt;s class=\"icon-1\"&gt;&lt;/s&gt; &lt;a href=\"\"&gt;衣服&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class=\"icon-2\"&gt;&lt;/s&gt; &lt;a href=\"\"&gt;鞋子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class=\"icon-3\"&gt;&lt;/s&gt; &lt;a href=\"\"&gt;背包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class=\"icon-4\"&gt;&lt;/s&gt; &lt;a href=\"\"&gt;双肩包&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class=\"icon-5\"&gt;&lt;/s&gt; &lt;a href=\"\"&gt;裤子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class=\"icon-6\"&gt;&lt;/s&gt; &lt;a href=\"\"&gt;羽绒服&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;s class=\"icon-7\"&gt;&lt;/s&gt; &lt;a href=\"\"&gt;外套&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; 给他们新增加一些样式： 1234567891011121314151617181920212223242526ul &#123; list-style: none; margin: 0; padding: 0;&#125;.sprite &#123; margin: 10px auto; width: 206px; border: 1px solid #b51600;&#125;.sprite li &#123; cursor: pointer; height: 42px; width: 206px; background-color: #b51600; border-bottom: 1px solid #911001; border-top: 1px solid #c11e08;&#125;.sprite li a &#123; color: #fff; line-height: 42px; font-size: 14px;&#125; 效果就是这样：引入了css文件，class也改动了，怎么没有图标呢？生成的css文件里面就告诉你了，让标签dispay:block; 12345.sprite li s&#123; display: inline-block; margin-left: 10px; margin-right: 8px; &#125; 看看效果：","content":"<p>Css雪碧图： CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。<br>原理：CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。<br>如何生成雪碧图？<br>安装gulp插件： <code>npm install –g gulp</code><br>安装制作雪碧图需要的插件 <code>npm install –g gulp.spritesmith</code><br>最好全局和本地各装一遍；</p>\n<a id=\"more\"></a> \n<p>新建一个Gulpfile.js文件，将下列代码放进去：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> gulp=<span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);   <span class=\"comment\">//引入这两个gulp  gulp.spritesmith</span></div><div class=\"line\">    spritesmith=<span class=\"built_in\">require</span>(<span class=\"string\">'gulp.spritesmith'</span>);   </div><div class=\"line\">      gulp.task(<span class=\"string\">'default'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;   <span class=\"comment\">//新建名为sprite的任务</span></div><div class=\"line\">         gulp.src(<span class=\"string\">'images/*.png'</span>)  <span class=\"comment\">//需要合成的图片路径  *为通配符  表示这个文件夹下面所有后缀为.png的文件都会被应用</span></div><div class=\"line\">            .pipe(spritesmith(&#123;  </div><div class=\"line\">    <span class=\"attr\">imgName</span>:<span class=\"string\">'sprite.png'</span>,<span class=\"comment\">//合成后需要保存图片的路径 </span></div><div class=\"line\">    cssName:<span class=\"string\">'sprite.css'</span>,  <span class=\"comment\">//合成后需要保存的css的路径</span></div><div class=\"line\">    padding:<span class=\"number\">5</span>,  <span class=\"comment\">//表示两个图片间的空隙</span></div><div class=\"line\">    algorithm:<span class=\"string\">'binary-tree'</span>, <span class=\"comment\">// Algorithm 有四个可选值分别为top-down、left-right、diagonal、alt-diagonal、binary-tree</span></div><div class=\"line\">    <span class=\"comment\">// cssTemplate:'dist/handlebarsStr.css' //生成的css模板文件，可以是函数也可以是字符串</span></div><div class=\"line\">    &#125;))  </div><div class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist/'</span>)) <span class=\"comment\">//将生成的文件放到dist文件夹下 </span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>或者:进入项目 <code>npm init</code> 输入需要的信息,创建一个package.json文件:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &#123;</div><div class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"package.json\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"Gulpfile.js\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"dependencies\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"gulp\"</span>: <span class=\"string\">\"^3.9.1\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"gulp.spritesmith\"</span>: <span class=\"string\">\"^6.5.1\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">\"devDependencies\"</span>: &#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"test\"</span>: <span class=\"string\">\"echo \\\"Error: no test specified\\\" &amp;amp;&amp;amp; exit 1\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"license\"</span>: <span class=\"string\">\"ISC\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里提几点需要注意的：<br>需要一个Gulpfile.js（首字母小写也可以） ，运行时执行 gulp default（defaullt是你新建的任务名，不是固定的，你写成其他也行）<br><b>imgName:’sprite.png’</b>//合成后需要保存图片的路径<b>cssName:’sprite.css’</b><br>这两个文件需要你先创建，里面的文件都要预先创建;我这里是放在dist下面就要在dis下面创建这两个文件<br>合成的雪碧图；<br><img src=\"/images/sp-1.png\" alt=\"sp\"><br>css样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.icon-1</span>  &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(sprite.png);</div><div class=\"line\">  <span class=\"attribute\">background-position</span>: <span class=\"number\">0px</span> <span class=\"number\">0px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.icon-2</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(sprite.png);</div><div class=\"line\">  <span class=\"attribute\">background-position</span>: -<span class=\"number\">38px</span> <span class=\"number\">0px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.icon-3</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(sprite.png);</div><div class=\"line\">  <span class=\"attribute\">background-position</span>: <span class=\"number\">0px</span> -<span class=\"number\">38px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.icon-4</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(sprite.png);</div><div class=\"line\">  <span class=\"attribute\">background-position</span>: -<span class=\"number\">38px</span> -<span class=\"number\">38px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.icon-5</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(sprite.png);</div><div class=\"line\">  <span class=\"attribute\">background-position</span>: -<span class=\"number\">76px</span> <span class=\"number\">0px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.icon-6</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(sprite.png);</div><div class=\"line\">  <span class=\"attribute\">background-position</span>: -<span class=\"number\">76px</span> -<span class=\"number\">38px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.icon-7</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(sprite.png);</div><div class=\"line\">  <span class=\"attribute\">background-position</span>: <span class=\"number\">0px</span> -<span class=\"number\">76px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">33px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>algorithm：四个参数只是决定图片的排列顺序；<br>top-down：<br><img src=\"/images/sp-2.png\" alt=\"sp\"><br>具体的参数可以看这里：<br><img src=\"/images/sp-3.png\" alt=\"sp\"><br>好了,雪碧图就合成啦；<br>下面会讲讲如何使用雪碧图；<br>创建一个文件：index.html<br>引入生成的css<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">”stylesheet”</span> <span class=\"attr\">type</span>=<span class=\"string\">”text/css”</span> <span class=\"attr\">href</span>=<span class=\"string\">”./dist/sprite.css”</span> /&gt;</span></div></pre></td></tr></table></figure></p>\n<p>写基本架构：<b>class=”icon-1”</b> 这里是css里生成的样式名；按顺序写好就行; </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sprite\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">s</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">s</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span>衣服<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">s</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">s</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span>鞋子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">s</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-3\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">s</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span>背包<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">s</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-4\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">s</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span>双肩包<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">s</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-5\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">s</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span>裤子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">s</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-6\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">s</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span>羽绒服<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">s</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon-7\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">s</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span>外套<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>给他们新增加一些样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ul</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">list-style</span>: none;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.sprite</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span> auto;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">206px</span>;</div><div class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#b51600</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.sprite</span> <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">42px</span>;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">206px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#b51600</span>;</div><div class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#911001</span>;</div><div class=\"line\">    <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#c11e08</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.sprite</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">a</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</div><div class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">42px</span>;</div><div class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">14px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>效果就是这样：<br><img src=\"/images/sp-3.png\" alt=\"sp\"><br>引入了css文件，class也改动了，怎么没有图标呢？<br><img src=\"/images/sp-4.png\" alt=\"sp\"><br>生成的css文件里面就告诉你了，让标签<code>dispay:block</code>;</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.sprite</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">s</span>&#123;      </div><div class=\"line\">          <span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">          <span class=\"attribute\">margin-left</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">          <span class=\"attribute\">margin-right</span>: <span class=\"number\">8px</span>;</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p>看看效果：<br><img src=\"/images/sp-5.png\" alt=\"sp\"></p>\n","comments":true,"categories":[{"name":"CSS","slug":"CSS","permalink":"http://www.sulishibaobei.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.sulishibaobei.com/tags/CSS/"},{"name":"雪碧图","slug":"雪碧图","permalink":"http://www.sulishibaobei.com/tags/雪碧图/"},{"name":"gulp","slug":"gulp","permalink":"http://www.sulishibaobei.com/tags/gulp/"}]},{"title":"关于个人博客的搭建","date":"2017-09-06T03:08:53.000Z","path":"index20170906/","text":"博客前生[博客基本搭建]http://www.cnblogs.com/sulishibaobei/p/6428241.html, 这是用的yilia主题之前是将博客托管在github上，运行http://sulishibaobei.github.io 即可以访问，如果你只是初步尝试，建议看这个，教你10分钟搭建一个属于自己的博客 博客今世1.在阿里云上购买了一个域名：www.sulishibaobei.com ,将域名解析到sulishibaobei.github.io上，现在我的博客访问地址就是www.sulishibaobei.com;这样访问http://sulishibaobei.github.io 将会重定向到http://www.sulishibaobei.com 上;2.给博客重新更换了主题：next;方法还是和之前更换yilia主题一样，github上将想要的主题下载好，放置在Themes文件夹下面,更换站点根目录的_config.yml文件下的theme: next3.hexo clean ,hexo g,hexo d ;这三步重新编译，这样你的博客就焕然一新了;不一定要是这两个主题，因为配置都是大同小异,只是因为Next里面继承了许多的功能比较全，像我这么懒惰的人就用它了; 博客最基本配置主题更换好以后，怎么让主题的功能更突出就需要操作主题里面的_config.yml文件了,是主题下的文件; 1.菜单栏menu的配置找到主题配置文件_config.yml中的的menu,大概是这样一段代码：123456789101112menu: 主页: / || home 关于: /about/ || user 标签: /tags/ || tags 归档: /archives/ || archive 展示: /site/ || th 日程: /schedule/ || calendar 有料 : /something 公益404: /404.html || heartbeatmenu_icons: enable: true blog:/images/1.jpg 注：你下载下来的是英文的,根据你的习惯,喜欢中文就切换成中文的;本来主题就提供了配置语言的,在next主题的languages里面,我们只需要配置即可；在根站点的_config.yml文件中配置language: zh-Hans表示你要使用的是中文,配置了这一句就不用像我这样手动修改;有可能你并不需要像我这么多项，根据自己的需求进行配置，其实就是将它#注释的地方去掉注释就行关于图标前面的图标,你不写的话，就会采用主题默认的,例如：有料;主题里为我们提供的几种图标，例如：home,tags等;还有一类是你自己想自定义图标，menu_icons就是配置图标的,例如blog,在需要使用图标的||后面写上blog;但是关出现这些标签，怎么让标签点击到对于的页面这就需要我们去创建应的文件夹hexo new page tags 创建的文件夹名和配置的名字标签: /tags是一样的;新创建的文件夹会出现在source文件下，和_post文件夹同级,默认的文件是index.md,其中会只有这两行代码：1234---title: tagsdate: 2017-09-05 14:45:27--- 按照所需的数量，依次创建完成好，最基本的菜单栏就完成了; 2.header和个人内容介绍的配置 这个是在站点根目录_config.yml配置的，在这个文件里面配置的内容即便更换主题，这些内容也不会改变，只是显示位置不一样；找到site 12345678# Site 网站title: 少女雨的博客subtitle: 爱生活爱远方爱自由更爱你description: 12级毕业生，南方姑娘，前端程序媛，前途堪忧的代码洁癖者;author: 少女雨email: 380571249@qq.comkeywords: \"前端,js,jquery,javascript,html5,开发者,程序媛，typescript,angular，校园java醋虐者\"language: zh-Hans 填上你的个人信息，这块就算完成了 3.标签页的配置Category &amp; Tag这块的配置也是在站点根目录_config.yml下的；1234#default_category: uncategorizedcategory_map: 分类tag_map: 标签archives_map: 日志 找到这一部分,配置就行,但是怎么和你博客的内容关联起来这需要这样配置：例如：想让标签和博客文章关联起来，找到source文件下的tags文件index.md文件，添加这一句：12345---title: date: 2017-09-01 11:07:25type: \"tags\"--- 告诉主题，你想关联tags其他的关于category_map等也是这样配置的;关于这一部分标签如何配置，建议参看这篇文章，戳这里 4. 社交连接,Rss,友链配置这一部分是在主题文件下的_config.yml里面配置：找到这一块rss:false：禁用 RSS，不在页面上显示 RSS 连接。留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。具体的链接地址：适用于已经烧制过 Feed 的情形。社交链接，找到这个social12345678910111213141516171819social: GitHub : https://github.com/sulishibaobei/ || github E-Mail : 380571249@qq.com || envelope weibo : http://weibo.com/xiaoyu051027/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo/ || weibo CSDN : http://blog.csdn.net/sulishibaobei/ CSDN 博客园 : http://www.cnblogs.com/sulishibaobei/ 简书 : http://www.jianshu.com/u/e6c53e37e95b/ #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false 根据你自己的想法，换上自己链接配置就行，图标和上面介绍的Menu是一样的；友链，找到这个links_title123456# Blog rolls 友情链接links_title: 友情链接#links_layout: block#links_layout: inlinelinks: Angular 4.x 修仙之路 : https://segmentfault.com/blog/angular4 填上自己的就行，配置多个在链接那里添加就行；基本上博客雏形就配置完成了; 5.基本配置还有一些关于主题选择，字体配置的小细节，请看 博客内容完善阅读量统计这部分是采用leanCloud实现的，推荐一篇写的好的文章,戳这里 访客量统计这部分采用不蒜子统计统计找到这一部分：123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt;本站访客数 site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; 本站总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=\"fa fa-file-o\"&gt;&lt;/i&gt; 本文总阅读量 page_pv_footer: 次 评论系统我才用的是有言评论，localhost时候会失败，但是采用http页面评论时会成功;配置看这里next如果你是Next主题5.1以上的版本，只需要注册，然后将Uid号填在主题文件下的_config.yml从多说不能用的时候，facebook也不能用，DISQUS，HyperComments是国外的，请求不一定会成功；使用畅言需要备案，除非你的网站备案了，否则也不行；来必力尝试过也不行，选择友言是比较合理的； 搜索服务和百度统计搜索采用的是：Local Search ;配置可以看这里 博客收录如何将让自己的博客在搜索引擎被搜索到：看这里 博客小功能如何点击的时候出现桃心，如何更换链接颜色等看这里 关于后续有一些基本的配置,很难一个一个写出来;如果看到其他的功能,而我没有写出来的，欢迎给我私信;","content":"<p><img src=\"/images/fengjing-1.jpg\" alt=\"fengjing\"><br><a id=\"more\"></a></p>\n<h2 id=\"博客前生\"><a href=\"#博客前生\" class=\"headerlink\" title=\"博客前生\"></a>博客前生</h2><p>[博客基本搭建]<a href=\"http://www.cnblogs.com/sulishibaobei/p/6428241.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/sulishibaobei/p/6428241.html</a>, 这是用的yilia主题<br>之前是将博客托管在github上，运行<a href=\"http://sulishibaobei.github.io\" target=\"_blank\" rel=\"external\">http://sulishibaobei.github.io</a> 即可以访问，如果你只是初步尝试，建议看这个，教你10分钟搭建一个属于自己的博客</p>\n<h2 id=\"博客今世\"><a href=\"#博客今世\" class=\"headerlink\" title=\"博客今世\"></a>博客今世</h2><p>1.在阿里云上购买了一个域名：www.sulishibaobei.com ,将域名解析到sulishibaobei.github.io上，现在我的博客访问地址就是<a href=\"http://www.sulishibaobei.com\">www.sulishibaobei.com</a>;<br>这样访问<a href=\"http://sulishibaobei.github.io\" target=\"_blank\" rel=\"external\">http://sulishibaobei.github.io</a> 将会重定向到<a href=\"http://www.sulishibaobei.com\">http://www.sulishibaobei.com</a> 上;<br>2.给博客重新更换了主题：next;方法还是和之前更换yilia主题一样，github上将想要的主题下载好，放置在<b>Themes</b>文件夹下面,更换站点根目录的<b>_config.yml</b>文件下的<b>theme: next</b><br>3.<b>hexo clean </b>,<b>hexo g</b>,<b>hexo d ;</b>这三步重新编译，这样你的博客就焕然一新了;<br>不一定要是这两个主题，因为配置都是大同小异,只是因为Next里面继承了许多的功能比较全，像我这么懒惰的人就用它了;</p>\n<h2 id=\"博客最基本配置\"><a href=\"#博客最基本配置\" class=\"headerlink\" title=\"博客最基本配置\"></a>博客最基本配置</h2><p>主题更换好以后，怎么让主题的功能更突出就需要操作主题里面的<b>_config.yml</b>文件了,是主题下的文件;</p>\n<h3 id=\"1-菜单栏menu的配置\"><a href=\"#1-菜单栏menu的配置\" class=\"headerlink\" title=\"1.菜单栏menu的配置\"></a>1.菜单栏<b>menu</b>的配置</h3><p><img src=\"/images/theme-1.png\" alt=\"menu\"><br>找到主题配置文件<b>_config.yml</b>中的的menu,大概是这样一段代码：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu:</div><div class=\"line\">  主页: / || home</div><div class=\"line\">  关于: /about/ || user</div><div class=\"line\">  标签: /tags/ || tags</div><div class=\"line\">  归档: /archives/ || archive</div><div class=\"line\">  展示: /site/ || th</div><div class=\"line\">  日程: /schedule/ || calendar</div><div class=\"line\">  有料 : /something</div><div class=\"line\">  公益404: /404.html || heartbeat</div><div class=\"line\">menu_icons:</div><div class=\"line\">  enable: true</div><div class=\"line\">  blog:/images/1.jpg</div></pre></td></tr></table></figure></p>\n<p>注：你下载下来的是英文的,根据你的习惯,喜欢中文就切换成中文的;本来主题就提供了配置语言的,在next主题的languages里面,我们只需要配置即可；<br>在根站点的_config.yml文件中配置<b>language: zh-Hans</b>表示你要使用的是中文,配置了这一句就不用像我这样手动修改;<br>有可能你并不需要像我这么多项，根据自己的需求进行配置，其实就是将它#注释的地方去掉注释就行<br>关于图标前面的图标,你不写的话，就会采用主题默认的,例如：有料;主题里为我们提供的几种图标，例如：home,tags等;还有一类是你自己想自定义图标，<br>menu_icons就是配置图标的,例如blog,在需要使用图标的||后面写上blog;<br>但是关出现这些标签，怎么让标签点击到对于的页面这就需要我们去创建应的文件夹<b>hexo new page tags</b>  创建的文件夹名和配置的名字标签: /tags是一样的;<br>新创建的文件夹会出现在source文件下，和_post文件夹同级,默认的文件是index.md,其中会只有这两行代码：<br><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: tags</div><div class=\"line\"><span class=\"section\">date: 2017-09-05 14:45:27</span></div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>按照所需的数量，依次创建完成好，最基本的菜单栏就完成了;</p>\n<h3 id=\"2-header和个人内容介绍的配置\"><a href=\"#2-header和个人内容介绍的配置\" class=\"headerlink\" title=\"2.header和个人内容介绍的配置\"></a>2.<b>header</b>和个人内容介绍的配置</h3><p> <img src=\"/images/theme-3.png\" alt=\"header\"><br> <img src=\"/images/theme-4.png\" alt=\"themes\"><br>这个是在<b>站点根目录_config.yml</b>配置的，在这个文件里面配置的内容即便更换主题，这些内容也不会改变，只是显示位置不一样；找到<b>site</b></p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\"># Site 网站</span></div><div class=\"line\">title: 少女雨的博客</div><div class=\"line\">subtitle: 爱生活爱远方爱自由更爱你</div><div class=\"line\">description: 12级毕业生，南方姑娘，前端程序媛，前途堪忧的代码洁癖者;</div><div class=\"line\">author: 少女雨</div><div class=\"line\">email: 380571249@qq.com</div><div class=\"line\">keywords: \"前端,js,jquery,javascript,html5,开发者,程序媛，typescript,angular，校园java醋虐者\"</div><div class=\"line\">language: zh-Hans</div></pre></td></tr></table></figure>\n<p>填上你的个人信息，这块就算完成了</p>\n<h3 id=\"3-标签页的配置Category-amp-Tag\"><a href=\"#3-标签页的配置Category-amp-Tag\" class=\"headerlink\" title=\"3.标签页的配置Category &amp; Tag\"></a>3.标签页的配置Category &amp; Tag</h3><p><img src=\"/images/theme-5.png\" alt=\"tag\"><br>这块的配置也是在站点根目录_config.yml下的；<br><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\">#default_category: uncategorized</span></div><div class=\"line\">category_map: 分类</div><div class=\"line\">tag_map:  标签</div><div class=\"line\">archives_map: 日志</div></pre></td></tr></table></figure></p>\n<p>找到这一部分,配置就行,但是怎么和你博客的内容关联起来这需要这样配置：<br>例如：想让标签和博客文章关联起来，找到source文件下的tags文件index.md文件，添加这一句：<br><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title:  </div><div class=\"line\">date: 2017-09-01 11:07:25</div><div class=\"line\"><span class=\"section\">type: \"tags\"</span></div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>告诉主题，你想关联tags<br>其他的关于category_map等也是这样配置的;<br>关于这一部分标签如何配置，建议参看这篇文章，<a href=\"https://hexo.io/zh-cn/docs/front-matter.html#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE\" target=\"_blank\" rel=\"external\">戳这里</a></p>\n<h3 id=\"4-社交连接-Rss-友链配置\"><a href=\"#4-社交连接-Rss-友链配置\" class=\"headerlink\" title=\"4. 社交连接,Rss,友链配置\"></a>4. 社交连接,Rss,友链配置</h3><p><img src=\"/images/theme-6.png\" alt=\"links\"><br>这一部分是在主题文件下的_config.yml里面配置：<br>找到这一块rss:<br>false：禁用 RSS，不在页面上显示 RSS 连接。<br>留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。<br>具体的链接地址：适用于已经烧制过 Feed 的情形。<br>社交链接，找到这个social<br><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">social:</div><div class=\"line\">  GitHub : https://github.com/sulishibaobei/ || github</div><div class=\"line\">  E-Mail : 380571249@qq.com || envelope</div><div class=\"line\">  weibo :  http://weibo.com/xiaoyu051027/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo/ || weibo </div><div class=\"line\">  CSDN :   http://blog.csdn.net/sulishibaobei/  CSDN</div><div class=\"line\">  博客园 :  http://www.cnblogs.com/sulishibaobei/    </div><div class=\"line\">  简书 :    http://www.jianshu.com/u/e6c53e37e95b/ </div><div class=\"line\">  #Google: https://plus.google.com/yourname || google</div><div class=\"line\">  #Twitter: https://twitter.com/yourname || twitter</div><div class=\"line\">  #FB Page: https://www.facebook.com/yourname || facebook</div><div class=\"line\">  #VK Group: https://vk.com/yourname || vk</div><div class=\"line\">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</div><div class=\"line\">  #YouTube: https://youtube.com/yourname || youtube</div><div class=\"line\">  #Instagram: https://instagram.com/yourname || instagram</div><div class=\"line\">  #Skype: skype:yourname?call|chat || skype</div><div class=\"line\">social_icons:</div><div class=\"line\">  enable: true</div><div class=\"line\">  icons_only: false</div><div class=\"line\">  transition: false</div></pre></td></tr></table></figure></p>\n<p>根据你自己的想法，换上自己链接配置就行，图标和上面介绍的Menu是一样的；<br>友链，找到这个links_title<br><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\"># Blog rolls  友情链接</span></div><div class=\"line\">links_title: 友情链接</div><div class=\"line\"><span class=\"section\">#links_layout: block</span></div><div class=\"line\"><span class=\"section\">#links_layout: inline</span></div><div class=\"line\">links:</div><div class=\"line\">  Angular 4.x 修仙之路 : https://segmentfault.com/blog/angular4</div></pre></td></tr></table></figure></p>\n<p>填上自己的就行，配置多个在链接那里添加就行；<br>基本上博客雏形就配置完成了;</p>\n<h3 id=\"5-基本配置\"><a href=\"#5-基本配置\" class=\"headerlink\" title=\"5.基本配置\"></a>5.基本配置</h3><p>还有一些关于主题选择，字体配置的小细节，<a href=\"http://theme-next.iissnan.com/theme-settings.html\" target=\"_blank\" rel=\"external\">请看</a></p>\n<h2 id=\"博客内容完善\"><a href=\"#博客内容完善\" class=\"headerlink\" title=\"博客内容完善\"></a>博客内容完善</h2><h3 id=\"阅读量统计\"><a href=\"#阅读量统计\" class=\"headerlink\" title=\"阅读量统计\"></a>阅读量统计</h3><p><img src=\"/images/theme-7.png\" alt=\"yuedu\"><br>这部分是采用<a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"external\">leanCloud</a>实现的，推荐一篇写的好的文章,<a href=\"https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud\" target=\"_blank\" rel=\"external\">戳这里</a></p>\n<h3 id=\"访客量统计\"><a href=\"#访客量统计\" class=\"headerlink\" title=\"访客量统计\"></a>访客量统计</h3><p><img src=\"/images/theme-8.png\" alt=\"yuedu\"><br>这部分采用不蒜子统计统计<br>找到这一部分：<br><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">busuanzi_count:</div><div class=\"line\">  # count values only if the other configs are false</div><div class=\"line\">  enable: true</div><div class=\"line\">  # custom uv span for the whole site</div><div class=\"line\">  site_uv: true</div><div class=\"line\">  site<span class=\"emphasis\">_uv_</span>header: &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt;本站访客数</div><div class=\"line\">  site<span class=\"emphasis\">_uv_</span>footer: 人次</div><div class=\"line\">  # custom pv span for the whole site</div><div class=\"line\">  site_pv: true</div><div class=\"line\">  site<span class=\"emphasis\">_pv_</span>header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; 本站总访问量</div><div class=\"line\">  site<span class=\"emphasis\">_pv_</span>footer: 次</div><div class=\"line\">  # custom pv span for one page only</div><div class=\"line\">  page_pv: true</div><div class=\"line\">  page<span class=\"emphasis\">_pv_</span>header: &lt;i class=\"fa fa-file-o\"&gt;&lt;/i&gt; 本文总阅读量</div><div class=\"line\">  page<span class=\"emphasis\">_pv_</span>footer: 次</div></pre></td></tr></table></figure></p>\n<h3 id=\"评论系统\"><a href=\"#评论系统\" class=\"headerlink\" title=\"评论系统\"></a>评论系统</h3><p>我才用的是有言评论，localhost时候会失败，但是采用http页面评论时会成功;配置看这里<a href=\"http://www.jianshu.com/p/4729e92fddbe\" target=\"_blank\" rel=\"external\">next</a><br>如果你是Next主题5.1以上的版本，只需要注册，然后将Uid号填在主题文件下的_config.yml<br>从多说不能用的时候，facebook也不能用，DISQUS，HyperComments是国外的，请求不一定会成功；<br>使用畅言需要备案，除非你的网站备案了，否则也不行；来必力尝试过也不行，选择友言是比较合理的；</p>\n<h3 id=\"搜索服务和百度统计\"><a href=\"#搜索服务和百度统计\" class=\"headerlink\" title=\"搜索服务和百度统计\"></a>搜索服务和百度统计</h3><p>搜索采用的是：Local Search ;<br>配置可以看<a href=\"http://theme-next.iissnan.com/third-party-services.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h3 id=\"博客收录\"><a href=\"#博客收录\" class=\"headerlink\" title=\"博客收录\"></a>博客收录</h3><p>如何将让自己的博客在搜索引擎被搜索到：<a href=\"http://www.jianshu.com/p/df46bca5889d\" target=\"_blank\" rel=\"external\">看这里</a></p>\n<h3 id=\"博客小功能\"><a href=\"#博客小功能\" class=\"headerlink\" title=\"博客小功能\"></a>博客小功能</h3><p>如何点击的时候出现桃心，如何更换链接颜色等<a href=\"http://blog.csdn.net/qq_33699981/article/details/72716951\" target=\"_blank\" rel=\"external\">看这里</a></p>\n<h2 id=\"关于后续\"><a href=\"#关于后续\" class=\"headerlink\" title=\"关于后续\"></a>关于后续</h2><p>有一些基本的配置,很难一个一个写出来;如果看到其他的功能,而我没有写出来的，欢迎给我私信;</p>\n","comments":true,"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.sulishibaobei.com/categories/Hexo/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://www.sulishibaobei.com/tags/node-js/"},{"name":"hexo","slug":"hexo","permalink":"http://www.sulishibaobei.com/tags/hexo/"},{"name":"next","slug":"next","permalink":"http://www.sulishibaobei.com/tags/next/"}]},{"title":"Angular 2+ 关于新版angular-cli的应用","date":"2017-09-06T03:08:53.000Z","path":"angular/angular-cli/angular-120170906/","text":"以前写过一个webstorm借助angular-cli搭建angular2.0项目的博客。 后来许久没有接触过angular，现在拾起来的时候发现已经更新，用法变了。所以来记录下，以免其他友看到照成误区。这也是说明一个道理，别人写下的东西你不一定适用，因为技术的东西说变就变，谁知道的。 [1]基于Node环境，安装angular-cli。&nbsp; 新版的已经变成安装@angular/cli。所以安装时：npm install -d @angular/cli 那么问题来了，一大堆错误，说缺少pathon和visual studio。还有说版本不兼容的，所以建议node的版本不要太高，也不用太低。第一次我用的7以上的版本说不支持。然后换成6.0以上也是不支持。最后换成6.9几用的好好的。并不是所有人的电脑安装都会出问题的。 既然说缺少pathon那就安装吧。推荐一个网友的解决办法，我也是参照这个解决的，就不重复啰嗦看这里;说到底会出错的原因都是因为npm是国外的，需要FQ，会有那么一丝丝不稳定。不过建议大家先安装cnpm在装，就什么问题都，没有了。npm install -g cnpmcnpm install -g @angular/cli ng命令安装好angular/cli之后，就可以用ng命令啦。例如：ng –version 查看版本号ng help 帮助 当然最重要的还是用它创建工程。ng new 工程名;然后会自动帮你创建所有的依赖，搭建成一个简单的模板，大概这样node-modules会自动帮你创建，只是耗时比较长，建议一次下载多次copy。运行项目试试，进入你的工程目录下，然后ng serve; 默认是开启localhost:4200的。所以浏览器里打开localhost:4200就可以啦。 这是最简单的项目啦，当然你可以继续创建命令 例如运行ng g c user 它是四个四个创建的，配套吗！！ 后续介绍一篇文章专门讲angular-cli的这些文件工程太大了，运行时可以打压，ng serve --prod --aot 也是可以的。好了就介绍这些基础的，其实后面的使用并没有改变太多啦之前在博客园中也介绍过关于在webstorm中如何开发angular项目，如果想在webstorm中使用，可以去看看目前我使用VScode ，觉得挺好的！！","content":"<p>以前写过一个webstorm借助angular-cli搭建angular2.0项目的博客。 后来许久没有接触过angular，现在拾起来的时候发现已经更新，用法变了。所以来记录下，以免其他友看到照成误区。这也是说明一个道理，别人写下的东西你不一定适用，因为技术的东西说变就变，谁知道的。</p>\n<h2 id=\"1-基于Node环境，安装angular-cli。-nbsp-新版的已经变成安装-angular-cli。所以安装时：npm-install-d-angular-cli\"><a href=\"#1-基于Node环境，安装angular-cli。-nbsp-新版的已经变成安装-angular-cli。所以安装时：npm-install-d-angular-cli\" class=\"headerlink\" title=\"[1]基于Node环境，安装angular-cli。&nbsp; 新版的已经变成安装@angular/cli。所以安装时：npm install -d @angular/cli\"></a>[1]基于Node环境，安装angular-cli。&nbsp; 新版的已经变成安装@angular/cli。所以安装时：<code>npm install -d @angular/cli</code></h2><a id=\"more\"></a>\n<p>那么问题来了，一大堆错误，说缺少pathon和visual studio。还有说版本不兼容的，所以建议node的版本不要太高，也不用太低。第一次我用的7以上的版本说不支持。然后换成6.0以上也是不支持。最后换成6.9几用的好好的。并不是所有人的电脑安装都会出问题的。 既然说缺少pathon那就安装吧。推荐一个网友的解决办法，我也是参照这个解决的，就不重复啰嗦<a href=\"http://www.cnblogs.com/liangxiaojie/p/4595406.html\" target=\"_blank\" rel=\"external\">看这里</a>;说到底会出错的原因都是因为npm是国外的，需要FQ，会有那么一丝丝不稳定。<br>不过建议大家先安装cnpm在装，就什么问题都，没有了。<br><code>npm install -g cnpm</code><br><code>cnpm install -g @angular/cli</code></p>\n<h2 id=\"ng命令\"><a href=\"#ng命令\" class=\"headerlink\" title=\"ng命令\"></a>ng命令</h2><p>安装好angular/cli之后，就可以用ng命令啦。<br>例如：ng –version 查看版本号<br>ng help 帮助 </p>\n<p><strong>当然最重要的还是用它创建工程。ng new 工程名;</strong><br>然后会自动帮你创建所有的依赖，搭建成一个简单的模板，大概这样<br><img src=\"/images/angular-1.png\" alt=\"angular-cli\"><br>node-modules会自动帮你创建，只是耗时比较长，建议一次下载多次copy。<br>运行项目试试，进入你的工程目录下，然后ng serve; 默认是开启localhost:4200的。<br>所以浏览器里打开localhost:4200就可以啦。</p>\n<p><img src=\"/images/angular-2.png\" alt=\"angular-cli\"><br>这是最简单的项目啦，当然你可以继续创建命令 </p>\n<p><img src=\"/images/angular-3.png\" alt=\"angular-cli\"><br>例如运行<code>ng g c user</code></p>\n<p><img src=\"/images/angular-4.png\" alt=\"angular-cli\"><br>它是四个四个创建的，配套吗！！ 后续介绍一篇文章专门讲<a href=\"http://blog.csdn.net/sulishibaobei/article/details/77246482\" target=\"_blank\" rel=\"external\">angular-cli</a>的<br>这些文件工程太大了，运行时可以打压，<code>ng serve --prod --aot</code> 也是可以的。<br>好了就介绍这些基础的，其实后面的使用并没有改变太多啦<br>之前在博客园中也介绍过关于在webstorm中如何开发angular项目，如果想在webstorm中使用，可以去看看<br>目前我使用VScode ，觉得挺好的！！</p>\n","comments":true,"categories":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/categories/Angular-2/"}],"tags":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/tags/Angular-2/"},{"name":"Angular-cli","slug":"Angular-cli","permalink":"http://www.sulishibaobei.com/tags/Angular-cli/"},{"name":"工具","slug":"工具","permalink":"http://www.sulishibaobei.com/tags/工具/"}]},{"title":"前端面试中遇见的那些纯js题","date":"2017-09-05T03:08:53.000Z","path":"js/js120170905/","text":"js 定义类有哪些常用的方法？1.工厂方式12345678910111213function Car()&#123; var ocar=new Obejct; //不用括号 ocar.color='blue'; ocar.doors=4; ocar.showColor=function()&#123; this.color; &#125; return ocar;&#125;var car1=Car();var car2=Car();console.log(car1); //&#123;color: \"blue\", doors: 4, snowColor: ƒ&#125; f指的是function()console.log(car2); //&#123;color: \"blue\", doors: 4, snowColor: ƒ&#125; 注：1.调用此方法时，将创建新的对象，并赋予它所有的属性和方法。使用此函数可以创建两个属性完全相同的对象；2.我们可以通过给函数传递不同的参数来得到具有不同值得对象 12345678910111213function Car(color,door)&#123; var ocar=new Object; ocar.color=color; ocar.doos=door; ocar.showColor=function()&#123; console.log(this.color); &#125; return ocar;&#125;var car1=Car(\"red\",5);var car2=car(\"blue\",4);car1.showColor(); //red；car2.showColor(); //blue 在上面的两个例子中，每次创建一个Car()对象都会创建一个showColor()，意味着每个对象都有自己的showcolor()方法，但是实际上每个对象可以共享同一个函数，最后通过将函数的属性指向该方法* 123456789101112function showColor()&#123; console.log(this.color); &#125; function Car(color,door)&#123; var ocar=new Object(); ocar.color=color; ocar.doors=door; ocar.showColor=showColor; return ocar; &#125; var car1=new Car('red',4); car1.showColor(); 当然这里扯远了 2.构造函数方法这个和工厂方式差不多 1234567891011function Car(color,door)&#123; this.color=color; this.doors=door; this.showColor=function()&#123; console.log(this.color); &#125; &#125; var car1=new Car(\"red\",4); var car2=new Car(\"blue\",5); car1.showColor();//red car2.showColor();//blue 注：这种模式和工厂的方式区别在于，不用通过自己去New一个对象，而是使用this关键字；因为在调用构造函数时就已经创建了对象，而在函数内部只能通过this来访问此对象但是，它和工厂方式一样，每次调用对象都会创建自己的方法 3.原型方式该方式利用了对象的prototype属性，首先用空函数创建类名，然后所有的属性和方法都被赋予prototype属性； 12345678910function Car()&#123;&#125;Car.prototype.color=\"red\";Car.prototype.doors=4;Car.prototype.showColor=function()&#123; console.log(this.color);&#125;var car1=new Car();var car2=new Car(); console.log(car1); 看看最后输出的是什么注：1.首先定义一个空函数，然后通过prototype属性来定义对象的属性；调用该函数时，原型的所有属性都会立即赋予要创建的对象，所有该函数的对象存放的对是指向showColor()的指针，语法上看起来都属于同一个对象；2.但是这个函数没有参数，不能通过传参来初始化属性，必须要在对象创建后才能改变属性的默认值；3.原型方式还有个很大的弊端；如果属性指向的是对象时： 12345678910111213function Car()&#123;&#125;Car.prototype.color=\"red\";Car.prototype.doors=4;Car.prototype.arr=new Array('a',\"b\");Car.prototype.showColor=function()&#123; console.log(this.color);&#125;var car1=new Car();var car2=new Car();car1.arr.push('cc');console.log(car1.arr); //(3) [\"a\", \"b\", \"cc\"]console.log(car2.arr); //(3) [\"a\", \"b\", \"cc\"] 注：arr对象指向的是一个数组，这里用的是数组的引用值，Car的两个对象指向的都是同一个数组所以car1添加值以后，在car2中也能看到值；形式是这样的： 4.联合方式（构造函数+原型方式)1234567891011121314function Car(color,door)&#123; this.color=color; this.doors=door; this.arr=new Array(\"aa\",\"bb\"); &#125;; Car.prototype.showColor=function()&#123; console.log(this.color); &#125; var car1=new Car(\"red\",4); var car2=new Car(\"blue\",5); car1.arr.push(\"cc\"); console.log(car1); console.log(car1.arr); // (3) [\"aa\", \"bb\", \"cc\"] console.log(car2.arr); //(2) [\"aa\", \"bb\"] 首先来看看car1对象注：1.car1和car2对象都有自己单独的arr属性，所以改变其中一个另一个并不会受影响2.此方式是用构造函数定义对象的非函数属性，用原型对象定义对象的方法 5.动态原型方式和混合模式相似，区别就是赋予对象方法的位置不一样； 12345678910111213141516function Car(color,door)&#123; this.color=color; this.doors=door; this.arr=new Array(\"aa\",\"bb\"); if(typeof Car._initialized ==\"undefined\")&#123; Car.prototype.showColor=function()&#123; console.log(this.color); &#125;; Car._initialized=true; &#125;;&#125;var car1=new Car('blue',3);var car2=new Car('red',3);car1.showColor();car2.showColor();console.log(car1); 注：此方法是用一个标志来判断是否已经给原型赋予了此方法，这样可以保证该方法只被创建一次 6.混合工厂方式目的是创建假构函数，只返回另一种对象的新实例 123456789101112function Car()&#123; var ocar=new Object();//带括号 ocar.color=\"red\"; ocar.doors=4; ocar.showColor=function()&#123; console.log(this.color); &#125; return ocar;&#125;var car1=new Car();var car2=new Car();car1.showColor(); //red 注：和工厂方式很像，不通的就是这是通过New运算符 7.对象直接量采用set get的方式 123456789101112var car1=&#123; color:\"\", getColor: function()&#123; console.log(this.color); //red return this.color; &#125;, setColor:function(color)&#123; this.color=color; &#125;&#125;car1.setColor('red');car1.getColor(); 8.定义函数对象1234567891011121314var car2=new Function(); //注意大写car2.prototype = &#123; color:\"\", getColor:function()&#123; console.log(this.color);//blue return this.color; &#125;, setColor:function(color)&#123; this.color=color; &#125;&#125;car2.prototype.setColor('blue');car2.prototype.getColor();console.log(car2.prototype);//&#123;color: \"blue\", getColor: ƒ, setColor: ƒ&#125; 也是运用上面的原型方式和混合工厂模式 js类继承的方法有哪些既然是继承，首先得有个父类 12345678910111213//定义一个动物类 function Animal(name)&#123; //给一个Name属性 this.name=name || 'Animal'; //实例方法 this.sleep=function()&#123; console.log(this.name+\" 在睡觉\")； &#125; &#125; //原型方法 Animal.prototype.eat=function(food)&#123; console.log(this.name + '正在吃' +food); &#125; 原型链继承核心： 将父类的实例作为子类的原型 12345678910function Cat()&#123;&#125;Cat.prototype=new Animal();Cat.prototype.name='cat';var cat=new Cat();console.log(cat.name); //catconsole.log(cat.eat('fish')); //cat正在吃fishconsole.log(cat.sleep()); //cat 在睡觉console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 注：使用的的原型方式；特点: 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法和原型属性，子类都能访问 简单，易于实现 缺点: 要想为子类新增方法和属性，必须要在new Animal()这样的语句指向之后，不能放在构造器中； 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 12var cat1=new Cat()console.log(cat1.name) //cat 构造继承 call（）123456789function Cat(name)&#123; Animal.call(this); this.name=name || 'Animal';&#125;var cat=new Cat('cat');console.log(cat.name); //catconsole.log(cat.sleep()); //cat 在睡觉console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 注：这里是调用不到eat原型方法的;特点: 解决了1中，子类实例共享父类引用属性的问题； 创建实例时，可以向父类传参； 可以实现多继承（call 多个父类对象); 缺点: 实例并不是父类的实例 只能继承父类的实例和方法，并不能继承原型属性和方法； 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承 instace核心： 为父类实例添加新特性，作为子类实例返回 12345678910 function Cat(name)&#123; var instace=new Animal(); instace.name=name || 'Animal'; return instace; &#125;var cat=new Cat();console.log(cat.name); //Animalconsole.log(cat.sleep()); //Animal 在睡觉console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点:不限制调用方法，不管是new 子类()还是子类(),返回的对象具有相同的效果；缺点:1.实例是父类的实例，不是子类的实例;2.不支持多继承 拷贝继承123456789101112 function Cat(name)&#123; var animal=new Animal(); for(var p in animal)&#123; Cat.prototype[p]=animal[p]; &#125; Cat.prototype.name=name || 'Tom'; &#125;var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点:支持多继承;缺点: 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 12345678910function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 1.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 2.既是子类的实例，也是父类的实例 3.不存在引用属性共享问题 4.可传参 5.函数可复用缺点：调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 1234567891011121314151617function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点:堪称完美缺点: 实现较为复杂 数组去重给定无序数组，要求去除数组中的重复数组，并且返回新的无重复数组ES6写法： 123var array=[1,2,3,5,2,4,1,9,8];Array.from(new Set(array));console.log(Array.from(new Set(array)));//(7) [1, 2, 3, 5, 4, 9, 8] ES5写法： 12345678910111213console.log(uniqueArray(array));//(7) [1, 2, 3, 5, 4, 9, 8]function uniqueArray(array)&#123; var hashmap=&#123;&#125;; var unique=[]; for(var i=0;i&lt;array.length;i++)&#123; //hasOwnProperty boolean 用于表示一个对象本身是否具有指定名称的属性值 if(!hashmap.hasOwnProperty([array[i]]))&#123; hashmap[array[i]]=1; unique.push(array[i]); &#125; &#125; return unique;&#125; js类多重继承的实现方法是怎么样的其实就是第二部分的代码；1.call/apply 123456789101112131415161718var s1 = function(name)&#123; this.name = name; //专门存放名字的&#125;var s2 = function(sex)&#123; this.sex = sex; //专门存放性别的的&#125;var s3 = function(age)&#123; this.age = age; //专门存放年纪的&#125;var Student = function(name, sex, age, score)&#123; s1.call(this, name); s2.call(this, sex); s3.call(this, age); this.score = score;&#125;Student.prototype.constructor = Student;var s = new Student('jack', 'male', '12', '100');console.log(s.name+\" \"+s.age+ \" \" + s.age+\" \"+ s.score);//jack 12 12 100 1.使用call()实现多重继承，核心就是用Function类的call方法去绑定新的类，使新的类实例化后的对象继承了该属性及方法2.这样我们就可以根据各个不同的功能模块分不同程序员独立开发，最后合并起来，实现了多重继承。3.但它的缺点是基类的方法只能定义在类中，这样在每次实例化的时候都会创建该方法，造成多余内存占用这也是我们上面的构造继承的缺点 2.原型链继承 1234567891011121314151617181920var s1 = function()&#123;&#125;s1.prototype.getName = function()&#123;alert(this.name)&#125;;var s2 = function()&#123;&#125;s2.prototype =new s1();s2.prototype.constructor = s2;s2.prototype.getSex = function()&#123;alert(this.sex)&#125;;var s3 = function()&#123;&#125;s3.prototype = new s2();s3.prototype.constructor = s3;s3.prototype.getAge = function()&#123;alert(this.age)&#125;;var s = new s3();s.name = 'jack';s.sex = 'male';s.age = '22';s.getName();//jacks.getSex();//males.getAge();//22 出现代码冗余，而且无法传递参数 3.混合模式继承就是将上面的两种方式进行结合，扬长避短； 12345678910111213141516171819202122232425var s1 = function(name)&#123;this.name = name;&#125;s1.prototype.getName = function()&#123;alert(this.name)&#125;;var s2 = function(sex)&#123;this.sex = sex;&#125;s2.prototype =new s1();s2.prototype.getSex = function()&#123;alert(this.sex)&#125;;var s3 = function(age)&#123;this.age = age&#125;s3.prototype = new s2();s3.prototype.getAge = function()&#123;alert(this.age)&#125;;var s4 = function(name, sex, age)&#123;s1.call(this, name);s2.call(this, sex);s3.call(this, age);&#125;s4.prototype = new s3();s4.prototype.constructor = s4;var s = new s4('jack', 'male', '25');s.getName();//jacks.getSex();//males.getAge();//25 1.属性用构造的方法，方法采用原型模式；大大提高了效率 js中的作用域是什么样子的变量作用域全局变量的作用域：全局，在代码定义的任何地方都是有定义的；局部变量和函数的参数只有在函数体内才有定义另外，局部变量的优先级要高于同名的全局变量，也就是说当局部变量与全局变量重名时，局部变量会覆盖全局变量； 123456var num = 1; //声明一个全局变量function func() &#123; var num = 2; //声明一个局部变量 return num;&#125;console.log(func()); //输出：2 注：声明局部变量时一定要使用var,否则，解释器会将该变量当做全局对象window的属性。 函数作用域在JavaScript中函数作用域（变量在声明它们的函数体以及这个函数体嵌套的任意函数体都是有定义的） 123456function func() &#123; console.log(num); //输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的 var num = 1; //声明num 在整个函数体func内都有定义 console.log(num); //输出：1 &#125; func(); JavaScript的函数作用域是指在在函数内声明的所有变量在函数体内始终是可见的，也就是说在函数体内变量声明之前就已经可用了作为属性的变量，当声明一个全局变量的时候，实际上是定义了全局对象window的一个属性 12var num = 1; //声明全变量num alert(window.num) //输出：1 声明的全局变量实际上就是声明了一个window对象的属性 js中的this指的是什么1.在全局作用域时：this指向window 1console.log(this === window); //true 因此,我们在全局作用域声明的变量也会指向this 123var x = 1;console.log(this.x);//1console.log(window.x);//1 2.当在函数中时,this指向调用函数的那个对象。 1234567var x = 0;function num()&#123; this.x = 1;&#125;console.log(this.x);//0num();console.log(this.x);//1 这里就是经常容易犯得错误，很多人觉得，当this已经在一个function之中时，其目前所处位置为当前的局部作用域，所以目前指向的应该是此函数 但是，如果你将这个函数实例化（new）之后，此函数将生成一个全新的环境，此时在此实例中的this也会随之发生变化，它将指向所在实例。首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代; 12345678num = \"0\";function setThis()&#123; this.num = \"1\";&#125;console.log(this.num);//\"0\"new setThis();console.log(this.num);//\"0\"console.log(new setThis().num);//1 另外，在我们写javascript的时候，我们通常还会有一种调用函数的方法，即为元素绑定事件，比如button.addEventListener(‘click’, fn, false)等，如果在fn里面需要使用到this的话，那么此时this指向事件处理元素，也就是button 3.作为对象调用时,this 指代上级对象 1234567function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 总之：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 call,apply,bind的区别是什么一般用来指定的this环境; 123456789var a=&#123; user:'少女雨', fn:function()&#123; console.log(this.user); &#125; &#125; var b=a.fn; b(); //undefined a.fn(); //少女雨 引言：运行b()得到的是undefined，其实和我们的this指向有关系;因为此时this指向的是b;而下面a.fn()为什么能输出来能，因为此时this指向的是我们的a;也就是常说的那句，this始终指向的是调用它的那个对象;虽然a.fn()能打印出我们的数据，但是并不是最科学的方式，这时候可以通过下面的方法：1.call():调用一个对象的一个方法，以另一个对象替换当前对象说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 12345678var a=&#123; user:'少女雨', fn:function()&#123; console.log(this.user); &#125; &#125; var b=a.fn; b.call(a); //少女雨 简单来说：通过在call方法，给定第一个参数；将b添加到哪个环境中，this就会指向那个对象；call方法除了第一个参数以外还能添加多个参数 12345678910111213var a=&#123; user:'少女雨', fn:function(a)&#123; console.log(this.user); console.log(a); //2 &#125; &#125; var b=a.fn; b(); //undefined a.fn(); //少女雨 b.call(a); //少女雨 b.call(a,2);//少女雨 2 这样就可以用作传参2.apply():应用某一对象的一个方法，用另一个对象替换当前对象。说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。apply方法和call方法相似，它也可以改变this指向； 12345678var a=&#123; user:'少女雨', fn:function()&#123; console.log(this.user); &#125; &#125; var b=a.fn; b.apply(a); //少女雨 同样的apply也可以有多个参数，但不同的是，第二个参数必须是一个数组， 123456789var a=&#123; user:'少女雨', fn:function(a)&#123; console.log(this.user); console.log(a); //10 &#125; &#125; var b=a.fn; b.apply(a,[10]); //少女雨 10 注意：如果call和apply的第一个参数是Null,那么this指向的是window对象； 123456789var a=&#123; user:'少女雨', fn:function(a)&#123; console.log(this); &#125; &#125; var b=a.fn; b.apply(null); //Window &#123;stop: function, open: function, alert: function, confirm: function, prompt: function…&#125; 3.bind() 和call,apply方法不同，但是都可以改变this的指向 12345678var a=&#123; user:'少女雨', fn:function(a)&#123; console.log(this.user); &#125; &#125; var b=a.fn; b.bind(a); 这里没有打印出数据；这就是bind和call,apply不同的地方，实际上bind返回的是一个修改过后的函数；你看： 12345var c=b.bind(a); console.log(c); /*function (a)&#123; console.log(this.user); &#125;*/ 若想打印出数据，需要再执行以下c();同样bind()也可以有多个参数，并且参数可以执行的时候再次添加，但注意，参数是按照形参顺序进行的；就是这样 12345678910var a=&#123; user:'少女雨', fn:function(a,b,c)&#123; console.log(this.user); //少女雨 console.log(a,b,c); //1 3 4 &#125; &#125; var b=a.fn; var c=b.bind(a,1); c(3,4); 总结：call和apply都是改变上下文中的this并立即执行这个函数，都可以添加多个参数，但是apply方法添加的参数必须是一个数组;bind方法可以让对应的函数想什么时候调用就什么时候调用，并且参数可以在执行时候添加 caller , callee和arguments分别是什么1.arguments:在函数调用时，会自动在该函数内部生成一个名为arguments的隐藏对象，该对象类似于数组，但又不是数组；可以用[]操作符获取函数调用时传递的实参,并不局限于函数声明的参数列表;表示被这拗口的话混乱了； 123456function obj()&#123; console.log( 'arguments instanceof Array? ' + (arguments instanceof Array) ); // arguments instanceof Array? false console.log( 'arguments instanceof Object? ' + (arguments instanceof Object) ); // arguments instanceof Object? true console.log(arguments); //Arguments(0) &#125; obj(); 我们通过控制台显示的数据还看：从打印的结果看，arguments是一个对象，并且里面还包含了callee，callee中又包含caller等属性；接下来，我们gia百年代码看看，让函数调用时，传递参数，而函数本身没有参数；123456function obj()&#123; console.log( 'arguments instanceof Array? ' + (arguments instanceof Array) ); // arguments instanceof Array? false console.log( 'arguments instanceof Object? ' + (arguments instanceof Object) ); // arguments instanceof Object? true console.log(arguments); //Arguments(0)&#125;obj('xiaonv','LOVE',23); 和上面的代码没有什么区别，只是obj传递了参数；很显然，Arguments包含了3个参数，也就是我们调用obj()时传递的；所以，也就是说为什么arguments是存储的实际传递给函数的参数呢，而不是函数声明的参数；2.callee上面的截图中，我们已经看到了callee的出现，可以看出，callee是arguments对象的一个成员，并且值就是为我们被执行的obj()方法；我们在obj方法中加入这一句： 1console.log(arguments.callee); 从而可知：arguments.callee是指向参数arguments对象的函数，在这里就是obj咯。3.caller又是哪个？记得上图也出现过，caller则是callee里的一个属性对象；该属性保存着调用当前函数的函数；注意：是调用，不仅仅包含闭包，如果没有父函数，则为null;所以上诉代码中，我们这样输出：1console.log(arguments.callee.caller); //null 因为obj方法没有父函数，所以为null；接下来，我们再看： 12345678910//父函数function parent()&#123; //子函数 function child()&#123; console.log(child.caller); &#125; child(); console.log(parent.caller); //null&#125; parent(); 看看输出结果：可以看到caller保存的是parent对象；这是因为child有一个父函数parent，并且在父函数中被执行child(); 而后一个parent没有父函数，所以为null；那这样看看： 12345678 //parent2调用了child2function parent2()&#123; child2();&#125;function child2()&#123; console.log(child2.caller);&#125; parent2(); 结果呢：看见区别了吗？ parent2调用了child2，但child2不是嵌套在parent2里的函数；所以只显示了child2();大概就是这样; 什么是闭包，闭包有什么用处相信很多人都会有这个困惑，闭包到底是什么？ 什么是闭包呢？闭包是有权访问另一个函数作用域的变量的函数简单点来说：javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数体内，而且，这些内部函数可以访问它们所在的内部函数中声明的所有全局变量，参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包； 作用域的作用这是理解闭包的第一步；前面已经介绍过作用域了，无非就是全局和局部；javascript语言的特殊之处，在于函数内部可以直接读取全局变量；其中内部函数中可以访问外部函数的变量，是因为内部函数的作用域链中包含了外部函数的作用域； 12345var n=999; function f1()&#123; console.log(n); //999 &#125; f1(); 而另一方面，函数外部是无法取到函数内部的值； 12345function f1()&#123; var n=999; &#125;f1();console.log(n); //n is not defined 还有一点要注意，函数内部声明变量时，一定要使用var命令，不然等于声明了一个全局变量，变量作用域会提升； 12345function f1()&#123; n=999;&#125;f1();alert(n); // 999 闭包的几种写法简单介绍下，和上面的定义类的几种方法其实就是闭包； 123456789function Circle(r) &#123; this.r = r; &#125; Circle.PI = 3.14159; Circle.prototype.area = function() &#123; return Circle.PI * this.r * this.r; &#125; var c = new Circle(1.0); console.log(c.area()); //3.14159 还有 1234567var Circle=&#123; \"PI\":3.14159, \"area\":function(r)&#123; return this.PI * r * r; &#125; &#125;; alert( Circle.area(1.0) );//3.14159 可以结合上面的例子简单理解下； 闭包的作用1.可以读取函数内部的变量，2.让这些变量的值始终保持在内存中；但是究竟怎么使用闭包才能读取到函数内的局部变量呢？ 1234567 function f1()&#123; var n=999; function f2()&#123; console.log(n); // 999 &#125;f2();&#125; 上面的代码，我在函数内部再定义了一个函数；f2被包含在f1内部了，所以可以访问f1内部的所有全局变量；但是f1去不能访问f2内部的局部变量；这就是js的“链式作用域”结构，子对象会一级一级的向上寻找所有父对象的变量，所以父对象的所有变量，对子对象都是可见的，反之则不成立；123456789 function f1()&#123; var n=999; function f2()&#123; console.log(n); &#125; return f2;&#125;var result=f1();result(); // 999 f2可以读取到f1的变量，那么将f2作为返回值，不久可以在f1中读取到它的内部变量了；但是如何将变量的值存在内存中呢？ 1234567891011121314function f1()&#123; var n=99; nAdd=function()&#123; //匿名函数 n+=1; //全局变量 &#125; function f2()&#123; console.log(n); &#125; return f2;&#125;var result=f1();result(); //99nAdd();result(); //100 这段代码中result实际上就是闭包f2函数，它一共运行了两次，第一次值是99，第二次是100；这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 闭包与this在闭包中使用this对象会导致一些问题；因为匿名函数的执行具有全局性，而this对象通常指向window对象；12345678910var name = \"The window\";var object = &#123; name:\"My object\", getNameFun:function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFun()); //\"The window\"（在非严格模式下） 但是，将其阿布作用域中的this对象保存在一个闭包能够访问的变量里，就可以让闭包访问该对象啦；12345getNameFun:function()&#123; var that=this; return function()&#123; return that.name; &#125;; 使用闭包注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 defineProperty,hasOwnProperty,isEnumerable 都是做什么用的?javascript中任何一个构造函数对有其对应的原型，我们可以给原型赋予一些我们想要的属性； 1234567891011121314function Gadget(name,color)&#123; this.name=name; this.color=color; this.whatAreYou=function()&#123; return 'I am a' + this.color + ' ' + this.name; &#125; &#125; Gadget.prototype.price=100; Gadget.prototype.rating=3; Gadget.prototype.getInfo=function()&#123; return 'Rating' +this.rating + ' ,price:' +this.price; &#125;; var newtoy=new Gadget('少女雨','black'); console.log(newtoy); 先看看输出结果：这里定义了一个Gadget类的实例 –newtoy对象，在这个对象中，我们可以访问对象内部以及其原型对象中的属性和方法；如果想要获得某个对象所有的属性列表，可以使用for-in循环；123for (i in newtoy) &#123; console.log(i+ '= ' + newtoy[i]);&#125; 可以得到这样的结果：12345678910name= 少女雨color= blackwhatAreYou= function ()&#123; return 'I am a' + this.color + ' ' + this.name; &#125;price= 100rating= 3getInfo= function ()&#123; return 'Rating' +this.rating + ' ,price:' +this.price; &#125; 这时候，如果我们想把原型中的属性过滤掉，就可以首先使用hasOwnProperty()来判断该属性是否属于原型对象内部的：1234for (i in newtoy) &#123; if(newtoy.hasOwnProperty(i)) console.log(i+ '= ' + newtoy[i]);&#125; 输出结果是这样的：12345name= 少女雨color= blackwhatAreYou= function ()&#123; return 'I am a' + this.color + ' ' + this.name;&#125; 需要注意以下几点： 只有那些可枚举的属性才会被显示出来(一般内建属性都是不可枚举的) 原型中的各个原型属性才会被显示出来，当然前提是它们是可枚举的； propertyIsEnumerable()用于测试该属性是否可枚举，对于所以的原型属性，propertyIsEnumerable()都会返回false，包括那些在for-in循环中可枚举的属性。console.log(newtoy.propertyIsEnumerable()) //false但如果propertyIsEnumerable()的调用是来自原型链上的某个对象，那么该对象中的属性是可枚举的。例如：newtoy.constructor.prototype.propertyIsNumerable(‘price’); //返回: ture 另外还有一个比较常用的isPrototypeOf()方法，这个方法告诉我们当前对象是否是另外一个对象的原型；1234567891011121314151617181920function Gadget(name,color)&#123; this.name=name; this.color=color; this.whatAreYou=function()&#123; return 'I am a' + this.color + ' ' + this.name; &#125; &#125; Gadget.prototype.price=100; Gadget.prototype.rating=3; Gadget.prototype.getInfo=function()&#123; return 'Rating' +this.rating + ' ,price:' +this.price; &#125;;function Human()&#123; this.name=name;&#125;Gadget.prototype=Human;var newtoy=new Gadget('少女雨','black');console.log(Gadget.isPrototypeOf(newtoy)); //falseconsole.log(Human.isPrototypeOf(newtoy)); //true 第一个输出false，因为newtoy是Gadget的一个实例，不是原型；第二个输出true，因为Human是Gadget的原型，所以也就是newtoy的原型； defineProperty是es5新加的给对象属性设置描述符的方法，使用的方式如下：Object.defineProperty(obj,prop,descriptor) //对象，属性，描述符基本的描述符有这三个： writable –是否为可写 configurable – 是否为可配置的 enumerable – 是否为可枚举的顾名思义，writable设置属性是否为可写，如果是false，那属性之后的修改将会无效configurable属性是否可配置，设置为false后，该属性不可被删除，也不可再更改为可配置的，但是可以从可写改为不可写enumerable 属性是否可枚举，如果是false，则属性不可枚举，不可枚举属性对 for … in语句和Ojbect.keys是不可见的123456789101112var o = &#123; name: 'xu'&#125;Object.defineProperty(o, 'name', &#123; writeable:false //不可写&#125;)Object.defineProperty(o, 'name', &#123; configurable:false &#125;)Object.defineProperty(o, 'name', &#123; enumerable: false&#125;) 对value的get/set方法采用的就是此方法； js常用的设计模式的实现思想，单例，工厂，代理，装饰，观察者模式等;什么是设计模式呢？设计模式是一种解决问题的方案，用于解决在软件设计过程中普遍存在的问题；学习设计模式是为了学习如何合理的整理我们的代码； 设计模式六要素单一职责原则：一个类只负责一个功能领域中相应的职责，或者可以定义为：就一个类而言，应该只有一个引起他变化的原因；单一职责原则要求一个类不能承担过多的职责，形成”超级类”。需要根据不同职责分为不同的类，从而降低类的复杂度，提高可阅读性，增加系统的稳定性；开闭原则：一个软件实体应该对扩展开发，对修改关闭，即软件实体应尽量在不修改原有代码的情况下进行扩展；里氏代换原则：所有引用父类的地方都必须能透明的使用起子类的对象；里氏代换原则要求在软件中一个基类能够替换为它的子类而不会因此任何异常。因此要求子类可以扩展父类的功能，但不能修改父类本身的非抽象方法；依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象，换言之，要针对接口编程，而不是针对现实编程；接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。接口隔离原则要求我们设计接口不应太大，接口应仅仅提供客户端需要的行为，在使用此原则时应注意接口的粒度，接口太小会导致接口泛滥，不利于维护，接口太大灵活性较差，使用不便；迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用；迪米特法则要求我们应该减少对象之间的交互，如果两个对象之间不必彼此之间直接通信，那么这两个对象就不应该发送任何直接的相互作用，当需要调用另一个对象的某一方法时，可以通过第三者来转发此调用。 几种常用设计模式单例模式作用：用来保证一个类只有一个实例，用来解决一个全局使用的类频繁的创建和销毁，从而节约系统资源； 12345678910111213141516var single = (function()&#123; var unique; function getInstance()&#123; // 如果该实例存在，则直接返回，否则就对其实例化 if( unique === undefined )&#123; unique = new Construct(); &#125; return unique; &#125; function Construct()&#123; // ... 生成单例的构造函数的代码 &#125; return &#123; getInstance : getInstance &#125;&#125;)(); 可以通过 single.getInstance() 来获取到单例，并且每次调用均获取到同一个单例。这就是 单例模式 所实现的效果。应用场景：适用于我们平常将代码封装起来，只暴露一个入口，从而避免全部变量被污染； 工厂模式概念：提供创建对象的接口，根据调用者的参数，生产相对应的产品；分类：简单工厂模式:使用一个类，通常为单体，来生成实例；复杂工厂模式：将其成员对象的实例化推到子类中，子子类可以重写父类接口方法以便创建的时候指定自己的对象类型。父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。简单工厂模式：123456789101112131415var XMLHttpFactory =function()&#123;&#125;; //这是一个简单工厂模式 XMLHttpFactory.createXMLHttp =function()&#123; var XMLHttp = null; if (window.XMLHttpRequest)&#123; XMLHttp = new XMLHttpRequest() &#125;else if (window.ActiveXObject)&#123; XMLHttp = new ActiveXObject(\"Microsoft.XMLHTTP\") &#125; return XMLHttp; &#125; //XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。 var AjaxHander =function()&#123; var XMLHttp = XMLHttpFactory.createXMLHttp(); ... &#125; 复杂工厂模式：12345678910111213141516171819202122var XMLHttpFactory =function()&#123;&#125;; //这是一个抽象工厂模式XMLHttpFactory.prototype = &#123; //如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类 createFactory:function()&#123; throw new Error('This is an abstract class'); &#125;&#125;var XHRHandler =function()&#123;&#125;; //定义一个子类// 子类继承父类原型方法extend( XHRHandler , XMLHttpFactory );XHRHandler.prototype =new XMLHttpFactory(); //把超类原型引用传递给子类,实现继承XHRHandler.prototype.constructor = XHRHandler; //重置子类原型的构造器为子类自身//重新定义createFactory 方法XHRHandler.prototype.createFactory =function()&#123; var XMLHttp =null; if (window.XMLHttpRequest)&#123; XMLHttp =new XMLHttpRequest(); &#125;else if (window.ActiveXObject)&#123; XMLHttp =new ActiveXObject(\"Microsoft.XMLHTTP\") &#125; return XMLHttp;&#125; 简单对象使用工厂模式会增加其系统的复杂度。所以工厂模式适用的场景只是对象的构建十分复杂，处理大量具有相同属性的小对象，需要依赖具体环境创建不同实例； 代理模式概念：把对一个对象的访问, 交给另一个代理对象来操作举一个例子：我们公司的补打卡是最后是要交给大boss来审批的，但是公司那么多人，每天都那么多补打卡，那大boss岂不是被这些琐事累死。所以大boss下会有一个助理，来帮忙做这个审批，最后再将每个月的补打卡统一交给大boss看看就行； 1234567891011121314151617181920// 补打卡事件var fillOut = function (lateDate) &#123; this.lateDate = lateDate;&#125;;// 这是bigBossvar bigBoss = function (fillOut) &#123; this.state = function (isSuccess) &#123; console.log(\"忘记打卡的日期为：\" + fillOut.lateDate + \", 补打卡状态：\" + isSuccess); &#125;&#125;;// 助理代理大boss 完成补打卡审批var proxyAssis = function (fillOut) &#123; this.state = function (isSuccess) &#123; (new bigBoss(fillOut)).state(isSuccess); // 替bigBoss审批 &#125;&#125;;// 调用方法：var proxyAssis = new proxyAssis(new fillOut(\"2016-9-11\"));proxyAssis.state(\"补打卡成功\");// 忘记打卡的日期为：2016-9-11, 补打卡状态：补打卡成功 应用场景：比如图片的懒加载，我们就可以运用这种技术。在图片未加载完成之前，给个loading图片，加载完成后再替换成实体路径。还有解决跨域问题都能采用代理模式； 观察者模式（发布订阅)概念：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。它需要一种高级的抽象策略，以便订阅者能够彼此独立地发生改变，而发行方能够接受任何有消费意向的订阅者。发布订阅流程： 确定谁是发布者(比如我的博客)。 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者。 发布消息，发布者需要遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 退订（比如不想再接收到这些订阅的信息了，就可以取消掉）这种其实很好理解，特别是我学习了框架之后，subscribe用来订阅；unsubscribe取消订阅； 还有更多设计模式；可以自行去了解下； 列举数组相关的方法一个简单数组：12345var mycars=new Arrat();mycars[0]='Sab';mycars[1]='Volvo';mycars[2]='BMW';console.log(mycars); 输出结果很简单，就是这样：从图可以看出数组有啥属性吧，length,construtor,prototype;现在主要来介绍数组的方法；看看如何使用：1&lt;button onclick=\"myage.forEach(myFunction)\"&gt;点我&lt;/button&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var mycars=new Array(); mycars[0]='Sab'; mycars[1]='Volvo'; mycars[2]='BMW'; console.log(mycars); //[\"Sab\", \"Volvo\", \"BMW\"] var myshops=new Array('小雨','haha'); console.log(myshops);//[\"小雨\", \"haha\"] var mys=mycars.concat(myshops); console.log(mys);//[\"Sab\", \"Volvo\", \"BMW\", \"小雨\", \"haha\"] var mybeds=new Array('床'); var mys=myshops.concat(mybeds,mycars); console.log(mys);//[\"小雨\", \"haha\", \"床\", \"Sab\", \"Volvo\", \"BMW\"] //所以concat不止传入一个参数，和拼接顺序有关； mycars.copyWithin(1,0); console.log(mycars);//[\"Sab\", \"Sab\", \"Volvo\"] //copyWiththin是用于数组内部的 var myage=[32,15,25,25]; function checkAdult(age)&#123; return age&gt;=18; &#125; console.log(myage.every(checkAdult));//false //every用于检测所有元素是否都符合条件，有一个不满足都会返回false；如果有一个返回false，则其余的并不会被检测；并外不能检测空数组；和 some方法相反，some方法一旦有满足条件就返回true； console.log(myage.filter(checkAdult));//[32, 25, 25] //filter输出的是符合检索的所有值，对空数组无效 console.log(myage.find(checkAdult)); //32 //find返回的是符合条件的第一个值，如果没有符合条件的就返回undefined，对空数组无效 //对于以上的检索方法都是传入一个检查条件 console.log(myage.findIndex(checkAdult));//0 //findIndex 顾名思义，返回的是符合条件的值的索引值，和上面的find类似；没有返回-1； mycars.fill('shaonvyu'); console.log(mycars);//[\"shaonvyu\", \"shaonvyu\", \"shaonvyu\"] //fill 使用一个固定值来替换数组中所有的值，对空数组无效 function myFunction(item, index) &#123; console.log( \"index[\" + index + \"]: \" + item ); //index[0]: 32 index[1]: 15 index[2]: 25 index[3]: 25 &#125; //forEach用于调用数组中的每一个元素，并将元素给回调函数，有一个用于场景，点击的时候想获取每一个列表的值，但是使用for返回的总是只有最后一个，这时候可以试试forEach；对空数组无效; console.log(mycars.indexOf('Sab')); //-1 console.log(myshops.indexOf('haha')); //1 //indexof用来返回某个指定字符串首次出现在数组中的位置,按从左到右顺序索引的，如果想反过来就使用lastIndexOf；没有找到则返回-1； //但是上面的两个输出为什么第一个是-1,从直观感觉看，Sab这个值却是在mycars数组中；那是因为数组开始时new的一个空数组，Sab是我们后来加入进去的值，采用Indexof索引的是原始数组，所以找不到； var join=mycars.join(); console.log(join); //shaonvyu,shaonvyu,shaonvyu // join用于把数组中的所有元素转换成一个字符串，用,或者指定的符号进行分割；为什么输出是shaonvyu呢，因为上面的fill方法； console.log(myage.map(Math.sqrt)); //[5.656854249492381, 3.872983346207417, 5, 5] //map返回一个新的数组，数组中的值是经过函数调用返回的值，对空数组无效，按序处理 console.log(mys);//[\"小雨\", \"haha\", \"床\", \"Sab\", \"Volvo\", \"BMW\"] console.log(mys.pop());//BMW console.log(mys);//[\"小雨\", \"haha\", \"床\", \"Sab\", \"Volvo\"] //pop方法删除数组的最后一个元素，并返回被删除元素的值；会改变数组长度，shift方法用来删除数组的第一个元素，和pop相反； console.log(mys.shift()); //小雨 console.log(mys.indexOf('haha')); //0 console.log(mycars.push('Sab')); //4 console.log(mycars);//[\"shaonvyu\", \"shaonvyu\", \"shaonvyu\", \"Sab\"] //push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。新增的元素被添加在末尾;改变了数组长度，如果想在开始位置添加，使用unshift方法;都是返回新的长度 function getSum(total,age)&#123; return total + age; &#125; console.log(myage.reduce(getSum));//97 // reduce 只返回一个值，从左到右开始计算，作为一个累加，如果想从右到左，使用reduceRight方法，功能一样 console.log(myshops.reverse()); //[\"haha\", \"小雨\"] console.log(myshops);//[\"haha\", \"小雨\"] //reverse 反序输出数组，将数组顺序颠倒； console.log(mys);//[\"haha\", \"床\", \"Sab\", \"Volvo\"] console.log(mys.slice(1,3)); //[\"床\", \"Sab\"] //slice方法从已有数组中返回指定的部分，并返回出来，输出的是索引，取前不取后；不改变原始数组 console.log(mys);//[\"haha\", \"床\", \"Sab\", \"Volvo\"] mys.splice(2,0,\"HRE\",\"DDD\") console.log(mys);//[\"haha\", \"床\", \"HRE\", \"DDD\", \"Sab\", \"Volvo\"] //splice() 方法用于插入、删除或替换数组的元素。会改变原始数组 console.log(myage.sort()); //[15, 25, 25, 32] var a=[-1,3,45,8,35]; console.log(a.sort()); //[-1,3,45,8] //sort对数组内的字母或数字进行排序，并按升序或者降序，默认是升序；这个方法会改变原始数组;注意不能对还有负数的数组进行排序 console.log(mys.toString())//haha,床,HRE,DDD,Sab,Volvo //tostring是最常用的， 可把数组转换为字符串，并返回结果。数组中的元素之间用逗号分隔。 console.log(mycars.valueOf()); //[\"shaonvyu\", \"shaonvyu\", \"shaonvyu\", \"Sab\"] //valueOf返回数组的原始值，和mycars输出的值一样，原始值指的是Array 对象派生的所有对象继承出来的值，不改变数组长度 以上就是所有的数组方法了； 列举与字符串相关的常用方法首先应该知道字符串就是一个或多个排列在一起的字符，放在单引号或双引号之中。12 var str=\"abcdfe\";console.log(str.length);//6 字符串只有一个属性，就是length；常用的多一些方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344var str=\"abcdfe\"; console.log(str.length);//6 console.log(str.charAt(2)); //c //charAt(n) 传入的是一个索引值，如果不在 0~str.length-1之间，则返回一个空字符串 console.log(str.charCodeAt(2));//99 //charCodeAt() 用法和charAt一样，只是返回的是指定位置的Unicode值, fromCharCode()将unicode值转成字符串 var str1=\"fdrref\"; var a=str.concat(str1); console.log(a)//abcdfefdrref //concat 连接两个或多个字符串，返回连接后的字符串 console.log(str.indexOf('c'));//c //indexof返回 substr 在字符串 str 中首次出现的位置,从 start 位置开始查找，如果不存在，则返回 -1。start可以是任意整数，默认值为 0。如果 start &lt; 0 则查找整个字符串（如同传进了 0）。如果 start &gt;= str.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，此时返回 str.length.从最后一个位置查找lastIndexOf() console.log(str1.localeCompare(str));//1 //localCompare用本地特定的顺序来比较两个字符串，大于返回1，小于返回-1 console.log(str.match(/ab/)) //[\"ab\", index: 0, input: \"abcdfe\"] //match 返回一个包含匹配结果的数组，如果没有匹配项，则返回 null。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象,返回一个数组 console.log(str.replace('a','love'));//lovebcdfe //replace str.replace(regexp|substr, newSubStr|function) 替换 str 的子字符串 不改变原始字符串 console.log(str);//abcdfe console.log(str.search(/d/)); //3 //search() 查找 str 与一个正则表达式是否匹配。如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引；否则，返回 -1。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象 console.log(str.slice(3,-1))//df //slice 返回从 start 到 end （不包括）之间的字符，可传负值; console.log(str.split('b')); //[\"abcdfe\"] console.log(str.split('b'));//[\"a\", \"cdfe\"] //split 返回一个数组，分隔符 separator 可以是一个字符串或正则表达式,把字符串分割为子字符串数组 console.log(str);//abcdfe console.log(str.substr(4,2)); //fe // 返回 str 中从指定位置开始到指定长度的子字符串，start可为负值,第一个表示索引，第二个表示长度 console.log(str.substring(2,5));//cdf //提取字符串中两个指定的索引号之间的字符 都是取前不取后 console.log(str.toLocaleLowerCase()); //abcdfe console.log(str.toLocaleUpperCase()); //ABCDFE //toLocaleLowerCase()根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射，toLocaleUpperCase()反之 console.log(str.toLowerCase());//abcdfe console.log(str.toUpperCase()); //ABCDFE //将指定字符串转换成小写或者大写 console.log(str.toString());//abcdfe //tostring 返回字符串对象值 var a=\" fdfde dffd \"; console.log(a.trim()); //fdfde dffd //trim移除字符串首尾空白，中间的不移除 console.log(str.valueOf());//abcdfe //返回某个字符串的原始值，和直接输出一样 好了，所有的字符串的方法都在这里呀； 判断一个字符串中出现次数最多的字符，统计这个次数12345678910111213141516171819202122232425262728var str = 'asdfdffhwfeuwdasdsaaaaaaaa'; var json = &#123;&#125;; //遍历str拆解其中的每一个字符，将其中某个字符得到值及其出现的次数拿出来作为json的key和value for (var i = 0; i &lt; str.length; i++) &#123; //判断json中是否有当前str值 if (!json[str.charAt(i)]) &#123; //如果不存在，就将当前值添加到json中去； json[str.charAt(i)] = 1; &#125; else &#123; //else的话就让数组中已有的当前值的index值++； json[str.charAt(i)]++; &#125; &#125; console.log(json); //储存出现次数最多的值和次数 var iMax = 0; var iIndex = ''; //遍历json 使用打擂算法统计需要的值 for (var i in json) &#123; //如果当前项大于下一项 if (json[i] &gt; iMax) &#123; //让当前值更改为出现次数最多的值 iMax = json[i]; iIndex = i; &#125; &#125; //打印最终结果 console.log ('出现最多的值是'+ iIndex+ '出现的次数为'+iMax); //出现最多的值是a出现的次数为10 看看json 里面存入的值： 编写一个方法，求一个字符串的字节长度123456789101112var str=\"22来那个\"; console.log(getStrlen(str)); //3 5 function getStrlen(str)&#123; var json=&#123;len:0&#125;; var re=/[\\u4e00-\\u9fa5]/; for(var i=0;i&lt;str.length;i++)&#123; if(re.test(str.charAt(i)))&#123; json['len']++; &#125; &#125;; return json['len']+\" \"+str.length; &#125; 关于里面的正则表达式，可以看这里 JavaScript中如何检测一个变量是一个String类型？请写出函数实现12typeof(obj)=='string';obj.constructor==String; 说到数据类型，补充一点：1234console.log(typeof null);console.log(typeof &#123;&#125;);console.log(typeof []);console.log(typeof undefined); 结果：1234objectobjectobjectundefined 给String对象定义一个repeatify方法。该方法接收一个整数参数，作为字符串重复的次数，最后返回重复指定次数的字符串例如：console.log(‘hello’.repeatify(3));输出：hellohellohello.12345678String.prototype.repeatify=String.prototype.repeatify || function(times)&#123; var str=''; for(var i=0;i&lt;times;i++)&#123; str+=this; &#125; return str;&#125;console.log('hello'.repeatify(3)) //hellohellohello 下面这段代码的结果是什么？为什么？123456789function test()&#123; console.log(a); //undefined console.log(foo()); //2 var a=1; function foo()&#123; return 2; &#125; &#125; test(); 变量和函数的声明都被提前至函数体的顶部，而同时变量并没有被赋值；因此，当打印变量a时，它虽然存在于函数体，仍然是Undefined;","content":"<h2 id=\"js-定义类有哪些常用的方法？\"><a href=\"#js-定义类有哪些常用的方法？\" class=\"headerlink\" title=\"js 定义类有哪些常用的方法？\"></a>js 定义类有哪些常用的方法？</h2><h3 id=\"1-工厂方式\"><a href=\"#1-工厂方式\" class=\"headerlink\" title=\"1.工厂方式\"></a>1.工厂方式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> ocar=<span class=\"keyword\">new</span> Obejct;  <span class=\"comment\">//不用括号</span></div><div class=\"line\">    ocar.color=<span class=\"string\">'blue'</span>;</div><div class=\"line\">    ocar.doors=<span class=\"number\">4</span>;</div><div class=\"line\">    ocar.showColor=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.color;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ocar;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> car1=Car();</div><div class=\"line\"><span class=\"keyword\">var</span> car2=Car();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(car1);  <span class=\"comment\">//&#123;color: \"blue\", doors: 4, snowColor: ƒ&#125;  f指的是function()</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(car2);  <span class=\"comment\">//&#123;color: \"blue\", doors: 4, snowColor: ƒ&#125;</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><strong>注：</strong><br>1.调用此方法时，将创建新的对象，并赋予它所有的属性和方法。使用此函数可以创建两个属性完全相同的对象；<br>2.我们可以通过给函数传递不同的参数来得到具有不同值得对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\">color,door</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> ocar=<span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>;</div><div class=\"line\">    ocar.color=color;</div><div class=\"line\">    ocar.doos=door;</div><div class=\"line\">    ocar.showColor=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ocar;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> car1=Car(<span class=\"string\">\"red\"</span>,<span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> car2=car(<span class=\"string\">\"blue\"</span>,<span class=\"number\">4</span>);</div><div class=\"line\">car1.showColor(); <span class=\"comment\">//red；</span></div><div class=\"line\">car2.showColor(); <span class=\"comment\">//blue</span></div></pre></td></tr></table></figure>\n<p>在上面的两个例子中，每次创建一个Car()对象都会创建一个showColor()，意味着每个对象都有自己的showcolor()方法，但是实际上每个对象可以共享同一个函数，最后通过将函数的属性指向该方法*</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showColor</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\">color,door</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> ocar=<span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">   ocar.color=color;</div><div class=\"line\">   ocar.doors=door;</div><div class=\"line\">   ocar.showColor=showColor;</div><div class=\"line\">   <span class=\"keyword\">return</span> ocar;</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"keyword\">var</span> car1=<span class=\"keyword\">new</span> Car(<span class=\"string\">'red'</span>,<span class=\"number\">4</span>);</div><div class=\"line\"> car1.showColor();</div></pre></td></tr></table></figure>\n<p><em>当然这里扯远了</em></p>\n<h3 id=\"2-构造函数方法\"><a href=\"#2-构造函数方法\" class=\"headerlink\" title=\"2.构造函数方法\"></a>2.构造函数方法</h3><p>这个和工厂方式差不多</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\">color,door</span>)</span>&#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.color=color;</div><div class=\"line\">       <span class=\"keyword\">this</span>.doors=door;</div><div class=\"line\">       <span class=\"keyword\">this</span>.showColor=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">var</span> car1=<span class=\"keyword\">new</span> Car(<span class=\"string\">\"red\"</span>,<span class=\"number\">4</span>);</div><div class=\"line\">   <span class=\"keyword\">var</span> car2=<span class=\"keyword\">new</span> Car(<span class=\"string\">\"blue\"</span>,<span class=\"number\">5</span>);</div><div class=\"line\">   car1.showColor();<span class=\"comment\">//red</span></div><div class=\"line\">   car2.showColor();<span class=\"comment\">//blue</span></div></pre></td></tr></table></figure>\n<p><strong>注：</strong><br>这种模式和工厂的方式区别在于，不用通过自己去New一个对象，而是使用this关键字；<br>因为在调用构造函数时就已经创建了对象，而在函数内部只能通过this来访问此对象<br>但是，它和工厂方式一样，每次调用对象都会创建自己的方法</p>\n<h3 id=\"3-原型方式\"><a href=\"#3-原型方式\" class=\"headerlink\" title=\"3.原型方式\"></a>3.原型方式</h3><p>该方式利用了对象的prototype属性，首先用空函数创建类名，然后所有的属性和方法都被赋予prototype属性；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Car.prototype.color=<span class=\"string\">\"red\"</span>;</div><div class=\"line\">Car.prototype.doors=<span class=\"number\">4</span>;</div><div class=\"line\">Car.prototype.showColor=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> car1=<span class=\"keyword\">new</span> Car();</div><div class=\"line\"><span class=\"keyword\">var</span> car2=<span class=\"keyword\">new</span> Car();</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(car1);</div></pre></td></tr></table></figure>\n<p><strong>看看最后输出的是什么</strong><br><img src=\"/images/js-1.png\" alt=\"js\"><br><strong>注：</strong><br>1.首先定义一个空函数，然后通过prototype属性来定义对象的属性；调用该函数时，<br>原型的所有属性都会立即赋予要创建的对象，所有该函数的对象存放的对是指向showColor()的指针，<br>语法上看起来都属于同一个对象；<br>2.但是这个函数没有参数，不能通过传参来初始化属性，必须要在对象创建后才能改变属性的默认值；<br>3.原型方式还有个很大的弊端；如果属性指向的是对象时：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Car.prototype.color=<span class=\"string\">\"red\"</span>;</div><div class=\"line\">Car.prototype.doors=<span class=\"number\">4</span>;</div><div class=\"line\">Car.prototype.arr=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">'a'</span>,<span class=\"string\">\"b\"</span>);</div><div class=\"line\">Car.prototype.showColor=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> car1=<span class=\"keyword\">new</span> Car();</div><div class=\"line\"><span class=\"keyword\">var</span> car2=<span class=\"keyword\">new</span> Car();</div><div class=\"line\">car1.arr.push(<span class=\"string\">'cc'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(car1.arr); <span class=\"comment\">//(3) [\"a\", \"b\", \"cc\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(car2.arr); <span class=\"comment\">//(3) [\"a\", \"b\", \"cc\"]</span></div></pre></td></tr></table></figure>\n<p><strong>注：</strong><br>arr对象指向的是一个数组，这里用的是数组的引用值，Car的两个对象指向的都是同一个数组所以car1添加值以后，在car2中也能看到值；<br>形式是这样的：<br><img src=\"/images/js-2.png\" alt=\"js\"></p>\n<h3 id=\"4-联合方式（构造函数-原型方式\"><a href=\"#4-联合方式（构造函数-原型方式\" class=\"headerlink\" title=\"4.联合方式（构造函数+原型方式)\"></a>4.联合方式（构造函数+原型方式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\">color,door</span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.color=color;</div><div class=\"line\">      <span class=\"keyword\">this</span>.doors=door;</div><div class=\"line\">      <span class=\"keyword\">this</span>.arr=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">\"aa\"</span>,<span class=\"string\">\"bb\"</span>);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  Car.prototype.showColor=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">var</span> car1=<span class=\"keyword\">new</span> Car(<span class=\"string\">\"red\"</span>,<span class=\"number\">4</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> car2=<span class=\"keyword\">new</span> Car(<span class=\"string\">\"blue\"</span>,<span class=\"number\">5</span>);</div><div class=\"line\">  car1.arr.push(<span class=\"string\">\"cc\"</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(car1);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(car1.arr); <span class=\"comment\">// (3) [\"aa\", \"bb\", \"cc\"]</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(car2.arr);  <span class=\"comment\">//(2) [\"aa\", \"bb\"]</span></div></pre></td></tr></table></figure>\n<p><strong>首先来看看car1对象</strong><br><img src=\"/images/js-3.png\" alt=\"js\"><br><strong>注：</strong><br>1.car1和car2对象都有自己单独的arr属性，所以改变其中一个另一个并不会受影响<br>2.此方式是用构造函数定义对象的非函数属性，用原型对象定义对象的方法</p>\n<h3 id=\"5-动态原型方式\"><a href=\"#5-动态原型方式\" class=\"headerlink\" title=\"5.动态原型方式\"></a>5.动态原型方式</h3><p>和混合模式相似，区别就是赋予对象方法的位置不一样；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\">color,door</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.color=color;</div><div class=\"line\">    <span class=\"keyword\">this</span>.doors=door;</div><div class=\"line\">    <span class=\"keyword\">this</span>.arr=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">\"aa\"</span>,<span class=\"string\">\"bb\"</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> Car._initialized ==<span class=\"string\">\"undefined\"</span>)&#123;</div><div class=\"line\">        Car.prototype.showColor=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\">        &#125;;</div><div class=\"line\">          Car._initialized=<span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> car1=<span class=\"keyword\">new</span> Car(<span class=\"string\">'blue'</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> car2=<span class=\"keyword\">new</span> Car(<span class=\"string\">'red'</span>,<span class=\"number\">3</span>);</div><div class=\"line\">car1.showColor();</div><div class=\"line\">car2.showColor();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(car1);</div></pre></td></tr></table></figure>\n<p><strong>注：</strong>此方法是用一个标志来判断是否已经给原型赋予了此方法，这样可以保证该方法只被创建一次</p>\n<h3 id=\"6-混合工厂方式\"><a href=\"#6-混合工厂方式\" class=\"headerlink\" title=\"6.混合工厂方式\"></a>6.混合工厂方式</h3><p><strong>目的是创建假构函数，只返回另一种对象的新实例</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> ocar=<span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();<span class=\"comment\">//带括号</span></div><div class=\"line\">    ocar.color=<span class=\"string\">\"red\"</span>;</div><div class=\"line\">    ocar.doors=<span class=\"number\">4</span>;</div><div class=\"line\">    ocar.showColor=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ocar;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> car1=<span class=\"keyword\">new</span> Car();</div><div class=\"line\"><span class=\"keyword\">var</span> car2=<span class=\"keyword\">new</span> Car();</div><div class=\"line\">car1.showColor(); <span class=\"comment\">//red</span></div></pre></td></tr></table></figure>\n<p><strong>注：</strong>和工厂方式很像，不通的就是这是通过New运算符</p>\n<h3 id=\"7-对象直接量\"><a href=\"#7-对象直接量\" class=\"headerlink\" title=\"7.对象直接量\"></a>7.对象直接量</h3><p>采用set get的方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> car1=&#123;</div><div class=\"line\">   <span class=\"attr\">color</span>:<span class=\"string\">\"\"</span>,</div><div class=\"line\">   <span class=\"attr\">getColor</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);  <span class=\"comment\">//red</span></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color;</div><div class=\"line\">   &#125;,</div><div class=\"line\">   <span class=\"attr\">setColor</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">color</span>)</span>&#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>.color=color;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">car1.setColor(<span class=\"string\">'red'</span>);</div><div class=\"line\">car1.getColor();</div></pre></td></tr></table></figure>\n<h3 id=\"8-定义函数对象\"><a href=\"#8-定义函数对象\" class=\"headerlink\" title=\"8.定义函数对象\"></a>8.定义函数对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> car2=<span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(); <span class=\"comment\">//注意大写</span></div><div class=\"line\">car2.prototype = &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>:<span class=\"string\">\"\"</span>,</div><div class=\"line\">    <span class=\"attr\">getColor</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);<span class=\"comment\">//blue</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">setColor</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">color</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.color=color;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">car2.prototype.setColor(<span class=\"string\">'blue'</span>);</div><div class=\"line\">car2.prototype.getColor();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(car2.prototype);<span class=\"comment\">//&#123;color: \"blue\", getColor: ƒ, setColor: ƒ&#125;</span></div></pre></td></tr></table></figure>\n<p>也是运用上面的原型方式和混合工厂模式</p>\n<h2 id=\"js类继承的方法有哪些\"><a href=\"#js类继承的方法有哪些\" class=\"headerlink\" title=\"js类继承的方法有哪些\"></a>js类继承的方法有哪些</h2><p>既然是继承，首先得有个父类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义一个动物类</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">     <span class=\"comment\">//给一个Name属性</span></div><div class=\"line\">     <span class=\"keyword\">this</span>.name=name || <span class=\"string\">'Animal'</span>;</div><div class=\"line\">     <span class=\"comment\">//实例方法</span></div><div class=\"line\">     <span class=\"keyword\">this</span>.sleep=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name+<span class=\"string\">\" 在睡觉\"</span>)；</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"comment\">//原型方法</span></div><div class=\"line\"> Animal.prototype.eat=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>)</span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃'</span> +food);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><p><strong>核心：</strong> 将父类的实例作为子类的原型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Cat.prototype=<span class=\"keyword\">new</span> Animal();</div><div class=\"line\">Cat.prototype.name=<span class=\"string\">'cat'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> cat=<span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name); <span class=\"comment\">//cat</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.eat(<span class=\"string\">'fish'</span>)); <span class=\"comment\">//cat正在吃fish</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());  <span class=\"comment\">//cat 在睡觉</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">//true </span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<p><strong>注：</strong>使用的的原型方式；<br><em>特点:</em></p>\n<ol>\n<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>\n<li>父类新增原型方法和原型属性，子类都能访问</li>\n<li>简单，易于实现</li>\n</ol>\n<p><em>缺点:</em></p>\n<ol>\n<li>要想为子类新增方法和属性，必须要在new Animal()这样的语句指向之后，不能放在构造器中；</li>\n<li>无法实现多继承</li>\n<li>来自原型对象的引用属性是所有实例共享的</li>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cat1=<span class=\"keyword\">new</span> Cat()</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat1.name) <span class=\"comment\">//cat</span></div></pre></td></tr></table></figure>\n<h3 id=\"构造继承-call（）\"><a href=\"#构造继承-call（）\" class=\"headerlink\" title=\"构造继承 call（）\"></a>构造继承 call（）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">    Animal.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.name=name || <span class=\"string\">'Animal'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> cat=<span class=\"keyword\">new</span> Cat(<span class=\"string\">'cat'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name); <span class=\"comment\">//cat</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());  <span class=\"comment\">//cat 在睡觉</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><strong>注：</strong>这里是调用不到eat原型方法的;<br><em>特点:</em></p>\n<ol>\n<li>解决了1中，子类实例共享父类引用属性的问题；</li>\n<li>创建实例时，可以向父类传参；</li>\n<li>可以实现多继承（call 多个父类对象);</li>\n</ol>\n<p><em>缺点:</em></p>\n<ol>\n<li>实例并不是父类的实例 </li>\n<li>只能继承父类的实例和方法，并不能继承原型属性和方法；</li>\n<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>\n</ol>\n<h3 id=\"实例继承-instace\"><a href=\"#实例继承-instace\" class=\"headerlink\" title=\"实例继承  instace\"></a>实例继承  instace</h3><p><strong>核心：</strong> 为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> instace=<span class=\"keyword\">new</span> Animal();</div><div class=\"line\">     instace.name=name || <span class=\"string\">'Animal'</span>;</div><div class=\"line\">     <span class=\"keyword\">return</span> instace;</div><div class=\"line\"> &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> cat=<span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name); <span class=\"comment\">//Animal</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep()); <span class=\"comment\">//Animal 在睡觉</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p><em>特点:</em>不限制调用方法，不管是new 子类()还是子类(),返回的对象具有相同的效果；<br><em>缺点:</em><br>1.实例是父类的实例，不是子类的实例;<br>2.不支持多继承</p>\n<h3 id=\"拷贝继承\"><a href=\"#拷贝继承\" class=\"headerlink\" title=\"拷贝继承\"></a>拷贝继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> animal=<span class=\"keyword\">new</span> Animal();</div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> p <span class=\"keyword\">in</span> animal)&#123;</div><div class=\"line\">          Cat.prototype[p]=animal[p];</div><div class=\"line\">      &#125;</div><div class=\"line\">      Cat.prototype.name=name || <span class=\"string\">'Tom'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><em>特点:</em>支持多继承;<br><em>缺点:</em></p>\n<ol>\n<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>\n<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li>\n</ol>\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p><strong>核心：</strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</div><div class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><em>特点：</em><br>    1.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法<br>    2.既是子类的实例，也是父类的实例<br>    3.不存在引用属性共享问题<br>    4.可传参<br>    5.函数可复用<br><em>缺点：</em>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p>\n<h3 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h3><p><strong>核心：</strong>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></div><div class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">  Super.prototype = Animal.prototype;</div><div class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></div><div class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<p>特点:堪称完美<br>缺点: 实现较为复杂</p>\n<h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><p>给定无序数组，要求去除数组中的重复数组，并且返回新的无重复数组<br>ES6写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>];</div><div class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(array));</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(array)));<span class=\"comment\">//(7) [1, 2, 3, 5, 4, 9, 8]</span></div></pre></td></tr></table></figure>\n<p>ES5写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(uniqueArray(array));<span class=\"comment\">//(7) [1, 2, 3, 5, 4, 9, 8]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniqueArray</span>(<span class=\"params\">array</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> hashmap=&#123;&#125;;</div><div class=\"line\">    <span class=\"keyword\">var</span> unique=[];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;array.length;i++)&#123;</div><div class=\"line\">        <span class=\"comment\">//hasOwnProperty boolean 用于表示一个对象本身是否具有指定名称的属性值</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(!hashmap.hasOwnProperty([array[i]]))&#123;</div><div class=\"line\">            hashmap[array[i]]=<span class=\"number\">1</span>;</div><div class=\"line\">            unique.push(array[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> unique;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"js类多重继承的实现方法是怎么样的\"><a href=\"#js类多重继承的实现方法是怎么样的\" class=\"headerlink\" title=\"js类多重继承的实现方法是怎么样的\"></a>js类多重继承的实现方法是怎么样的</h2><p>其实就是第二部分的代码；<br>1.call/apply</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">this</span>.name = name;  <span class=\"comment\">//专门存放名字的</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">sex</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">this</span>.sex = sex;  <span class=\"comment\">//专门存放性别的的</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">age</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = age;  <span class=\"comment\">//专门存放年纪的</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> Student = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, sex, age, score</span>)</span>&#123;</div><div class=\"line\"> s1.call(<span class=\"keyword\">this</span>, name);</div><div class=\"line\"> s2.call(<span class=\"keyword\">this</span>, sex);</div><div class=\"line\"> s3.call(<span class=\"keyword\">this</span>, age);</div><div class=\"line\"> <span class=\"keyword\">this</span>.score = score;</div><div class=\"line\">&#125;</div><div class=\"line\">Student.prototype.constructor = Student;</div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> Student(<span class=\"string\">'jack'</span>, <span class=\"string\">'male'</span>, <span class=\"string\">'12'</span>, <span class=\"string\">'100'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s.name+<span class=\"string\">\" \"</span>+s.age+ <span class=\"string\">\" \"</span> + s.age+<span class=\"string\">\" \"</span>+ s.score);<span class=\"comment\">//jack 12 12 100</span></div></pre></td></tr></table></figure>\n<p>1.使用call()实现多重继承，核心就是用Function类的call方法去绑定新的类，使新的类实例化后的对象继承了该属性及方法<br>2.这样我们就可以根据各个不同的功能模块分不同程序员独立开发，最后合并起来，实现了多重继承。<br>3.但它的缺点是基类的方法只能定义在类中，这样在每次实例化的时候都会创建该方法，造成多余内存占用<br>这也是我们上面的构造继承的缺点</p>\n<p>2.原型链继承</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">s1.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"keyword\">this</span>.name)&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">s2.prototype =<span class=\"keyword\">new</span> s1();</div><div class=\"line\">s2.prototype.constructor = s2;</div><div class=\"line\">s2.prototype.getSex = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"keyword\">this</span>.sex)&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">s3.prototype = <span class=\"keyword\">new</span> s2();</div><div class=\"line\">s3.prototype.constructor = s3;</div><div class=\"line\">s3.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"keyword\">this</span>.age)&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> s3();</div><div class=\"line\">s.name = <span class=\"string\">'jack'</span>;</div><div class=\"line\">s.sex = <span class=\"string\">'male'</span>;</div><div class=\"line\">s.age = <span class=\"string\">'22'</span>;</div><div class=\"line\">s.getName();<span class=\"comment\">//jack</span></div><div class=\"line\">s.getSex();<span class=\"comment\">//male</span></div><div class=\"line\">s.getAge();<span class=\"comment\">//22</span></div></pre></td></tr></table></figure>\n<p>出现代码冗余，而且无法传递参数</p>\n<p>3.混合模式继承<br>就是将上面的两种方式进行结合，扬长避短；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\">s1.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"keyword\">this</span>.name)&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">sex</span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">this</span>.sex = sex;</div><div class=\"line\">&#125;</div><div class=\"line\">s2.prototype =<span class=\"keyword\">new</span> s1();</div><div class=\"line\">s2.prototype.getSex = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"keyword\">this</span>.sex)&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">age</span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">this</span>.age = age</div><div class=\"line\">&#125;</div><div class=\"line\">s3.prototype = <span class=\"keyword\">new</span> s2();</div><div class=\"line\">s3.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;alert(<span class=\"keyword\">this</span>.age)&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> s4 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, sex, age</span>)</span>&#123;</div><div class=\"line\">s1.call(<span class=\"keyword\">this</span>, name);</div><div class=\"line\">s2.call(<span class=\"keyword\">this</span>, sex);</div><div class=\"line\">s3.call(<span class=\"keyword\">this</span>, age);</div><div class=\"line\">&#125;</div><div class=\"line\">s4.prototype = <span class=\"keyword\">new</span> s3();</div><div class=\"line\">s4.prototype.constructor = s4;</div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> s4(<span class=\"string\">'jack'</span>, <span class=\"string\">'male'</span>, <span class=\"string\">'25'</span>);</div><div class=\"line\">s.getName();<span class=\"comment\">//jack</span></div><div class=\"line\">s.getSex();<span class=\"comment\">//male</span></div><div class=\"line\">s.getAge();<span class=\"comment\">//25</span></div></pre></td></tr></table></figure>\n<p>1.属性用构造的方法，方法采用原型模式；大大提高了效率</p>\n<h2 id=\"js中的作用域是什么样子的\"><a href=\"#js中的作用域是什么样子的\" class=\"headerlink\" title=\"js中的作用域是什么样子的\"></a>js中的作用域是什么样子的</h2><h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>全局变量的作用域：全局，在代码定义的任何地方都是有定义的；<br>局部变量和函数的参数只有在函数体内才有定义<br>另外，局部变量的优先级要高于同名的全局变量，也就是说当局部变量与全局变量重名时，局部变量会覆盖<br>全局变量；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">1</span>;            <span class=\"comment\">//声明一个全局变量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">　  <span class=\"keyword\">var</span> num = <span class=\"number\">2</span>;        <span class=\"comment\">//声明一个局部变量</span></div><div class=\"line\">    <span class=\"keyword\">return</span> num;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(func());    <span class=\"comment\">//输出：2</span></div></pre></td></tr></table></figure>\n<p> 注：声明局部变量时一定要使用var,否则，解释器会将该变量当做全局对象window的属性。</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><p>在JavaScript中函数作用域（变量在声明它们的函数体以及这个函数体嵌套的任意函数体都是有定义的）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">           <span class=\"built_in\">console</span>.log(num);           <span class=\"comment\">//输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的</span></div><div class=\"line\">           <span class=\"keyword\">var</span> num = <span class=\"number\">1</span>;                <span class=\"comment\">//声明num 在整个函数体func内都有定义</span></div><div class=\"line\">           <span class=\"built_in\">console</span>.log(num);           <span class=\"comment\">//输出：1</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       func();</div></pre></td></tr></table></figure>\n<p>JavaScript的函数作用域是指在在函数内声明的所有变量在函数体内始终是可见的，也就是说在函数体内变量声明之前就已经可用了<br>作为属性的变量，当声明一个全局变量的时候，实际上是定义了全局对象window的一个属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">1</span>;            <span class=\"comment\">//声明全变量num</span></div><div class=\"line\">      alert(<span class=\"built_in\">window</span>.num)       <span class=\"comment\">//输出：1 声明的全局变量实际上就是声明了一个window对象的属性</span></div></pre></td></tr></table></figure>\n<h2 id=\"js中的this指的是什么\"><a href=\"#js中的this指的是什么\" class=\"headerlink\" title=\"js中的this指的是什么\"></a>js中的this指的是什么</h2><p>1.在全局作用域时：this指向window</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>);  <span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<p>因此,我们在全局作用域声明的变量也会指向this</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);<span class=\"comment\">//1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.x);<span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n<p>2.当在函数中时,this指向调用函数的那个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">num</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);<span class=\"comment\">//0</span></div><div class=\"line\">num();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);<span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n<p>这里就是经常容易犯得错误，很多人觉得，当this已经在一个function之中时，其目前所处位置为当前的局部作用域，所以目前指向的应该是此函数 </p>\n<p>但是，如果你将这个函数实例化（new）之后，此函数将生成一个全新的环境，此时在此实例中的this也会随之发生变化，它将指向所在实例。首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">num = <span class=\"string\">\"0\"</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setThis</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.num = <span class=\"string\">\"1\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.num);<span class=\"comment\">//\"0\"</span></div><div class=\"line\"><span class=\"keyword\">new</span> setThis();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.num);<span class=\"comment\">//\"0\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> setThis().num);<span class=\"comment\">//1</span></div></pre></td></tr></table></figure>\n<p>另外，在我们写javascript的时候，我们通常还会有一种调用函数的方法，即为元素绑定事件，比如button.addEventListener(‘click’, fn, false)等，如果在fn里面需要使用到this的话，那么此时this指向事件处理元素，也就是button</p>\n<p>3.作为对象调用时,this 指代上级对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　alert(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</div><div class=\"line\">o.x = <span class=\"number\">1</span>;</div><div class=\"line\">o.m = test;</div><div class=\"line\">o.m(); <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>总之：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</p>\n<h2 id=\"call-apply-bind的区别是什么\"><a href=\"#call-apply-bind的区别是什么\" class=\"headerlink\" title=\"call,apply,bind的区别是什么\"></a>call,apply,bind的区别是什么</h2><p>一般用来指定的this环境;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=&#123;</div><div class=\"line\">          <span class=\"attr\">user</span>:<span class=\"string\">'少女雨'</span>,</div><div class=\"line\">          <span class=\"attr\">fn</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">              <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.user);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">var</span> b=a.fn;</div><div class=\"line\">      b(); <span class=\"comment\">//undefined</span></div><div class=\"line\">      a.fn();  <span class=\"comment\">//少女雨</span></div></pre></td></tr></table></figure>\n<p>引言：运行b()得到的是undefined，其实和我们的this指向有关系;因为此时this指向的是b;而下面a.fn()为什么能输出来能，因为此时this指向的是我们的a;也就是常说的那句，this始终指向的是调用它的那个对象;<br>虽然a.fn()能打印出我们的数据，但是并不是最科学的方式，这时候可以通过下面的方法：<br>1.call():调用一个对象的一个方法，以另一个对象替换当前对象<br>说明：<br>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。<br>如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=&#123;</div><div class=\"line\">     <span class=\"attr\">user</span>:<span class=\"string\">'少女雨'</span>,</div><div class=\"line\">     <span class=\"attr\">fn</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.user);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">var</span> b=a.fn;</div><div class=\"line\">       b.call(a); <span class=\"comment\">//少女雨</span></div></pre></td></tr></table></figure>\n<p>简单来说：通过在call方法，给定第一个参数；将b添加到哪个环境中，this就会指向那个对象；<br>call方法除了第一个参数以外还能添加多个参数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=&#123;</div><div class=\"line\">           <span class=\"attr\">user</span>:<span class=\"string\">'少女雨'</span>,</div><div class=\"line\">           <span class=\"attr\">fn</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">               <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.user);</div><div class=\"line\">               <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//2</span></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"keyword\">var</span> b=a.fn;</div><div class=\"line\">       b(); <span class=\"comment\">//undefined</span></div><div class=\"line\">       a.fn();  <span class=\"comment\">//少女雨</span></div><div class=\"line\">       b.call(a); <span class=\"comment\">//少女雨</span></div><div class=\"line\">       b.call(a,<span class=\"number\">2</span>);<span class=\"comment\">//少女雨 2</span></div></pre></td></tr></table></figure>\n<p>这样就可以用作传参<br>2.apply():应用某一对象的一个方法，用另一个对象替换当前对象。<br>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。<br>apply方法和call方法相似，它也可以改变this指向；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=&#123;</div><div class=\"line\">     <span class=\"attr\">user</span>:<span class=\"string\">'少女雨'</span>,</div><div class=\"line\">     <span class=\"attr\">fn</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.user);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; </div><div class=\"line\">       <span class=\"keyword\">var</span> b=a.fn;</div><div class=\"line\">       b.apply(a);  <span class=\"comment\">//少女雨</span></div></pre></td></tr></table></figure>\n<p>同样的apply也可以有多个参数，但不同的是，第二个参数必须是一个数组，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=&#123;</div><div class=\"line\">      <span class=\"attr\">user</span>:<span class=\"string\">'少女雨'</span>,</div><div class=\"line\">      <span class=\"attr\">fn</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.user);</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">//10</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; </div><div class=\"line\">        <span class=\"keyword\">var</span> b=a.fn;</div><div class=\"line\">        b.apply(a,[<span class=\"number\">10</span>]);  <span class=\"comment\">//少女雨  10</span></div></pre></td></tr></table></figure>\n<p>注意：如果call和apply的第一个参数是Null,那么this指向的是window对象；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=&#123;</div><div class=\"line\">     <span class=\"attr\">user</span>:<span class=\"string\">'少女雨'</span>,</div><div class=\"line\">     <span class=\"attr\">fn</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">           <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);  </div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; </div><div class=\"line\">       <span class=\"keyword\">var</span> b=a.fn;</div><div class=\"line\">       b.apply(<span class=\"literal\">null</span>);</div><div class=\"line\">       <span class=\"comment\">//Window &#123;stop: function, open: function, alert: function, confirm: function, prompt: function…&#125;</span></div></pre></td></tr></table></figure>\n<p>3.bind() 和call,apply方法不同，但是都可以改变this的指向</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=&#123;</div><div class=\"line\">      <span class=\"attr\">user</span>:<span class=\"string\">'少女雨'</span>,</div><div class=\"line\">      <span class=\"attr\">fn</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.user);       </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; </div><div class=\"line\">        <span class=\"keyword\">var</span> b=a.fn; </div><div class=\"line\">        b.bind(a);</div></pre></td></tr></table></figure>\n<p>这里没有打印出数据；这就是bind和call,apply不同的地方，实际上bind返回的是一个修改过后的函数；<br>你看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> c=b.bind(a); </div><div class=\"line\">        <span class=\"built_in\">console</span>.log(c);</div><div class=\"line\">        <span class=\"comment\">/*function (a)&#123;</span></div><div class=\"line\">            console.log(this.user);       </div><div class=\"line\">            &#125;*/</div></pre></td></tr></table></figure>\n<p>若想打印出数据，需要再执行以下c();<br>同样bind()也可以有多个参数，并且参数可以执行的时候再次添加，但注意，参数是按照形参顺序进行的；<br>就是这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=&#123;</div><div class=\"line\">    <span class=\"attr\">user</span>:<span class=\"string\">'少女雨'</span>,</div><div class=\"line\">    <span class=\"attr\">fn</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b,c</span>)</span>&#123;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.user);   <span class=\"comment\">//少女雨</span></div><div class=\"line\">          <span class=\"built_in\">console</span>.log(a,b,c);     <span class=\"comment\">//1 3 4</span></div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125; </div><div class=\"line\">      <span class=\"keyword\">var</span> b=a.fn; </div><div class=\"line\">      <span class=\"keyword\">var</span> c=b.bind(a,<span class=\"number\">1</span>); </div><div class=\"line\">      c(<span class=\"number\">3</span>,<span class=\"number\">4</span>);</div></pre></td></tr></table></figure>\n<p>总结：call和apply都是改变上下文中的this并立即执行这个函数，都可以添加多个参数，但是apply方法添加的参数必须是一个数组;bind方法可以让对应的函数想什么时候调用就什么时候调用，并且参数可以在执行时候添加</p>\n<h2 id=\"caller-callee和arguments分别是什么\"><a href=\"#caller-callee和arguments分别是什么\" class=\"headerlink\" title=\"caller , callee和arguments分别是什么\"></a>caller , callee和arguments分别是什么</h2><p>1.arguments:在函数调用时，会自动在该函数内部生成一个名为arguments的隐藏对象，该对象类似于数组，但又不是数组；<br>可以用[]操作符获取函数调用时传递的实参,并不局限于函数声明的参数列表;<br>表示被这拗口的话混乱了；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">obj</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"string\">'arguments instanceof Array? '</span> + (<span class=\"built_in\">arguments</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) ); <span class=\"comment\">// arguments instanceof Array? false</span></div><div class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"string\">'arguments instanceof Object? '</span> + (<span class=\"built_in\">arguments</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) );  <span class=\"comment\">// arguments instanceof Object? true</span></div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>);  <span class=\"comment\">//Arguments(0)</span></div><div class=\"line\"> &#125;</div><div class=\"line\"> obj();</div></pre></td></tr></table></figure>\n<p>我们通过控制台显示的数据还看：<br><img src=\"/images/js-4.png\" alt=\"js\"><br>从打印的结果看，arguments是一个对象，并且里面还包含了callee，callee中又包含caller等属性；<br>接下来，我们gia百年代码看看，让函数调用时，传递参数，而函数本身没有参数；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">obj</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">'arguments instanceof Array? '</span> + (<span class=\"built_in\">arguments</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) ); <span class=\"comment\">// arguments instanceof Array? false</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">'arguments instanceof Object? '</span> + (<span class=\"built_in\">arguments</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) );  <span class=\"comment\">// arguments instanceof Object? true</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>);  <span class=\"comment\">//Arguments(0)</span></div><div class=\"line\">&#125;</div><div class=\"line\">obj(<span class=\"string\">'xiaonv'</span>,<span class=\"string\">'LOVE'</span>,<span class=\"number\">23</span>);</div></pre></td></tr></table></figure></p>\n<p>和上面的代码没有什么区别，只是obj传递了参数；<br><img src=\"/images/js-5.png\" alt=\"js\"><br>很显然，Arguments包含了3个参数，也就是我们调用obj()时传递的；<br>所以，也就是说为什么arguments是存储的实际传递给函数的参数呢，而不是函数声明的参数；<br>2.callee<br>上面的截图中，我们已经看到了callee的出现，可以看出，callee是arguments对象的一个成员，并且值就是为我们被执行的obj()方法；<br>我们在obj方法中加入这一句：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>.callee);</div></pre></td></tr></table></figure>\n<p><img src=\"/images/js-6.png\" alt=\"js\"><br>从而可知：arguments.callee是指向参数arguments对象的函数，在这里就是obj咯。<br>3.caller又是哪个？<br>记得上图也出现过，caller则是callee里的一个属性对象；该属性保存着调用当前函数的函数；<br>注意：是调用，不仅仅包含闭包，如果没有父函数，则为null;<br>所以上诉代码中，我们这样输出：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>.callee.caller);  <span class=\"comment\">//null</span></div></pre></td></tr></table></figure></p>\n<p>因为obj方法没有父函数，所以为null；<br>接下来，我们再看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//父函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//子函数</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">         <span class=\"built_in\">console</span>.log(child.caller);</div><div class=\"line\">     &#125;</div><div class=\"line\">    child();</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(parent.caller); <span class=\"comment\">//null</span></div><div class=\"line\">&#125; </div><div class=\"line\">parent();</div></pre></td></tr></table></figure>\n<p>看看输出结果：<br><img src=\"/images/js-7.png\" alt=\"js\"><br>可以看到caller保存的是parent对象；这是因为child有一个父函数parent，并且在父函数中被执行child(); 而后一个parent没有父函数，所以为null；<br>那这样看看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//parent2调用了child2</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent2</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    child2();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child2</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(child2.caller);</div><div class=\"line\">&#125;</div><div class=\"line\"> parent2();</div></pre></td></tr></table></figure>\n<p>结果呢：<br><img src=\"/images/js-8.png\" alt=\"js\"><br>看见区别了吗？ parent2调用了child2，但child2不是嵌套在parent2里的函数；<br>所以只显示了child2();<br>大概就是这样;</p>\n<h2 id=\"什么是闭包，闭包有什么用处\"><a href=\"#什么是闭包，闭包有什么用处\" class=\"headerlink\" title=\"什么是闭包，闭包有什么用处\"></a>什么是闭包，闭包有什么用处</h2><p>相信很多人都会有这个困惑，闭包到底是什么？</p>\n<h3 id=\"什么是闭包呢？\"><a href=\"#什么是闭包呢？\" class=\"headerlink\" title=\"什么是闭包呢？\"></a>什么是闭包呢？</h3><p>闭包是有权访问<b>另一个函数作用域的变量</b>的函数<br>简单点来说：javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数体内，而且，这些内部函数可以访问它们所在的内部函数中声明的所有全局变量，参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包；</p>\n<h3 id=\"作用域的作用\"><a href=\"#作用域的作用\" class=\"headerlink\" title=\"作用域的作用\"></a>作用域的作用</h3><p>这是理解闭包的第一步；前面已经介绍过作用域了，无非就是全局和局部；<br>javascript语言的特殊之处，在于函数内部可以直接读取全局变量；其中内部函数中可以访问外部函数的变量，是因为内部函数的作用域链中包含了外部函数的作用域；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(n); <span class=\"comment\">//999</span></div><div class=\"line\">   &#125;</div><div class=\"line\">   f1();</div></pre></td></tr></table></figure>\n<p>而另一方面，函数外部是无法取到函数内部的值；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;    </div><div class=\"line\">&#125;</div><div class=\"line\">f1();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(n);  <span class=\"comment\">//n is not defined</span></div></pre></td></tr></table></figure>\n<p>还有一点要注意，函数内部声明变量时，一定要使用var命令，不然等于声明了一个全局变量，变量作用域会提升；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　 n=<span class=\"number\">999</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">f1();</div><div class=\"line\">alert(n); <span class=\"comment\">// 999</span></div></pre></td></tr></table></figure>\n<h3 id=\"闭包的几种写法\"><a href=\"#闭包的几种写法\" class=\"headerlink\" title=\"闭包的几种写法\"></a>闭包的几种写法</h3><p>简单介绍下，和上面的定义类的几种方法其实就是闭包；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Circle</span>(<span class=\"params\">r</span>) </span>&#123; </div><div class=\"line\">   <span class=\"keyword\">this</span>.r = r; </div><div class=\"line\">&#125; </div><div class=\"line\">Circle.PI = <span class=\"number\">3.14159</span>; </div><div class=\"line\">Circle.prototype.area = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </div><div class=\"line\">  <span class=\"keyword\">return</span> Circle.PI * <span class=\"keyword\">this</span>.r * <span class=\"keyword\">this</span>.r; </div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> Circle(<span class=\"number\">1.0</span>); </div><div class=\"line\"><span class=\"built_in\">console</span>.log(c.area()); <span class=\"comment\">//3.14159</span></div></pre></td></tr></table></figure>\n<p>还有</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Circle=&#123; </div><div class=\"line\"><span class=\"string\">\"PI\"</span>:<span class=\"number\">3.14159</span>, </div><div class=\"line\"><span class=\"string\">\"area\"</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123; </div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.PI * r * r; </div><div class=\"line\">&#125; </div><div class=\"line\">&#125;; </div><div class=\"line\">alert( Circle.area(<span class=\"number\">1.0</span>) );<span class=\"comment\">//3.14159</span></div></pre></td></tr></table></figure>\n<p>可以结合上面的例子简单理解下；</p>\n<h3 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h3><p>1.可以读取函数内部的变量，<br>2.让这些变量的值始终保持在内存中；<br>但是究竟怎么使用闭包才能读取到函数内的局部变量呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　<span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</div><div class=\"line\">　　<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　 <span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 999</span></div><div class=\"line\">　　&#125;</div><div class=\"line\">f2();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码，我在函数内部再定义了一个函数；f2被包含在f1内部了，所以可以访问f1内部的所有全局变量；<br>但是f1去不能访问f2内部的局部变量；<br>这就是js的“链式作用域”结构，子对象会一级一级的向上寻找所有父对象的变量，所以父对象的所有变量，对子对象都是可见的，反之则不成立；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　<span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</div><div class=\"line\">　　<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　<span class=\"built_in\">console</span>.log(n); </div><div class=\"line\">　　&#125;</div><div class=\"line\">　　<span class=\"keyword\">return</span> f2;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> result=f1();</div><div class=\"line\">result(); <span class=\"comment\">// 999</span></div></pre></td></tr></table></figure></p>\n<p>f2可以读取到f1的变量，那么将f2作为返回值，不久可以在f1中读取到它的内部变量了；<br>但是如何将变量的值存在内存中呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> n=<span class=\"number\">99</span>;</div><div class=\"line\">    nAdd=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//匿名函数</span></div><div class=\"line\">       n+=<span class=\"number\">1</span>; <span class=\"comment\">//全局变量</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(n);</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> f2;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> result=f1();</div><div class=\"line\">result(); <span class=\"comment\">//99</span></div><div class=\"line\">nAdd();</div><div class=\"line\">result(); <span class=\"comment\">//100</span></div></pre></td></tr></table></figure>\n<p>这段代码中result实际上就是闭包f2函数，它一共运行了两次，第一次值是99，第二次是100；这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。<br>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>\n<h3 id=\"闭包与this\"><a href=\"#闭包与this\" class=\"headerlink\" title=\"闭包与this\"></a>闭包与this</h3><p>在闭包中使用this对象会导致一些问题；因为匿名函数的执行具有全局性，而this对象通常指向window对象；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The window\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> object = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>:<span class=\"string\">\"My object\"</span>,</div><div class=\"line\">  <span class=\"attr\">getNameFun</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">  &#125;;</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(object.getNameFun()); <span class=\"comment\">//\"The window\"（在非严格模式下）</span></div></pre></td></tr></table></figure></p>\n<p>但是，将其阿布作用域中的this对象保存在一个闭包能够访问的变量里，就可以让闭包访问该对象啦；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getNameFun:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> that=<span class=\"keyword\">this</span>;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> that.name;</div><div class=\"line\">  &#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用闭包注意点\"><a href=\"#使用闭包注意点\" class=\"headerlink\" title=\"使用闭包注意点\"></a>使用闭包注意点</h3><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>\n<h2 id=\"defineProperty-hasOwnProperty-isEnumerable-都是做什么用的\"><a href=\"#defineProperty-hasOwnProperty-isEnumerable-都是做什么用的\" class=\"headerlink\" title=\"defineProperty,hasOwnProperty,isEnumerable 都是做什么用的?\"></a>defineProperty,hasOwnProperty,isEnumerable 都是做什么用的?</h2><p>javascript中任何一个构造函数对有其对应的原型，我们可以给原型赋予一些我们想要的属性；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Gadget</span>(<span class=\"params\">name,color</span>)</span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">     <span class=\"keyword\">this</span>.color=color;</div><div class=\"line\">     <span class=\"keyword\">this</span>.whatAreYou=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">'I am a'</span> + <span class=\"keyword\">this</span>.color + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.name;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"> Gadget.prototype.price=<span class=\"number\">100</span>;</div><div class=\"line\"> Gadget.prototype.rating=<span class=\"number\">3</span>;</div><div class=\"line\"> Gadget.prototype.getInfo=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"string\">'Rating'</span> +<span class=\"keyword\">this</span>.rating + <span class=\"string\">' ,price:'</span> +<span class=\"keyword\">this</span>.price;</div><div class=\"line\"> &#125;;</div><div class=\"line\"> <span class=\"keyword\">var</span> newtoy=<span class=\"keyword\">new</span> Gadget(<span class=\"string\">'少女雨'</span>,<span class=\"string\">'black'</span>);</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(newtoy);</div></pre></td></tr></table></figure>\n<p>先看看输出结果：<br><img src=\"/images/js-8.png\" alt=\"js\"><br>这里定义了一个Gadget类的实例 –newtoy对象，在这个对象中，我们可以访问对象内部以及其原型对象中的属性和方法；如果想要获得某个对象所有的属性列表，可以使用for-in循环；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> newtoy) &#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(i+ <span class=\"string\">'= '</span> + newtoy[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以得到这样的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">name= 少女雨</div><div class=\"line\">color= black</div><div class=\"line\">whatAreYou= <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">'I am a'</span> + <span class=\"keyword\">this</span>.color + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.name;</div><div class=\"line\">     &#125;</div><div class=\"line\">price= <span class=\"number\">100</span></div><div class=\"line\">rating= <span class=\"number\">3</span></div><div class=\"line\">getInfo= <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"string\">'Rating'</span> +<span class=\"keyword\">this</span>.rating + <span class=\"string\">' ,price:'</span> +<span class=\"keyword\">this</span>.price;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>这时候，如果我们想把原型中的属性过滤掉，就可以首先使用hasOwnProperty()来判断该属性是否属于原型对象内部的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> newtoy) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(newtoy.hasOwnProperty(i))</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(i+ <span class=\"string\">'= '</span> + newtoy[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出结果是这样的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">name= 少女雨</div><div class=\"line\">color= black</div><div class=\"line\">whatAreYou= <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">'I am a'</span> + <span class=\"keyword\">this</span>.color + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意以下几点：</p>\n<blockquote>\n<ul>\n<li>只有那些可枚举的属性才会被显示出来(一般内建属性都是不可枚举的)</li>\n<li>原型中的各个原型属性才会被显示出来，当然前提是它们是可枚举的；</li>\n<li>propertyIsEnumerable()用于测试该属性是否可枚举，对于所以的原型属性，propertyIsEnumerable()都会返回false，包括那些在for-in循环中可枚举的属性。<br>console.log(newtoy.propertyIsEnumerable()) //false<br>但如果propertyIsEnumerable()的调用是来自原型链上的某个对象，那么该对象中的属性是可枚举的。例如：<br>newtoy.constructor.prototype.propertyIsNumerable(‘price’); //返回: ture</li>\n</ul>\n</blockquote>\n<p>另外还有一个比较常用的isPrototypeOf()方法，这个方法告诉我们当前对象是否是另外一个对象的原型；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Gadget</span>(<span class=\"params\">name,color</span>)</span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">     <span class=\"keyword\">this</span>.color=color;</div><div class=\"line\">     <span class=\"keyword\">this</span>.whatAreYou=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">'I am a'</span> + <span class=\"keyword\">this</span>.color + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.name;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"> Gadget.prototype.price=<span class=\"number\">100</span>;</div><div class=\"line\"> Gadget.prototype.rating=<span class=\"number\">3</span>;</div><div class=\"line\"> Gadget.prototype.getInfo=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"string\">'Rating'</span> +<span class=\"keyword\">this</span>.rating + <span class=\"string\">' ,price:'</span> +<span class=\"keyword\">this</span>.price;</div><div class=\"line\"> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Human</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">&#125;</div><div class=\"line\">Gadget.prototype=Human;</div><div class=\"line\"><span class=\"keyword\">var</span> newtoy=<span class=\"keyword\">new</span> Gadget(<span class=\"string\">'少女雨'</span>,<span class=\"string\">'black'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(Gadget.isPrototypeOf(newtoy)); <span class=\"comment\">//false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Human.isPrototypeOf(newtoy));  <span class=\"comment\">//true</span></div></pre></td></tr></table></figure></p>\n<p>第一个输出false，因为newtoy是Gadget的一个实例，不是原型；<br>第二个输出true，因为Human是Gadget的原型，所以也就是newtoy的原型；</p>\n<p>defineProperty是es5新加的给对象属性设置描述符的方法，使用的方式如下：<br>Object.defineProperty(obj,prop,descriptor)  //对象，属性，描述符<br>基本的描述符有这三个：</p>\n<blockquote>\n<ul>\n<li>writable –是否为可写</li>\n<li>configurable – 是否为可配置的</li>\n<li>enumerable – 是否为可枚举的<br>顾名思义，writable设置属性是否为可写，如果是false，那属性之后的修改将会无效<br>configurable属性是否可配置，设置为false后，该属性不可被删除，也不可再更改为可配置的，但是可以从可写改为不可写<br>enumerable 属性是否可枚举，如果是false，则属性不可枚举，不可枚举属性对  for … in语句和Ojbect.keys是不可见的<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;</div><div class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'xu'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o, <span class=\"string\">'name'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">writeable</span>:<span class=\"literal\">false</span>   <span class=\"comment\">//不可写</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o, <span class=\"string\">'name'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">configurable</span>:<span class=\"literal\">false</span>  </div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o, <span class=\"string\">'name'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p>对value的get/set方法采用的就是此方法；</p>\n<h2 id=\"js常用的设计模式的实现思想，单例，工厂，代理，装饰，观察者模式等\"><a href=\"#js常用的设计模式的实现思想，单例，工厂，代理，装饰，观察者模式等\" class=\"headerlink\" title=\"js常用的设计模式的实现思想，单例，工厂，代理，装饰，观察者模式等;\"></a>js常用的设计模式的实现思想，单例，工厂，代理，装饰，观察者模式等;</h2><h3 id=\"什么是设计模式呢？\"><a href=\"#什么是设计模式呢？\" class=\"headerlink\" title=\"什么是设计模式呢？\"></a>什么是设计模式呢？</h3><p>设计模式是一种解决问题的方案，用于解决在软件设计过程中普遍存在的问题；学习设计模式是为了学习如何合理的整理我们的代码；</p>\n<h3 id=\"设计模式六要素\"><a href=\"#设计模式六要素\" class=\"headerlink\" title=\"设计模式六要素\"></a>设计模式六要素</h3><p>单一职责原则：一个类只负责一个功能领域中相应的职责，或者可以定义为：就一个类而言，<br>应该只有一个引起他变化的原因；<br>单一职责原则要求一个类不能承担过多的职责，形成”超级类”。需要根据不同职责分为不同的类，从而降低类的复杂度，提高可阅读性，增加系统的稳定性；<br>开闭原则：一个软件实体应该对扩展开发，对修改关闭，即软件实体应尽量在不修改原有代码<br>的情况下进行扩展；<br>里氏代换原则：所有引用父类的地方都必须能透明的使用起子类的对象；<br>里氏代换原则要求在软件中一个基类能够替换为它的子类而不会因此任何异常。因此要求子类可以扩展父类的功能，但不能修改父类本身的非抽象方法；<br>依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象，换言之，要针对接口编程，而不是针对现实编程；<br>接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。<br>接口隔离原则要求我们设计接口不应太大，接口应仅仅提供客户端需要的行为，在使用此原则时应注意接口的粒度，接口太小会导致接口泛滥，不利于维护，接口太大灵活性较差，使用不便；<br>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用；<br>迪米特法则要求我们应该减少对象之间的交互，如果两个对象之间不必彼此之间直接通信，那么这两个对象就不应该发送任何直接的相互作用，当需要调用另一个对象的某一方法时，可以通过第三者来转发此调用。</p>\n<h3 id=\"几种常用设计模式\"><a href=\"#几种常用设计模式\" class=\"headerlink\" title=\"几种常用设计模式\"></a>几种常用设计模式</h3><h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><p>作用：用来保证一个类只有一个实例，用来解决一个全局使用的类频繁的创建和销毁，从而节约系统资源；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> single = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> unique;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getInstance</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　<span class=\"comment\">// 如果该实例存在，则直接返回，否则就对其实例化</span></div><div class=\"line\">    <span class=\"keyword\">if</span>( unique === <span class=\"literal\">undefined</span> )&#123;</div><div class=\"line\">      unique = <span class=\"keyword\">new</span> Construct();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> unique;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Construct</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ... 生成单例的构造函数的代码</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">getInstance</span> : getInstance</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>可以通过 single.getInstance() 来获取到单例，并且每次调用均获取到同一个单例。这就是 单例模式 所实现的效果。<br>应用场景：适用于我们平常将代码封装起来，只暴露一个入口，从而避免全部变量被污染；</p>\n<h4 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h4><p>概念：提供创建对象的接口，根据调用者的参数，生产相对应的产品；<br>分类：<br>简单工厂模式:使用一个类，通常为单体，来生成实例；<br>复杂工厂模式：将其成员对象的实例化推到子类中，子子类可以重写父类接口方法以便创建的时候指定自己的对象类型。父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。<br>简单工厂模式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> XMLHttpFactory =<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;　　　　　　<span class=\"comment\">//这是一个简单工厂模式</span></div><div class=\"line\">　　XMLHttpFactory.createXMLHttp =<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　 <span class=\"keyword\">var</span> XMLHttp = <span class=\"literal\">null</span>;</div><div class=\"line\">　　　　<span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest)&#123;</div><div class=\"line\">　　　　　　XMLHttp = <span class=\"keyword\">new</span> XMLHttpRequest()</div><div class=\"line\">　　　 &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.ActiveXObject)&#123;</div><div class=\"line\">　　　　　　XMLHttp = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">\"Microsoft.XMLHTTP\"</span>)</div><div class=\"line\">　　　　&#125;</div><div class=\"line\">　　<span class=\"keyword\">return</span> XMLHttp;</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　<span class=\"comment\">//XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。</span></div><div class=\"line\">　　<span class=\"keyword\">var</span> AjaxHander =<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　<span class=\"keyword\">var</span> XMLHttp = XMLHttpFactory.createXMLHttp();</div><div class=\"line\">　　　　...</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure></p>\n<p>复杂工厂模式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> XMLHttpFactory =<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;　   <span class=\"comment\">//这是一个抽象工厂模式</span></div><div class=\"line\">XMLHttpFactory.prototype = &#123;</div><div class=\"line\">　　<span class=\"comment\">//如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类</span></div><div class=\"line\">　　createFactory:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"> 　　<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'This is an abstract class'</span>);</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> XHRHandler =<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;; <span class=\"comment\">//定义一个子类</span></div><div class=\"line\"><span class=\"comment\">// 子类继承父类原型方法</span></div><div class=\"line\">extend( XHRHandler , XMLHttpFactory );</div><div class=\"line\">XHRHandler.prototype =<span class=\"keyword\">new</span> XMLHttpFactory(); <span class=\"comment\">//把超类原型引用传递给子类,实现继承</span></div><div class=\"line\">XHRHandler.prototype.constructor = XHRHandler; <span class=\"comment\">//重置子类原型的构造器为子类自身</span></div><div class=\"line\"><span class=\"comment\">//重新定义createFactory 方法</span></div><div class=\"line\">XHRHandler.prototype.createFactory =<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　<span class=\"keyword\">var</span> XMLHttp =<span class=\"literal\">null</span>;</div><div class=\"line\">　　<span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest)&#123;</div><div class=\"line\"> 　　XMLHttp =<span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">　　&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.ActiveXObject)&#123;</div><div class=\"line\"> 　　XMLHttp =<span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">\"Microsoft.XMLHTTP\"</span>)</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　<span class=\"keyword\">return</span> XMLHttp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>简单对象使用工厂模式会增加其系统的复杂度。所以工厂模式适用的场景只是对象的构建十分复杂<br>，处理大量具有相同属性的小对象，需要依赖具体环境创建不同实例；</p>\n<h4 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h4><p>概念：把对一个对象的访问, 交给另一个代理对象来操作<br>举一个例子：我们公司的补打卡是最后是要交给大boss来审批的，但是公司那么多人，每天都那么多补打卡，那大boss岂不是被这些琐事累死。所以大boss下会有一个助理，来帮忙做这个审批，最后再将每个月的补打卡统一交给大boss看看就行；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 补打卡事件</span></div><div class=\"line\"><span class=\"keyword\">var</span> fillOut = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">lateDate</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.lateDate = lateDate;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 这是bigBoss</span></div><div class=\"line\"><span class=\"keyword\">var</span> bigBoss = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fillOut</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.state = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">isSuccess</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"忘记打卡的日期为：\"</span> + fillOut.lateDate + <span class=\"string\">\", 补打卡状态：\"</span> + isSuccess);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 助理代理大boss 完成补打卡审批</span></div><div class=\"line\"><span class=\"keyword\">var</span> proxyAssis = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fillOut</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.state = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">isSuccess</span>) </span>&#123;</div><div class=\"line\">    (<span class=\"keyword\">new</span> bigBoss(fillOut)).state(isSuccess); <span class=\"comment\">// 替bigBoss审批</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 调用方法：</span></div><div class=\"line\"><span class=\"keyword\">var</span> proxyAssis = <span class=\"keyword\">new</span> proxyAssis(<span class=\"keyword\">new</span> fillOut(<span class=\"string\">\"2016-9-11\"</span>));</div><div class=\"line\">proxyAssis.state(<span class=\"string\">\"补打卡成功\"</span>);</div><div class=\"line\"><span class=\"comment\">// 忘记打卡的日期为：2016-9-11, 补打卡状态：补打卡成功</span></div></pre></td></tr></table></figure>\n<p>应用场景：比如图片的懒加载，我们就可以运用这种技术。在图片未加载完成之前，给个loading图片，加载完成后再替换成实体路径。<br>还有解决跨域问题都能采用代理模式；</p>\n<h4 id=\"观察者模式（发布订阅\"><a href=\"#观察者模式（发布订阅\" class=\"headerlink\" title=\"观察者模式（发布订阅)\"></a>观察者模式（发布订阅)</h4><p>概念：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。<br>它需要一种高级的抽象策略，以便订阅者能够彼此独立地发生改变，而发行方能够接受任何有消费意向的订阅者。<br>发布订阅流程：</p>\n<ol>\n<li>确定谁是发布者(比如我的博客)。</li>\n<li>然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者。</li>\n<li>发布消息，发布者需要遍历这个缓存列表，依次触发里面存放的订阅者回调函数。</li>\n<li>退订（比如不想再接收到这些订阅的信息了，就可以取消掉）<br>这种其实很好理解，特别是我学习了框架之后，subscribe用来订阅；unsubscribe取消订阅；</li>\n</ol>\n<p>还有更多设计模式；可以自行去了解下；</p>\n<h2 id=\"列举数组相关的方法\"><a href=\"#列举数组相关的方法\" class=\"headerlink\" title=\"列举数组相关的方法\"></a>列举数组相关的方法</h2><p>一个简单数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mycars=<span class=\"keyword\">new</span> Arrat();</div><div class=\"line\">mycars[<span class=\"number\">0</span>]=<span class=\"string\">'Sab'</span>;</div><div class=\"line\">mycars[<span class=\"number\">1</span>]=<span class=\"string\">'Volvo'</span>;</div><div class=\"line\">mycars[<span class=\"number\">2</span>]=<span class=\"string\">'BMW'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(mycars);</div></pre></td></tr></table></figure></p>\n<p>输出结果很简单，就是这样：<br><img src=\"/images/js-10.png\" alt=\"js\"><br>从图可以看出数组有啥属性吧，length,construtor,prototype;现在主要来介绍数组的方法；<br><img src=\"/images/js-11.png\" alt=\"js\"><br>看看如何使用：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myage.forEach(myFunction)\"</span>&gt;</span>点我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mycars=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\"> mycars[<span class=\"number\">0</span>]=<span class=\"string\">'Sab'</span>;</div><div class=\"line\"> mycars[<span class=\"number\">1</span>]=<span class=\"string\">'Volvo'</span>;</div><div class=\"line\"> mycars[<span class=\"number\">2</span>]=<span class=\"string\">'BMW'</span>;</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mycars);  <span class=\"comment\">//[\"Sab\", \"Volvo\", \"BMW\"]</span></div><div class=\"line\"> <span class=\"keyword\">var</span> myshops=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">'小雨'</span>,<span class=\"string\">'haha'</span>);</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myshops);<span class=\"comment\">//[\"小雨\", \"haha\"]</span></div><div class=\"line\"> <span class=\"keyword\">var</span> mys=mycars.concat(myshops);</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys);<span class=\"comment\">//[\"Sab\", \"Volvo\", \"BMW\", \"小雨\", \"haha\"]</span></div><div class=\"line\"> <span class=\"keyword\">var</span> mybeds=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">'床'</span>);</div><div class=\"line\"> <span class=\"keyword\">var</span> mys=myshops.concat(mybeds,mycars);</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys);<span class=\"comment\">//[\"小雨\", \"haha\", \"床\", \"Sab\", \"Volvo\", \"BMW\"]</span></div><div class=\"line\"> <span class=\"comment\">//所以concat不止传入一个参数，和拼接顺序有关；</span></div><div class=\"line\"> mycars.copyWithin(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mycars);<span class=\"comment\">//[\"Sab\", \"Sab\", \"Volvo\"]</span></div><div class=\"line\"> <span class=\"comment\">//copyWiththin是用于数组内部的</span></div><div class=\"line\"> <span class=\"keyword\">var</span> myage=[<span class=\"number\">32</span>,<span class=\"number\">15</span>,<span class=\"number\">25</span>,<span class=\"number\">25</span>];</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkAdult</span>(<span class=\"params\">age</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> age&gt;=<span class=\"number\">18</span>;</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myage.every(checkAdult));<span class=\"comment\">//false</span></div><div class=\"line\"> <span class=\"comment\">//every用于检测所有元素是否都符合条件，有一个不满足都会返回false；如果有一个返回false，则其余的并不会被检测；并外不能检测空数组；和 some方法相反，some方法一旦有满足条件就返回true；</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myage.filter(checkAdult));<span class=\"comment\">//[32, 25, 25]</span></div><div class=\"line\"> <span class=\"comment\">//filter输出的是符合检索的所有值，对空数组无效</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myage.find(checkAdult)); <span class=\"comment\">//32</span></div><div class=\"line\"> <span class=\"comment\">//find返回的是符合条件的第一个值，如果没有符合条件的就返回undefined，对空数组无效</span></div><div class=\"line\"> <span class=\"comment\">//对于以上的检索方法都是传入一个检查条件</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myage.findIndex(checkAdult));<span class=\"comment\">//0</span></div><div class=\"line\"> <span class=\"comment\">//findIndex 顾名思义，返回的是符合条件的值的索引值，和上面的find类似；没有返回-1；</span></div><div class=\"line\"> mycars.fill(<span class=\"string\">'shaonvyu'</span>);</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mycars);<span class=\"comment\">//[\"shaonvyu\", \"shaonvyu\", \"shaonvyu\"]</span></div><div class=\"line\"> <span class=\"comment\">//fill 使用一个固定值来替换数组中所有的值，对空数组无效</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\">item, index</span>) </span>&#123;</div><div class=\"line\">   <span class=\"built_in\">console</span>.log(  <span class=\"string\">\"index[\"</span> + index + <span class=\"string\">\"]: \"</span> + item );  <span class=\"comment\">//index[0]: 32  index[1]: 15   index[2]: 25   index[3]: 25</span></div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"comment\">//forEach用于调用数组中的每一个元素，并将元素给回调函数，有一个用于场景，点击的时候想获取每一个列表的值，但是使用for返回的总是只有最后一个，这时候可以试试forEach；对空数组无效;</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mycars.indexOf(<span class=\"string\">'Sab'</span>)); <span class=\"comment\">//-1</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myshops.indexOf(<span class=\"string\">'haha'</span>));  <span class=\"comment\">//1</span></div><div class=\"line\"> <span class=\"comment\">//indexof用来返回某个指定字符串首次出现在数组中的位置,按从左到右顺序索引的，如果想反过来就使用lastIndexOf；没有找到则返回-1；</span></div><div class=\"line\"> <span class=\"comment\">//但是上面的两个输出为什么第一个是-1,从直观感觉看，Sab这个值却是在mycars数组中；那是因为数组开始时new的一个空数组，Sab是我们后来加入进去的值，采用Indexof索引的是原始数组，所以找不到；</span></div><div class=\"line\"> <span class=\"keyword\">var</span> join=mycars.join();</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(join); <span class=\"comment\">//shaonvyu,shaonvyu,shaonvyu</span></div><div class=\"line\"> <span class=\"comment\">// join用于把数组中的所有元素转换成一个字符串，用,或者指定的符号进行分割；为什么输出是shaonvyu呢，因为上面的fill方法；</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myage.map(<span class=\"built_in\">Math</span>.sqrt)); <span class=\"comment\">//[5.656854249492381, 3.872983346207417, 5, 5]</span></div><div class=\"line\"> <span class=\"comment\">//map返回一个新的数组，数组中的值是经过函数调用返回的值，对空数组无效，按序处理</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys);<span class=\"comment\">//[\"小雨\", \"haha\", \"床\", \"Sab\", \"Volvo\", \"BMW\"]</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys.pop());<span class=\"comment\">//BMW</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys);<span class=\"comment\">//[\"小雨\", \"haha\", \"床\", \"Sab\", \"Volvo\"]</span></div><div class=\"line\"> <span class=\"comment\">//pop方法删除数组的最后一个元素，并返回被删除元素的值；会改变数组长度，shift方法用来删除数组的第一个元素，和pop相反；</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys.shift()); <span class=\"comment\">//小雨</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys.indexOf(<span class=\"string\">'haha'</span>)); <span class=\"comment\">//0</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mycars.push(<span class=\"string\">'Sab'</span>)); <span class=\"comment\">//4</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mycars);<span class=\"comment\">//[\"shaonvyu\", \"shaonvyu\", \"shaonvyu\", \"Sab\"]</span></div><div class=\"line\"> <span class=\"comment\">//push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。新增的元素被添加在末尾;改变了数组长度，如果想在开始位置添加，使用unshift方法;都是返回新的长度</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSum</span>(<span class=\"params\">total,age</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> total + age;</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myage.reduce(getSum));<span class=\"comment\">//97</span></div><div class=\"line\"> <span class=\"comment\">// reduce 只返回一个值，从左到右开始计算，作为一个累加，如果想从右到左，使用reduceRight方法，功能一样</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myshops.reverse()); <span class=\"comment\">//[\"haha\", \"小雨\"]</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myshops);<span class=\"comment\">//[\"haha\", \"小雨\"]</span></div><div class=\"line\"> <span class=\"comment\">//reverse 反序输出数组，将数组顺序颠倒；</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys);<span class=\"comment\">//[\"haha\", \"床\", \"Sab\", \"Volvo\"]</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys.slice(<span class=\"number\">1</span>,<span class=\"number\">3</span>)); <span class=\"comment\">//[\"床\", \"Sab\"]</span></div><div class=\"line\"> <span class=\"comment\">//slice方法从已有数组中返回指定的部分，并返回出来，输出的是索引，取前不取后；不改变原始数组</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys);<span class=\"comment\">//[\"haha\", \"床\", \"Sab\", \"Volvo\"]</span></div><div class=\"line\"> mys.splice(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"string\">\"HRE\"</span>,<span class=\"string\">\"DDD\"</span>)</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys);<span class=\"comment\">//[\"haha\", \"床\", \"HRE\", \"DDD\", \"Sab\", \"Volvo\"]</span></div><div class=\"line\"> <span class=\"comment\">//splice() 方法用于插入、删除或替换数组的元素。会改变原始数组</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(myage.sort()); <span class=\"comment\">//[15, 25, 25, 32]</span></div><div class=\"line\"> <span class=\"keyword\">var</span> a=[<span class=\"number\">-1</span>,<span class=\"number\">3</span>,<span class=\"number\">45</span>,<span class=\"number\">8</span>,<span class=\"number\">35</span>];</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(a.sort()); <span class=\"comment\">//[-1,3,45,8]</span></div><div class=\"line\"> <span class=\"comment\">//sort对数组内的字母或数字进行排序，并按升序或者降序，默认是升序；这个方法会改变原始数组;注意不能对还有负数的数组进行排序</span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mys.toString())<span class=\"comment\">//haha,床,HRE,DDD,Sab,Volvo</span></div><div class=\"line\"> <span class=\"comment\">//tostring是最常用的， 可把数组转换为字符串，并返回结果。数组中的元素之间用逗号分隔。 </span></div><div class=\"line\"> <span class=\"built_in\">console</span>.log(mycars.valueOf()); <span class=\"comment\">//[\"shaonvyu\", \"shaonvyu\", \"shaonvyu\", \"Sab\"]</span></div><div class=\"line\"> <span class=\"comment\">//valueOf返回数组的原始值，和mycars输出的值一样，原始值指的是Array 对象派生的所有对象继承出来的值，不改变数组长度</span></div></pre></td></tr></table></figure>\n<p>以上就是所有的数组方法了；</p>\n<h2 id=\"列举与字符串相关的常用方法\"><a href=\"#列举与字符串相关的常用方法\" class=\"headerlink\" title=\"列举与字符串相关的常用方法\"></a>列举与字符串相关的常用方法</h2><p>首先应该知道字符串就是一个或多个排列在一起的字符，放在单引号或双引号之中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">var</span> str=<span class=\"string\">\"abcdfe\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.length);<span class=\"comment\">//6</span></div></pre></td></tr></table></figure></p>\n<p>字符串只有一个属性，就是length；<br>常用的多一些方法：<br><img src=\"/images/js-12.png\" alt=\"js\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str=<span class=\"string\">\"abcdfe\"</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.length);<span class=\"comment\">//6</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.charAt(<span class=\"number\">2</span>)); <span class=\"comment\">//c</span></div><div class=\"line\">    <span class=\"comment\">//charAt(n) 传入的是一个索引值，如果不在 0~str.length-1之间，则返回一个空字符串</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.charCodeAt(<span class=\"number\">2</span>));<span class=\"comment\">//99</span></div><div class=\"line\">    <span class=\"comment\">//charCodeAt() 用法和charAt一样，只是返回的是指定位置的Unicode值, fromCharCode()将unicode值转成字符串</span></div><div class=\"line\">    <span class=\"keyword\">var</span> str1=<span class=\"string\">\"fdrref\"</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> a=str.concat(str1);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(a)<span class=\"comment\">//abcdfefdrref</span></div><div class=\"line\">    <span class=\"comment\">//concat 连接两个或多个字符串，返回连接后的字符串</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.indexOf(<span class=\"string\">'c'</span>));<span class=\"comment\">//c</span></div><div class=\"line\">    <span class=\"comment\">//indexof返回 substr 在字符串 str 中首次出现的位置,从 start 位置开始查找，如果不存在，则返回 -1。start可以是任意整数，默认值为 0。如果 start &lt; 0 则查找整个字符串（如同传进了 0）。如果 start &gt;= str.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，此时返回 str.length.从最后一个位置查找lastIndexOf()</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str1.localeCompare(str));<span class=\"comment\">//1 </span></div><div class=\"line\">    <span class=\"comment\">//localCompare用本地特定的顺序来比较两个字符串，大于返回1，小于返回-1</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/ab/</span>)) <span class=\"comment\">//[\"ab\", index: 0, input: \"abcdfe\"]</span></div><div class=\"line\">    <span class=\"comment\">//match 返回一个包含匹配结果的数组，如果没有匹配项，则返回 null。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象,返回一个数组</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.replace(<span class=\"string\">'a'</span>,<span class=\"string\">'love'</span>));<span class=\"comment\">//lovebcdfe</span></div><div class=\"line\">    <span class=\"comment\">//replace  str.replace(regexp|substr, newSubStr|function)  替换 str 的子字符串 不改变原始字符串</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str);<span class=\"comment\">//abcdfe</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.search(<span class=\"regexp\">/d/</span>)); <span class=\"comment\">//3</span></div><div class=\"line\">    <span class=\"comment\">//search() 查找 str 与一个正则表达式是否匹配。如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引；否则，返回 -1。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.slice(<span class=\"number\">3</span>,<span class=\"number\">-1</span>))<span class=\"comment\">//df</span></div><div class=\"line\">    <span class=\"comment\">//slice 返回从 start 到 end （不包括）之间的字符，可传负值;</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.split(<span class=\"string\">'b'</span>)); <span class=\"comment\">//[\"abcdfe\"]</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.split(<span class=\"string\">'b'</span>));<span class=\"comment\">//[\"a\", \"cdfe\"]</span></div><div class=\"line\">    <span class=\"comment\">//split 返回一个数组，分隔符 separator 可以是一个字符串或正则表达式,把字符串分割为子字符串数组</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str);<span class=\"comment\">//abcdfe</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.substr(<span class=\"number\">4</span>,<span class=\"number\">2</span>)); <span class=\"comment\">//fe</span></div><div class=\"line\">    <span class=\"comment\">// 返回 str 中从指定位置开始到指定长度的子字符串，start可为负值,第一个表示索引，第二个表示长度</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.substring(<span class=\"number\">2</span>,<span class=\"number\">5</span>));<span class=\"comment\">//cdf  </span></div><div class=\"line\">    <span class=\"comment\">//提取字符串中两个指定的索引号之间的字符  都是取前不取后</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.toLocaleLowerCase()); <span class=\"comment\">//abcdfe</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.toLocaleUpperCase()); <span class=\"comment\">//ABCDFE</span></div><div class=\"line\">    <span class=\"comment\">//toLocaleLowerCase()根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射，toLocaleUpperCase()反之</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.toLowerCase());<span class=\"comment\">//abcdfe</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.toUpperCase()); <span class=\"comment\">//ABCDFE</span></div><div class=\"line\">    <span class=\"comment\">//将指定字符串转换成小写或者大写</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.toString());<span class=\"comment\">//abcdfe</span></div><div class=\"line\">    <span class=\"comment\">//tostring \t返回字符串对象值</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a=<span class=\"string\">\" fdfde dffd \"</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(a.trim()); <span class=\"comment\">//fdfde dffd</span></div><div class=\"line\">    <span class=\"comment\">//trim移除字符串首尾空白，中间的不移除</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(str.valueOf());<span class=\"comment\">//abcdfe</span></div><div class=\"line\">    <span class=\"comment\">//返回某个字符串的原始值，和直接输出一样</span></div></pre></td></tr></table></figure>\n<p>好了，所有的字符串的方法都在这里呀；</p>\n<h2 id=\"判断一个字符串中出现次数最多的字符，统计这个次数\"><a href=\"#判断一个字符串中出现次数最多的字符，统计这个次数\" class=\"headerlink\" title=\"判断一个字符串中出现次数最多的字符，统计这个次数\"></a>判断一个字符串中出现次数最多的字符，统计这个次数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'asdfdffhwfeuwdasdsaaaaaaaa'</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> json = &#123;&#125;;</div><div class=\"line\">    <span class=\"comment\">//遍历str拆解其中的每一个字符，将其中某个字符得到值及其出现的次数拿出来作为json的key和value</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; str.length; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">//判断json中是否有当前str值</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!json[str.charAt(i)]) &#123;</div><div class=\"line\">        <span class=\"comment\">//如果不存在，就将当前值添加到json中去；</span></div><div class=\"line\">        json[str.charAt(i)] = <span class=\"number\">1</span>;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//else的话就让数组中已有的当前值的index值++；</span></div><div class=\"line\">        json[str.charAt(i)]++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(json); </div><div class=\"line\">    <span class=\"comment\">//储存出现次数最多的值和次数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> iMax = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> iIndex = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"comment\">//遍历json 使用打擂算法统计需要的值</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> json) &#123;</div><div class=\"line\">      <span class=\"comment\">//如果当前项大于下一项</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (json[i] &gt; iMax) &#123;</div><div class=\"line\">        <span class=\"comment\">//让当前值更改为出现次数最多的值</span></div><div class=\"line\">        iMax = json[i];</div><div class=\"line\">        iIndex = i;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//打印最终结果</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log (<span class=\"string\">'出现最多的值是'</span>+ iIndex+ <span class=\"string\">'出现的次数为'</span>+iMax); <span class=\"comment\">//出现最多的值是a出现的次数为10</span></div></pre></td></tr></table></figure>\n<p>看看json 里面存入的值：<br><img src=\"/images/js-13.png\" alt=\"js\"></p>\n<h2 id=\"编写一个方法，求一个字符串的字节长度\"><a href=\"#编写一个方法，求一个字符串的字节长度\" class=\"headerlink\" title=\"编写一个方法，求一个字符串的字节长度\"></a>编写一个方法，求一个字符串的字节长度</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str=<span class=\"string\">\"22来那个\"</span>;</div><div class=\"line\">   <span class=\"built_in\">console</span>.log(getStrlen(str)); <span class=\"comment\">//3 5</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getStrlen</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> json=&#123;<span class=\"attr\">len</span>:<span class=\"number\">0</span>&#125;;</div><div class=\"line\">     <span class=\"keyword\">var</span> re=<span class=\"regexp\">/[\\u4e00-\\u9fa5]/</span>;</div><div class=\"line\">     <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;str.length;i++)&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span>(re.test(str.charAt(i)))&#123;</div><div class=\"line\">         json[<span class=\"string\">'len'</span>]++;</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;;</div><div class=\"line\">     <span class=\"keyword\">return</span> json[<span class=\"string\">'len'</span>]+<span class=\"string\">\" \"</span>+str.length;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>关于里面的正则表达式，可以<a href=\"http://www.sulishibaobei.com/js/zhengze20170925/\">看这里</a></p>\n<h2 id=\"JavaScript中如何检测一个变量是一个String类型？请写出函数实现\"><a href=\"#JavaScript中如何检测一个变量是一个String类型？请写出函数实现\" class=\"headerlink\" title=\"JavaScript中如何检测一个变量是一个String类型？请写出函数实现\"></a>JavaScript中如何检测一个变量是一个String类型？请写出函数实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typeof</span>(obj)==<span class=\"string\">'string'</span>;</div><div class=\"line\">obj.constructor==<span class=\"built_in\">String</span>;</div></pre></td></tr></table></figure>\n<p>说到数据类型，补充一点：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> &#123;&#125;);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> []);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>);</div></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">object</div><div class=\"line\">object</div><div class=\"line\">object</div><div class=\"line\"><span class=\"literal\">undefined</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"给String对象定义一个repeatify方法。该方法接收一个整数参数，作为字符串重复的次数，最后返回重复指定次数的字符串\"><a href=\"#给String对象定义一个repeatify方法。该方法接收一个整数参数，作为字符串重复的次数，最后返回重复指定次数的字符串\" class=\"headerlink\" title=\"给String对象定义一个repeatify方法。该方法接收一个整数参数，作为字符串重复的次数，最后返回重复指定次数的字符串\"></a>给String对象定义一个repeatify方法。该方法接收一个整数参数，作为字符串重复的次数，最后返回重复指定次数的字符串</h2><p>例如：console.log(‘hello’.repeatify(3));<br>输出：hellohellohello.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.prototype.repeatify=<span class=\"built_in\">String</span>.prototype.repeatify || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">times</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> str=<span class=\"string\">''</span>;</div><div class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;times;i++)&#123;</div><div class=\"line\">       str+=<span class=\"keyword\">this</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> str;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>.repeatify(<span class=\"number\">3</span>)) <span class=\"comment\">//hellohellohello</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"下面这段代码的结果是什么？为什么？\"><a href=\"#下面这段代码的结果是什么？为什么？\" class=\"headerlink\" title=\"下面这段代码的结果是什么？为什么？\"></a>下面这段代码的结果是什么？为什么？</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//undefined</span></div><div class=\"line\">     <span class=\"built_in\">console</span>.log(foo()); <span class=\"comment\">//2</span></div><div class=\"line\">     <span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   test();</div></pre></td></tr></table></figure>\n<p>变量和函数的声明都被提前至函数体的顶部，而同时变量并没有被赋值；因此，当打印变量a时，它虽然存在于函数体，仍然是Undefined;</p>\n","comments":true,"categories":[{"name":"前端面试题整理","slug":"前端面试题整理","permalink":"http://www.sulishibaobei.com/categories/前端面试题整理/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.sulishibaobei.com/tags/javascript/"},{"name":"面试","slug":"面试","permalink":"http://www.sulishibaobei.com/tags/面试/"},{"name":"字符串,数组,设计模式","slug":"字符串-数组-设计模式","permalink":"http://www.sulishibaobei.com/tags/字符串-数组-设计模式/"}]},{"title":"简述alert和console.log的区别","date":"2017-09-05T03:08:53.000Z","path":"js/console20170905/","text":"生活中还是得有发现美好和差别的眼睛, 学习前端那么久既然还不知道alert和console.log的差别;本菜鸟一直以为alert和console.log其实是一样的用法，只是alert以弹出框形式呈现，而console.log在控制台输出而已。只到道昨天输出一段代码，结果发现alert和console.log输出结果不一样,本宝宝可算涨见识了, 然后就是各种查阅资料，百度查看，终于发现点眉目啦 ; 我写了这样一段代码：alert输出的结果为：console.log输出的结果为： 然后我就尴尬了 [1]原来console.log() 可以打印任何类型的数据。而 alert() 只能输出string，[2]如果alert输出是对象会自动调用 toString() 方法。如果想 console.log() 输出的与alert相同，需要调用 toString()。[3]所以将后面的改写成&nbsp;console.log(hmac.toString()) 就可以啦 下面再来总结下两者的差别123456789101112alert() 1.1 有阻塞作用，不点击确定，后续代码无法继续执行 1.2 alert()只能输出string,如果alert输出的是对象会自动调用toString()方法 e.g. alert([a,b,c]); //a,b,c 1.3 alert不支持多个参数的写法,只能输出第一个值 e.g. alert(1,2,3); // 1console.log() 2.1 在打印台输出 2.2 可以打印任何类型的数据 e.g. console.log([a,b,c]); //[a,b,c] 2.3 支持多个参数的写法 e.g. console.log(1,2,3) // 1 2 3 好啦~~~就是这样啦。","content":"<p><strong>生活中还是得有发现美好和差别的眼睛, 学习前端那么久既然还不知道alert和console.log的差别;</strong><br>本菜鸟一直以为alert和console.log其实是一样的用法，只是alert以弹出框形式呈现，而console.log在控制台输出而已。只到道昨天输出一段代码，结果发现alert和console.log输出结果不一样,本宝宝可算涨见识了, 然后就是各种查阅资料，百度查看，终于发现点眉目啦 ;</p>\n<a id=\"more\"></a>\n<p><strong>我写了这样一段代码：</strong><br><img src=\"/images/console-3.png\" alt=\"cmd-markdown-logo\"><br>alert输出的结果为：<br><img src=\"/images/console-1.png\" alt=\"cmd-markdown-logo\"><br>console.log输出的结果为：<br><img src=\"/images/console-2.png\" alt=\"cmd-markdown-logo\"></p>\n<p><strong>然后我就尴尬了</strong></p>\n<p>[1]原来console.log() 可以打印任何类型的数据。而 alert() 只能输出string，<br>[2]如果alert输出是对象会自动调用 toString() 方法。如果想 console.log() 输出的与alert相同，需要调用 toString()。<br>[3]所以将后面的改写成&nbsp;console.log(hmac.toString()) 就可以啦</p>\n<p><strong>下面再来总结下两者的差别</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert()</div><div class=\"line\">   <span class=\"number\">1.1</span> 有阻塞作用，不点击确定，后续代码无法继续执行</div><div class=\"line\">   <span class=\"number\">1.2</span> alert()只能输出string,如果alert输出的是对象会自动调用toString()方法 </div><div class=\"line\">      e.g. alert([a,b,c]); <span class=\"comment\">//a,b,c  </span></div><div class=\"line\">   <span class=\"number\">1.3</span> alert不支持多个参数的写法,只能输出第一个值</div><div class=\"line\">      e.g. alert(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>); <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log()</div><div class=\"line\">   <span class=\"number\">2.1</span> 在打印台输出</div><div class=\"line\">   <span class=\"number\">2.2</span> 可以打印任何类型的数据</div><div class=\"line\">        e.g. console.log([a,b,c]); <span class=\"comment\">//[a,b,c]</span></div><div class=\"line\">   <span class=\"number\">2.3</span> 支持多个参数的写法</div><div class=\"line\">        e.g. console.log(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>) <span class=\"comment\">// 1 2 3</span></div></pre></td></tr></table></figure></p>\n<p>好啦~~~就是这样啦。 </p>\n","comments":true,"categories":[{"name":"前端那些微小事","slug":"前端那些微小事","permalink":"http://www.sulishibaobei.com/categories/前端那些微小事/"}],"tags":[{"name":"console.log","slug":"console-log","permalink":"http://www.sulishibaobei.com/tags/console-log/"},{"name":"alert","slug":"alert","permalink":"http://www.sulishibaobei.com/tags/alert/"},{"name":"javascript","slug":"javascript","permalink":"http://www.sulishibaobei.com/tags/javascript/"}]},{"title":"Angular 2+ 设置组件样式的那些事","date":"2017-09-02T03:05:53.000Z","path":"angular/style/component-style20170902/","text":"你用Angular吗？ 介绍 :如何只改动最简单的css代码，呈现完全不一样的视图效果。第一种：最基本的设置： 图1 代码图2 界面运行效果图平常，想给一个label或者p等标签添加样式，我们就是这样操作，在Angular中也是一样的。现在，如果我想要将字体换成红色呢，首先想到的就是去修改.label里的color属性值，可如果样式表是封装的或者外部引用的，不方便修改呢？这时候就要用到ElementRef 和Renderer2了。可以去Angular 官网里搜索哟。&nbsp; renderer.class 图### 第二种:我们可以这样用&nbsp; label.html&nbsp; label.ts当然ElementRef和renderer2都引用自@angular/core库里面的。 至于ViewChild 和ngAfterViewInit()可以自行去了解。&nbsp;&nbsp;&nbsp; 修改效果图 当然，你说这样修改的弊端有没有呢？肯定是有的，因为，this.el.nativeElement获取的是当前元素，如果用*ngFor生成了一系列的label的话，它只会给你修改第一个label的。那有没有其他的办法可以修改呢。当然也是有的！ 第三种：我们可以获取到元素的节点进行操作? &nbsp; label.ts 获取元素节点，还是用上面的elementref。 如果要改变所有的，For循环皆可以啦。可是，这样做又有问题了？如果想不同的label不同字体颜色怎么办呢？当然Angular也提供了方法呀？ ngStyle和ngClass可以用呀！ &nbsp;ngStyle [ngStyle]=”{color:’&nbsp; ‘}”&nbsp; 和[style.color]是一样的意思。你的label想变成什么颜色，你就给我传那个值进来，0就是green……这种适用于只需要修改少量属性的标签。如果你需要修改颜色，字体大小，间距….这种方式显然太繁琐，这时候ngclass就来了。&nbsp;ngclass注意ngClass后面的字样。label为什么没有用单引号呢，而后面的text-primary却有呢？.label是一个变量，我们的样式是可以传参的。也就是你的html标签不需要改动，需要什么样式就在ts离传入即可。ngClass也可以利用这个特性去修改。其实这几种用的地方也挺多的，不过得根据实际需求去采用不同形式。欢迎来找我交流Angular 或前端技术哟。","content":"<p><img src=\"/images/fengjing-4.jpg\" alt=\"fengjing\"></p>\n<div class=\"image-caption\">你用Angular吗？</div>\n\n<h2 id=\"介绍-如何只改动最简单的css代码，呈现完全不一样的视图效果。\"><a href=\"#介绍-如何只改动最简单的css代码，呈现完全不一样的视图效果。\" class=\"headerlink\" title=\"介绍 :如何只改动最简单的css代码，呈现完全不一样的视图效果。\"></a>介绍 :如何只改动最简单的css代码，呈现完全不一样的视图效果。</h2><h3 id=\"第一种：最基本的设置：\"><a href=\"#第一种：最基本的设置：\" class=\"headerlink\" title=\"第一种：最基本的设置：\"></a>第一种：最基本的设置：</h3><a id=\"more\"></a>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4116930-982f4ad0d5fd7408.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"> </p>\n<div class=\"image-caption\">图1 代码</div><br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-66db768ea2abfff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><div class=\"image-caption\">图2 界面运行效果图</div><br>平常，想给一个label或者p等标签添加样式，我们就是这样操作，在Angular中也是一样的。现在，如果我想要将字体换成红色呢，首先想到的就是去修改.label里的color属性值，可如果样式表是封装的或者外部引用的，不方便修改呢？<br>这时候就要用到ElementRef 和Renderer2了。可以去Angular 官网里搜索哟。<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-84cb5a9a2291484d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><div class=\"image-caption\">&nbsp; renderer.class 图</div><br>###  第二种:我们可以这样用<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-a174137d1ddabdf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><div class=\"image-caption\">&nbsp; label.html</div><br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-047f9e0a9248b70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><div class=\"image-caption\">&nbsp; label.ts</div><br>当然ElementRef和renderer2都引用自@angular/core库里面的。 至于ViewChild 和ngAfterViewInit()可以自行去了解。<br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-062a49888ff8ea87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><div class=\"image-caption\">&nbsp;&nbsp;&nbsp; 修改效果图</div>\n\n<p>当然，你说这样修改的弊端有没有呢？肯定是有的，因为，this.el.nativeElement获取的是当前元素，如果用*ngFor生成了一系列的label的话，它只会给你修改第一个label的。那有没有其他的办法可以修改呢。当然也是有的！</p>\n<h3 id=\"第三种：我们可以获取到元素的节点进行操作\"><a href=\"#第三种：我们可以获取到元素的节点进行操作\" class=\"headerlink\" title=\"第三种：我们可以获取到元素的节点进行操作?\"></a>第三种：我们可以获取到元素的节点进行操作?</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/4116930-12c5b5c2c91e5027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<div class=\"image-caption\">&nbsp; label.ts</div>\n\n<p>获取元素节点，还是用上面的elementref。 如果要改变所有的，For循环皆可以啦。可是，这样做又有问题了？如果想不同的label不同字体颜色怎么办呢？<br><strong>当然Angular也提供了方法呀？ ngStyle和ngClass可以用呀！</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4116930-9812d0ae51e1617b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><div class=\"image-caption\">&nbsp;ngStyle</div></p>\n<p>[ngStyle]=”{color:’&nbsp; ‘}”&nbsp; 和[style.color]是一样的意思。<br>你的label想变成什么颜色，你就给我传那个值进来，0就是green……<br>这种适用于只需要修改少量属性的标签。<br>如果你需要修改颜色，字体大小，间距….这种方式显然太繁琐，这时候ngclass就来了。</p><br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-9e8fc68d79cdd836.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><div class=\"image-caption\">&nbsp;ngclass</div><br><p>注意ngClass后面的字样。label为什么没有用单引号呢，而后面的text-primary却有呢？<br>.label是一个变量，我们的样式是可以传参的。</p><br><img src=\"http://upload-images.jianshu.io/upload_images/4116930-09c7142d6bee0a3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><p>也就是你的html标签不需要改动，需要什么样式就在ts离传入即可。ngClass也可以利用这个特性去修改。<br>其实这几种用的地方也挺多的，不过得根据实际需求去采用不同形式。<br>欢迎来找我交流Angular 或前端技术哟。</p>\n\n\n\n\n","comments":true,"categories":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/categories/Angular-2/"}],"tags":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/tags/Angular-2/"},{"name":"ngStyle","slug":"ngStyle","permalink":"http://www.sulishibaobei.com/tags/ngStyle/"},{"name":"ngClass","slug":"ngClass","permalink":"http://www.sulishibaobei.com/tags/ngClass/"}]},{"title":"Angular 2+ 路由的那些事","date":"2017-09-01T03:08:53.000Z","path":"angular/route/title20170901/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路由的作用就是（导航）：会加载与请求路由相关联的组件，并获取特定路由的相关数据，这允许我们通过控制不同的路由，获取不同的数据，从而渲染不同的页面； 几种常见的路由配置：Angular路由器是一个可选的外部Angular NgModule ，叫RouterModule;路由器里面包含多种服务(RouterModule)，多种指令（RouterOutlet，RouterLink,RouterLinkActive），和一套配置（Routes）; 123456789import &#123; RouterModule&#125; from '@angular/router'; RouterModule.forRoot([ &#123; path: 'test', component: TestComponent &#125; ]) &lt;a routerLink=\"test\"&gt;Test&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; 详细解析：路由定义包括下面部分： [1] Path:路由器会用它来匹配浏览器地址栏中的地址，如’test’; [2] Component:导航到此路由时，需要加载的组件；注意，path不能以斜杠（/）开头。 路由器会为解析和构建最终的URL，这样当我们在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。 另外： 这里用到了RouterModule对象为我们提供的两个静态方法：forRoot()和forChild() 来配置路由信息； forRoot()方法提供了路由需要的路由服务提供商和指令，并基于当前浏览器 URL 初始化导航；用于在模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令； a标签中的routerLink 指令绑定一个字符串，字符串是path路径中配置的字符串，它将告诉路由器，当用户点击这个链接时，应该导航到哪里； 当然routerLink还可以绑定一个数组，就是我们的带参路由,下面会具体介绍的：1&lt;a [routerLink]=\"['/test', id]\"&gt;test&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以在上面这样配置添加一个routerLinkActive指令, 我们需要让用户知道哪个路由处于激活状态，通常情况下我们通过向激活的链接添加一个 class 来实现该功能,然后我们写一个active的类:1234&lt;a routerLink=\"test\" routerLinkActive=\"active\"&gt;test&lt;/a&gt; .active&#123; color：red &#125; &nbsp;&nbsp;&nbsp;&nbsp;当此路由被点击时，字体会变成红色；这也是routerLinkActive的作用，使我们知道哪个路由处于激活状态；当然还可以添加上这个[routerLinkActiveOptions]=”{exact: true}” 只有当路由完全一样时，才会将active类加载上去：1&lt;a routerLink=\"dashboard\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"&#123;exact: true&#125;\"&gt;Dashboard&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;chrome控制台这样显示：&nbsp;&nbsp;&nbsp;&nbsp;可见routerLink还是会自动将路由链接到href上的；class=”active“也作用上去啦；当切换路由时：class=”active” 移到我点击的路由上，只是应该是调用了：ngAfterContentInit(),ngOnChanges(),ngOnDestroy() 注意：第一个路径片段可以以 / ，./ 或 ../ 开头： 如果以 / 开头，路由将从根路由开始查找 如果以 ./ 开头或没有使用 / ，则路由将从当前激活路由的子路由开始查找 如果以 ../ 开头，路由往上一级查找1&lt;a [routerLink]=\"['../test', id]\"&gt;test&lt;/a&gt; 当然这里我们也可以通过在component里控制写:123456import &#123;Router&#125; from '@angular/router';&lt;a (click)=\"go()\"&gt;Heroes&lt;/a&gt;constructor(private router: Router) &#123;&#125;go() &#123; this.router.navigate(['heroes']);&#125; 这种效果也是一样的；这里就需要注入router服务：router方法用于切换路由很有用，下面会具体来介绍router服务的； 路由出口:RouterOutlet是由RouterModule提供的指令之一。当我们在应用中导航时，路由器就把激活的组件显示在&lt;/router-outlet&gt; 里面。不写1&lt;router-outlet&gt;&lt;/router-outlet&gt; 会导致组件内容不加载进来，从而不显示内容；但是一个组件可以共用一个routeroutlet，所以app.component.ts里面配置即可：1&lt;router-outlet&gt;&lt;/router-outlet&gt; 第二种写法：请看代码：12345678910111213RouterModule.forRoot([...]) 将[] 及中间的内容当成配置文件提取出去；RouterModule.forRoot(routes),routes是我们需要导入的配置文件参数名：import &#123; routes&#125; from './app-routing.module';app-routing.module:中我们可以这样写：import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';import &#123; HeroDetailComponent &#125; from './detail/hero-detail.component';export const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'detail/:id', component: HeroDetailComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;, &#123; path: '**', component:DashboardComponent&#125;]; 注意： { path: ‘’, redirectTo: ‘/dashboard’, pathMatch: ‘full’ } 表示重定向路由：需要一个pathMatch属性，告诉路由器是如何用URL去匹配路由的路径的，没有这个属性就会报错；意思就是当路由URL等于’’时，会去加载DashboardComponent组件；所以你运行你的服务端口号：localhost:4200首先加载的就会是这个组件；{ path: “**”, component:DashboardComponent} **路径是一个通配符，表示除了以上几种path,任何的路径都会加载DashboardComponent组件，这个记得写在路由配置最后 当然这种方式我们还能这么写: 无declarations！声明是关联模块的重点。我们将AppRoutingModule抛出去，当做一个路由模块， 1234567891011121314import &#123; NgModule &#125; from '@angular/core';import &#123; Routes,RouterModule&#125; from '@angular/router';import &#123; DashboardComponent &#125; from './dashboard/dashboard.component';import &#123; HeroesComponent &#125; from './hero/heroes.component';const routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;];@NgModule(&#123; imports: [ RouterModule.forChild(routes) ], exports: [ RouterModule ]&#125;)export class AppRoutingModule &#123;&#125; app.module.ts中引入： 1import &#123; AppRoutingModule&#125; from './app-routing.module'; imports:中导入这个就可以啦AppRoutingModule这种用法和上面这种用法是一样的还有一点：如何解决第二次刷新出现404问题： 1[RouterModule.forRoot(routes,&#123;useHash:true&#125;)] 配置后面这一点，通过添加一个#，防止刷新第二次出现404；http://localhost:4201/#RouterModule.forChild(routes)写在子模块里面，而且这边用的是forChild(),不是forRoot（）,使用forRoot()也是不会错的，但是一般情况下根模块中使用forRoot()，子模块中使用forChild() forChild()只能用在特性模块中，这样的一点好处就是我们不必在主模块就配置好所有的路由信息，在需要的时候将他们导入主模块； 参数化路由1&#123; path: 'detail/:id', component: HeroDetailComponent &#125;, 配置参数化路由格式： :id 是一个占位符，当导航到HeroDetailCompnent组件上时，会被填入一个特定的id；这里我们是这样绑定的：1&lt;a *ngFor=\"let hero of heroes\" [routerLink]=\"['/detail', hero.id]\" class=\"col-1-4\"&gt;&lt;/a&gt; eg: http://localhost:4201/detail/11 这时的id等于11； [1]传参类型的id作用可以根据传入的id不同让HeroDetailComponent显示不同的内容； [2]但是怎么能让其显示不同的内容呢？ 也就和我们这个id有关系，如何获取这个id 用在我们的组件里面呢？ [3]通过注入ActivatedRoute服务，一站式获取路由信息；1234import &#123; ActivatedRoute&#125; from '@angular/router'; constructor( private route: ActivatedRoute, ) &#123;&#125; 接下来我们这样试试：1234567public params;this.route.params.subscribe( params =&gt; &#123; this.params = params; console.log(this.params); &#125; ); 这样获取来的是一个对象：直接取id就能获取到了；既然是一站式获取，肯定不止这几个功能 后面会具体介绍它： 路由配置是也可以通过子路由来配置children：1234567&#123; path: 'heroes', component: HeroesComponent, children: [ &#123; path: 'heroTest', component: HeroTestComponent &#125;, ] &#125; 是这样配置的；此时HeroTestComponent组件的路由其实是:’heroes/heroTest’; 懒加载loadChildren:1234&#123; path:'loadtest', loadChildren:'./loadtest/loadtest.module#LoadtestModule' &#125; 路由是这样配置的： [1]这里注意几点：1import &#123; LoadtestComponent &#125; from './loadtest/loadtest.component'; 组件不需要在app.module.ts引入 [2]loadtest.module.ts 也不需要在app.module.ts中引入；而是通过loadchildren属性，在需要的时候告诉Angular路由依据loadchildren属性配置的路径去加载LoadtestModule模块，这就是模块懒加载功能；当用户需要的时候才回去加载，大大减少了应用启动时的资源加载大小； [3] loadChildren后面的字符串由三部分组成：(3.1) 需要导入模块路劲的相对路径(3.2) #分隔符(3.3) 导出模块类的名称 [4]还有一点也是也是重要的：loadtestModule代码是这样的：里面要引入自己的路由； 123456789101112131415import &#123; NgModule &#125; from '@angular/core';import &#123;CommonModule&#125; from '@angular/common';import &#123; LoadtestComponent &#125; from './loadtest.component';import &#123;RouterModule&#125; from '@angular/Router';import &#123;route&#125; from './loadtest-routing.module';@NgModule(&#123; imports:[ CommonModule, RouterModule.forChild(route), ], declarations:[ LoadtestComponent ]&#125;)export class LoadtestModule&#123;&#125; 在route路由里面记得这样配置这样一句才不会出错：1234567import &#123; LoadtestComponent &#125; from './loadtest.component';export const route = [ &#123; path:'', component: LoadtestComponent &#125;,] path:’’,才能保证代码不出错；懒加载的文件要注意：app.module.ts中：1234567declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent, TestComponent, ], 这里面的文件，采用懒在家的模块是引用不到得，因为lazy加载文件有自己的ngModule ，如果要使用的组件是同一个，最好建立一个shareModule模块；采用commonModule 将共享文件放进去，之后的Module里使用再加载进imports中； Router服务：123456789101112131415161718192021 class Router&#123;2. errorHandler:ErrorHandler3. navigated: boolean4. urlHandlingStrategy:UrlHandlingStrategy5. routeReuseStrategy:RouteReuseStrategy6. config:Routes7. initialNavigation():void8. setUpLocationChangeListener():void9. get routerState():RouterState10. get url(): string11. get events():Observable&lt;Event&gt;12. resetConfig(config:Routes):void13. ngOnDestroy():void14. dispose():void15. createUrlTree(commands: any[], navigationExtras:NavigationExtras):UrlTree16. navigateByUrl(url: string|UrlTree, extras:NavigationExtras):Promise&lt;boolean&gt;17. navigate(commands: any[], extras:NavigationExtras):Promise&lt;boolean&gt;18. serializeUrl(url:UrlTree): string19. parseUrl(url: string):UrlTree20. isActive(url: string|UrlTree, exact: boolean): boolean21. &#125; 这是Router API为我们提供的方法和属性； 看看几个常用的： navigate()该方法支持的参数类型和routerLink指令一样，所以他们的作用也是一样的：1this.router.navigate(['test', id]); 或者1this.router.navigate(['test']); 调用该方法后页面会自动跳转到对应的路由地址；1this.router.navigate(['test'], &#123; relativeTo: this.route&#125;); 我们可以设置一个参照路径，参照路径this.route从ActivatedRoute里面取；配置这个可以让自己知道相对于什么位置导航，this.route就是相对于当前的路由进行导航，假如当前url：localhost:4200/hero ,那么导航后的结果就是：localhost:4200/hero/test navigateByUrl() 这个叫做绝对路由；1this.router.navigateByUrl('home'); 可以帮助你快速的切换到某个路由下面，如果你当时的路由是这样的：localhost:4200/hero/test 点击这个路由后就是：localhost:4200/home 我们一般用这个路由来回到首页；和navigate()的区别还有点是：这个不是根据参数来确定路由地址的 config 会将页面所有的路由配置信息都显示：看看路由树： url 输出当前 的路由patheg：http://localhost:4200/detail/11url: /detail/11 每次导航前都会调用events方法；1RouterModule.forRoot(routes, &#123;enableTracing: true &#125;) 通过在控制台配置enableTracing: true可以在控制台看到相关改变； 注意：enableTracing: true 只能在forRoot()里面添加具体的事件有： chrome控制台:注意：这些事件是以Observable的形式提供的 ActivateRoute API :12345678910111213141516171819interface ActivatedRoute &#123;snapshot: ActivatedRouteSnapshoturl: Observable&lt;UrlSegment[]&gt;params: Observable&lt;Params&gt;queryParams: Observable&lt;Params&gt;fragment: Observable&lt;string&gt;data: Observable&lt;Data&gt;outlet: stringcomponent: Type&lt;any&gt;|string|nullget routeConfig(): Route|nullget root(): ActivatedRouteget parent(): ActivatedRoute|nullget firstChild(): ActivatedRoute|nullget children(): ActivatedRoute[]get pathFromRoot(): ActivatedRoute[]get paramMap(): Observable&lt;ParamMap&gt;get queryParamMap(): Observable&lt;ParamMap&gt;toString(): string&#125; parmaMap123456789第一步：import &#123; Router, ActivatedRoute, ParamMap &#125; from '@angular/router';第二步：import 'rxjs/add/operator/switchMap';导入switchMap操作符是因为我们稍后将会处理路由参数的可观察对象Observable ;会在以后的章节中介绍操作符的；第三步：constructor( private heroService: HeroService, private route: ActivatedRoute, private router: Router, ) &#123;&#125;&lt;code&gt; &lt;br&gt;&lt;/code&gt; 假定事先写好了HeroService： 1234this.route.paramMap .switchMap((params: ParamMap) =&gt; this.heroService.getHero(+params.get('id'))) .subscribe(hero =&gt; this.hero = hero ); &#125; 我们这样操作，前面已经介绍过用parmas获取参数；所以这样写也可以，用的是paramMap就引入paramMap，params就引入Params 123456this.route.params .switchMap((params: Params) =&gt; this.heroService.getHero(+params['id'])) .subscribe(hero =&gt; this.hero = hero; &#125; ); 由于参数是作为Observable提供的，所以我们得用switchMap操作符来根据名字取得id参数，并告诉HeroService来获取带有那个id的英雄。 snapshot(快照)route.snapshot提供了路由参数的初始值。 我们可以通过它来直接访问参数，而不用订阅或者添加Observable的操作符所以获取参数的id还可以这样：12&lt;a *ngFor=\"let hero of heroes\" [routerLink]=\"['/detail', hero.id]\" class=\"col-1-4\"&gt;&lt;/a&gt; &lt;br&gt;this.params = this.route.snapshot.paramMap.get('id');&lt;br&gt;&lt;br&gt;console.log(this.params); 所以上面的代码改成这样更好： 1234this.params = this.route.snapshot.paramMap.get('id'); console.log(this.params);this.heroService.getHero(this.params) .then(hero =&gt; this.hero = hero); 两种方法：params 和snapshot到底什么时候该用哪种呢？ 需要直接访问参数，主要获取初始值，不用订阅的情况下用snapshot； 需要连续导航多次的用params; 总结 ,路由主要是用到了这些方面啦： 给路由添加一些新特性：添加动画[1] 在app.module.ts中引入启用Angular动画必备的, 记得在imports中导入：1import &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations'; [2] 在app.component.ts同级下创建一个animation.ts文件，用来存放我们的动画效果； 1234567891011121314151617181920212223 import &#123; animate, AnimationEntryMetadata, state, style, transition, trigger &#125; from '@angular/core';export const slideInDownAnimation: AnimationEntryMetadata = trigger('routeAnimation', [ state('*', style(&#123; opacity: 1, transform: 'translateX(0)' &#125;) ), transition(':enter', [ style(&#123; opacity: 0, transform: 'translateX(-100%)' &#125;), animate('0.2s ease-in') ]), transition(':leave', [ animate('0.5s ease-out', style(&#123; opacity: 0, transform: 'translateY(100%)' &#125;)) ]) ]); 假定我有以上代码，视图进场和出场； 构建动画需要的库； 导出了一个名叫slideInDownAnimation的常量，并把它设置为一个名，用于外部引入此ts文件； 叫routeAnimation的动画触发器。带动画的组件将会引用这个名字。用在外部html页面引用 指定了一个通配符状态 —— *，它匹配该路由组件存在时的任何动画状态。 定义两个过渡效果，其中一个（:enter）在组件进入应用视图时让它从屏幕左侧缓动进入（ease-in），另一个（:leave）在组件离开应用视图时让它向下飞出。 [3] 如何使用动画； 在需要的组件中引入变量名为：slideInDownAnimation的文件animation.ts； 1import &#123;slideInDownAnimation&#125; from '../animation'; [4]组件中配置12templateUrl: 'hero-detail.component.html',animations: [slideInDownAnimation] [5]html模板中这样引入：1&lt;div *ngIf=\"hero\" [@routeAnimation]=\"'active'\"&gt; @routeAnimation 动画触发器名 点击之后会自动加载动画的； 多重路由出口一般情况下：我们使用一个路由出口就行啦，什么情况下会使用第二路由呢？ 1.创建一个新组件ComposemessageComponent2.路由配置：12345&#123; path:'compose', component:ComposemessageComponent, outlet:'popup' &#125; 3.html页面这样配置：123456789&lt;nav&gt; &lt;a routerLink=\"dashboard\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"&#123;exact: true&#125;\"&gt;Dashboard&lt;/a&gt; &lt;a (click)=\"go()\" &gt;Heroes&lt;/a&gt; &lt;a routerLink=\"test\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"&#123;exact: true&#125;\"&gt;Test&lt;/a&gt; &lt;a routerLink=\"loadtest\" routerLinkActive=\"active\"&gt;loadTest&lt;/a&gt; &lt;a [routerLink]=\"[&#123; outlets: &#123; popup: ['compose'] &#125; &#125;]\"&gt;Contact&lt;/a&gt; &lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;router-outlet name=\"popup\"&gt;&lt;/router-outlet&gt; 这是我的页面所有的路由配置；点击Contact 不会替换其他的组件信息，注意看Url:http://localhost:4200/dashboard(popup:compose)点击Contact url地址没有变成http://localhost:4200/contact而是采用圆括号加载 圆括号包裹的部分是第二路由。 第二路由包括一个出口名称（popup）、一个冒号分隔符和第二路由的路径（compose）而是显示在下面，点击test也是一样： Contact路由加载的组件不会被清除，一直显示在下面，状态一直被激活；这里我们就能知道第二路由的用处：即使在应用中的不同页面之间切换，这个组件也应该始终保持打开状态，多重出口可以在同一时间根据不同的路由来显示不同的内容；但是什么时候清除我们的第二路由呢？如果我页面不需要呢？注意：1234&lt;a (click)=\"go()\" &gt;Heroes&lt;/a&gt;go() &#123; this.router.navigateByUrl('heroes'); &#125; 当点击Heroes时，Contact路由加载的内容就不会被显示：原因是这样的：它使用Router.navigateNyUrl()方法进行强制导航,所以路由清除啦；还可以这样清除： 123this.router.navigate([&#123; outlets: &#123; popup: null &#125;&#125;]);outlets属性的值是另一个对象，该对象用一些出口名称作为属性名。 唯一的命名出口是'popup'。但这里，'popup'的值是null。null不是一个路由，但却是一个合法的值。 把popup这个RouterOutlet设置为null会清除该出口，并且从当前URL中移除第二路由popup 路由守卫按照上面所说：任何用户都能在任何时候导航到任何地方，这样就有问题，可能此用户并没有权限切换到此路由，可能用户未登陆不能切换，或者做一些友好提示之后再切换；所以路由守卫就来了：守卫返回一个值，以控制路由器的行为： 如果它返回true，导航过程会继续 如果它返回false，导航过程会终止，且用户会留在原地。也就是你导航的路由是可以取消的，路由守卫还有一个好处就是回退功能时，可以防止用户无限回退，走出app；路由守卫怎么做：用CanActivate来处理导航到某路由的情况。用CanActivateChild来处理导航到某子路由的情况。用CanDeactivate来处理从当前路由离开的情况.用Resolve在路由激活之前获取路由数据。用CanLoad来处理异步导航到某特性模块的情况。 返回的值是一个Observable或Promise，路由器会等待这个可观察对象被解析为true或false。在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。看看路由守卫怎么实现：1.new 一个新项目activeComponent;2.编写守卫服务： 123456789import &#123; Injectable &#125; from '@angular/core';import &#123; CanActivate &#125; from '@angular/router';@Injectable()export class LoadTestService implements CanActivate&#123; canActivate() &#123; console.log('AuthGuard#canActivate called'); return true; &#125;&#125; 3.路由中这样导入我们的守卫： 123456789101112131415import &#123; ActiveComponent &#125; from './active/active.component';import &#123;LoadTestService&#125; from './loadtest.service';export const route = [ &#123; path:'', component: LoadtestComponent, canActivate:[LoadTestService], children:[ &#123; path:'a', component: ActiveComponent &#125; ] &#125;,] 这样我们的ActiveComponent就是受保护的； 当然这只是模拟；还有更多用法，以后来列举；","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路由的作用就是（导航）：会加载与请求路由相关联的组件，并获取特定路由的相关数据，这允许我们通过控制不同的路由，获取不同的数据，从而渲染不同的页面；</p>\n<h2 id=\"几种常见的路由配置：\"><a href=\"#几种常见的路由配置：\" class=\"headerlink\" title=\"几种常见的路由配置：\"></a>几种常见的路由配置：</h2><p>Angular路由器是一个可选的外部Angular NgModule ，叫RouterModule;<br>路由器里面包含多种服务(RouterModule)，多种指令（RouterOutlet，RouterLink,RouterLinkActive），和一套配置（Routes）;</p>\n<a id=\"more\"></a>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; RouterModule&#125; from '@angular/router';</div><div class=\"line\"> RouterModule.forRoot([</div><div class=\"line\">       &#123;</div><div class=\"line\">         path: 'test',</div><div class=\"line\">         component: TestComponent</div><div class=\"line\">       &#125;</div><div class=\"line\"> ]) </div><div class=\"line\">&lt;a routerLink=\"test\"&gt;Test&lt;/a&gt; </div><div class=\"line\">&lt;router-outlet&gt;&lt;/router-outlet&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"详细解析：\"><a href=\"#详细解析：\" class=\"headerlink\" title=\"详细解析：\"></a>详细解析：</h3><h4 id=\"路由定义包括下面部分：\"><a href=\"#路由定义包括下面部分：\" class=\"headerlink\" title=\"路由定义包括下面部分：\"></a>路由定义包括下面部分：</h4><ul>\n<li>[1]  Path:路由器会用它来匹配浏览器地址栏中的地址，如’test’; </li>\n<li>[2]  Component:导航到此路由时，需要加载的组件；<br><strong><font color=\"#0099ff\">注意，path不能以斜杠（/）开头。 路由器会为解析和构建最终的URL，这样当我们在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。</font></strong></li>\n</ul>\n<p>另外：</p>\n<ol>\n<li>这里用到了RouterModule对象为我们提供的两个静态方法：forRoot()和forChild() 来配置路由信息；</li>\n<li>forRoot()方法提供了路由需要的路由服务提供商和指令，并基于当前浏览器 URL 初始化导航；用于在模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令；</li>\n<li>a标签中的routerLink 指令绑定一个字符串，字符串是path路径中配置的字符串，它将告诉路由器，当用户点击这个链接时，应该导航到哪里；</li>\n<li>当然routerLink还可以绑定一个数组，就是我们的带参路由,下面会具体介绍的：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> [<span class=\"attr\">routerLink</span>]=<span class=\"string\">\"['/test', id]\"</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以在上面这样配置添加一个routerLinkActive指令, 我们需要让用户知道哪个路由处于激活状态，通常情况下我们通过向激活的链接添加一个 class 来实现该功能,然后我们写一个active的类:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">routerLink</span>=<span class=\"string\">\"test\"</span> <span class=\"attr\">routerLinkActive</span>=<span class=\"string\">\"active\"</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">   .active&#123;</div><div class=\"line\">       color：red</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;当此路由被点击时，字体会变成红色；这也是routerLinkActive的作用，使我们知道哪个路由处于激活状态；当然还可以添加上这个[routerLinkActiveOptions]=”{exact: true}”  只有当路由完全一样时，才会将active类加载上去：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">routerLink</span>=<span class=\"string\">\"dashboard\"</span> <span class=\"attr\">routerLinkActive</span>=<span class=\"string\">\"active\"</span>  [<span class=\"attr\">routerLinkActiveOptions</span>]=<span class=\"string\">\"&#123;exact: true&#125;\"</span>&gt;</span>Dashboard<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;chrome控制台这样显示：<br><img src=\"/images/router-1.png\" alt=\"cmd-markdown-logo\"><br>&nbsp;&nbsp;&nbsp;&nbsp;可见routerLink还是会自动将路由链接到href上的；class=”active“也作用上去啦；当切换路由时：<br><img src=\"/images/router-2.png\" alt=\"cmd-markdown-logo\"><br><code>class=”active”</code> 移到我点击的路由上，只是应该是调用了：ngAfterContentInit(),ngOnChanges(),ngOnDestroy()</p>\n<p>注意：第一个路径片段可以以 / ，./ 或 ../ 开头：<br>  如果以 / 开头，路由将从根路由开始查找<br>  如果以 ./ 开头或没有使用 / ，则路由将从当前激活路由的子路由开始查找<br>  如果以 ../ 开头，路由往上一级查找<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> [<span class=\"attr\">routerLink</span>]=<span class=\"string\">\"['../test', id]\"</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><strong>当然这里我们也可以通过在component里控制写:</strong><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123;Router&#125; from '@angular/router';</div><div class=\"line\">&lt;a (click)=\"go()\"&gt;Heroes&lt;/a&gt;</div><div class=\"line\">constructor(private router: Router) &#123;&#125;</div><div class=\"line\">go() &#123;</div><div class=\"line\">  this.router.navigate(['heroes']);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这种效果也是一样的；这里就需要注入router服务：router方法用于切换路由很有用，下面会具体来介绍router服务的；<br>   路由出口:RouterOutlet是由RouterModule提供的指令之一。当我们在应用中导航时，路由器就把激活的组件显示在<code>&lt;/router-outlet&gt;</code> 里面。不写<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-outlet</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-outlet</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>会导致组件内容不加载进来，从而不显示内容；<br>但是一个组件可以共用一个routeroutlet，所以app.component.ts里面配置即可：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-outlet</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-outlet</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"第二种写法：\"><a href=\"#第二种写法：\" class=\"headerlink\" title=\"第二种写法：\"></a>第二种写法：</h2><p>请看代码：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">RouterModule.forRoot([...]) 将[] 及中间的内容当成配置文件提取出去；</div><div class=\"line\">RouterModule.forRoot(routes),</div><div class=\"line\">routes是我们需要导入的配置文件参数名：</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; routes&#125; from <span class=\"string\">'./app-routing.module'</span>;</div><div class=\"line\">app-routing.module:中我们可以这样写：</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; DashboardComponent &#125; from <span class=\"string\">'./dashboard/dashboard.component'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; HeroesComponent &#125; from <span class=\"string\">'./hero/heroes.component'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; HeroDetailComponent &#125; from <span class=\"string\">'./detail/hero-detail.component'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> routes = [</div><div class=\"line\">  &#123; path: <span class=\"string\">''</span>, redirectTo: <span class=\"string\">'/dashboard'</span>, pathMatch: <span class=\"string\">'full'</span> &#125;,</div><div class=\"line\">  &#123; path: <span class=\"string\">'dashboard'</span>,  component: DashboardComponent &#125;,</div><div class=\"line\">  &#123; path: <span class=\"string\">'detail/:id'</span>, component: HeroDetailComponent &#125;,</div><div class=\"line\">  &#123; path: <span class=\"string\">'heroes'</span>,     component: HeroesComponent &#125;,  &#123; path: <span class=\"string\">'**'</span>, component:DashboardComponent&#125;];</div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong><br> <strong>{ path: ‘’, redirectTo: ‘/dashboard’, pathMatch: ‘full’ }</strong><br>   表示重定向路由：需要一个pathMatch属性，告诉路由器是如何用URL去匹配路由的路径的，没有这个属性就会报错；意思就是当路由URL等于’’时，会去加载DashboardComponent组件；所以你运行你的服务端口号：localhost:4200首先加载的就会是这个组件；<br><em><font color=\"#000000\">{ path: “**”, component:DashboardComponent}</font></em><br>   **路径是一个通配符，表示除了以上几种path,任何的路径都会加载DashboardComponent组件，这个记得写在路由配置最后</p>\n<h3 id=\"当然这种方式我们还能这么写\"><a href=\"#当然这种方式我们还能这么写\" class=\"headerlink\" title=\"当然这种方式我们还能这么写:\"></a>当然这种方式我们还能这么写:</h3><ol>\n<li><p>无declarations！声明是关联模块的重点。我们将AppRoutingModule抛出去，当做一个路由模块，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NgModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; Routes,RouterModule&#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/router'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; DashboardComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./dashboard/dashboard.component'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; HeroesComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./hero/heroes.component'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> routes = [</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">''</span>, <span class=\"attr\">redirectTo</span>: <span class=\"string\">'/dashboard'</span>, <span class=\"attr\">pathMatch</span>: <span class=\"string\">'full'</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">'dashboard'</span>,  <span class=\"attr\">component</span>: DashboardComponent &#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">'heroes'</span>,     <span class=\"attr\">component</span>: HeroesComponent &#125;</div><div class=\"line\">];</div><div class=\"line\">@NgModule(&#123;</div><div class=\"line\">  <span class=\"attr\">imports</span>: [ RouterModule.forChild(routes) ],</div><div class=\"line\">  <span class=\"attr\">exports</span>: [ RouterModule ]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppRoutingModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>app.module.ts中引入：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRoutingModule&#125; from <span class=\"string\">'./app-routing.module'</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>imports:中导入这个就可以啦<strong>AppRoutingModule</strong><br>这种用法和上面这种用法是一样的还有一点：如何解决第二次刷新出现404问题：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[RouterModule.forRoot(routes,&#123;useHash:<span class=\"literal\">true</span>&#125;)]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>配置后面这一点，通过添加一个#，防止刷新第二次出现404；<em><a href=\"http://localhost:4201/#\" target=\"_blank\" rel=\"external\">http://localhost:4201/#</a></em><br>RouterModule.forChild(routes)写在子模块里面，而且这边用的是forChild(),不是forRoot（）,使用forRoot()也是不会错的，但是一般情况下<br><code><font color=\"red\">根模块中使用forRoot()，子模块中使用forChild()</font></code><br>   forChild()只能用在特性模块中，这样的一点好处就是我们不必在主模块就配置好所有的路由信息，在需要的时候将他们导入主模块；</p>\n<h3 id=\"参数化路由\"><a href=\"#参数化路由\" class=\"headerlink\" title=\"参数化路由\"></a>参数化路由</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; path: <span class=\"string\">'detail/:id'</span>, component: HeroDetailComponent &#125;,</div></pre></td></tr></table></figure>\n<p>配置参数化路由格式： :id 是一个占位符，当导航到HeroDetailCompnent组件上时，会被填入一个特定的id；<br><strong>这里我们是这样绑定的：</strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">\"let hero of heroes\"</span>  [<span class=\"attr\">routerLink</span>]=<span class=\"string\">\"['/detail', hero.id]\"</span>  <span class=\"attr\">class</span>=<span class=\"string\">\"col-1-4\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><font color=\"red\">eg: <a href=\"http://localhost:4201/detail/11\" target=\"_blank\" rel=\"external\">http://localhost:4201/detail/11</a> 这时的id等于11；</font></p>\n<ul>\n<li>[1]传参类型的id作用可以根据传入的id不同让HeroDetailComponent显示不同的内容；</li>\n<li>[2]但是怎么能让其显示不同的内容呢？ 也就和我们这个id有关系，如何获取这个id 用在我们的组件里面呢？</li>\n<li>[3]通过注入ActivatedRoute服务，一站式获取路由信息；<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; ActivatedRoute&#125; from <span class=\"string\">'@angular/router'</span>;</div><div class=\"line\"> <span class=\"keyword\">constructor</span>(<span class=\"params\"></span></div><div class=\"line\">    <span class=\"keyword\">private</span> route: ActivatedRoute,</div><div class=\"line\">     ) &#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>接下来我们这样试试：</strong><br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> params;</div><div class=\"line\"><span class=\"keyword\">this</span>.route.params.subscribe(</div><div class=\"line\">      params =&gt; &#123;</div><div class=\"line\">         <span class=\"keyword\">this</span>.params = params;</div><div class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.params);</div><div class=\"line\">      &#125;</div><div class=\"line\">    );</div></pre></td></tr></table></figure></p>\n<p><em>这样获取来的是一个对象：直接取id就能获取到了；既然是一站式获取，肯定不止这几个功能 后面会具体介绍它：</em></p>\n<h3 id=\"路由配置是也可以通过子路由来配置children：\"><a href=\"#路由配置是也可以通过子路由来配置children：\" class=\"headerlink\" title=\"路由配置是也可以通过子路由来配置children：\"></a>路由配置是也可以通过子路由来配置children：</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    path: <span class=\"string\">'heroes'</span>,</div><div class=\"line\">    component: HeroesComponent,</div><div class=\"line\">    children: [</div><div class=\"line\">      &#123; path: <span class=\"string\">'heroTest'</span>, component: HeroTestComponent &#125;,</div><div class=\"line\">    ]</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>是这样配置的；此时HeroTestComponent组件的路由其实是:’heroes/heroTest’;</p>\n<h3 id=\"懒加载loadChildren\"><a href=\"#懒加载loadChildren\" class=\"headerlink\" title=\"懒加载loadChildren:\"></a>懒加载loadChildren:</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">     path:<span class=\"string\">'loadtest'</span>,</div><div class=\"line\">     loadChildren:<span class=\"string\">'./loadtest/loadtest.module#LoadtestModule'</span></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p><strong>路由是这样配置的</strong>：</p>\n<ul>\n<li>[1]这里注意几点：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; LoadtestComponent &#125; from <span class=\"string\">'./loadtest/loadtest.component'</span>;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>组件不需要在app.module.ts引入</p>\n<ul>\n<li><p>[2]loadtest.module.ts 也不需要在app.module.ts中引入；而是通过loadchildren属性，在需要的时候告诉Angular路由依据loadchildren<br>属性配置的路径去加载LoadtestModule模块，这就是模块懒加载功能；当用户需要的时候才回去加载，大大减少了应用启动时的资源加载大小；</p>\n</li>\n<li><p>[3] loadChildren后面的字符串由三部分组成：<br>(3.1) 需要导入模块路劲的相对路径<br>(3.2) #分隔符<br>(3.3) 导出模块类的名称</p>\n</li>\n<li><p>[4]还有一点也是也是重要的：loadtestModule代码是这样的：里面要引入自己的路由；</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NgModule &#125; from <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;CommonModule&#125; from <span class=\"string\">'@angular/common'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; LoadtestComponent &#125; from <span class=\"string\">'./loadtest.component'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;RouterModule&#125; from <span class=\"string\">'@angular/Router'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;route&#125; from <span class=\"string\">'./loadtest-routing.module'</span>;</div><div class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</div><div class=\"line\">    imports:[</div><div class=\"line\">        CommonModule,</div><div class=\"line\">        RouterModule.forChild(route),</div><div class=\"line\">    ],</div><div class=\"line\">    declarations:[</div><div class=\"line\">        LoadtestComponent</div><div class=\"line\">    ]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> LoadtestModule&#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在route路由里面记得这样配置这样一句才不会出错：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; LoadtestComponent &#125; from <span class=\"string\">'./loadtest.component'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> route = [</div><div class=\"line\">    &#123;</div><div class=\"line\">       path:<span class=\"string\">''</span>,</div><div class=\"line\">        component: LoadtestComponent</div><div class=\"line\">    &#125;,</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p><font color=\"red\">path:’’,才能保证代码不出错；</font><br>懒加载的文件要注意：app.module.ts中：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">declarations: [</div><div class=\"line\">   AppComponent,</div><div class=\"line\">   DashboardComponent,</div><div class=\"line\">   HeroDetailComponent,</div><div class=\"line\">   HeroesComponent,</div><div class=\"line\">   TestComponent,</div><div class=\"line\"> ],</div></pre></td></tr></table></figure></p>\n<p>这里面的文件，采用懒在家的模块是引用不到得，因为lazy加载文件有自己的ngModule ，如果要使用的组件是同一个，最好建立一个shareModule模块；<br>采用commonModule 将共享文件放进去，之后的Module里使用再加载进imports中；</p>\n<h2 id=\"Router服务：\"><a href=\"#Router服务：\" class=\"headerlink\" title=\"Router服务：\"></a>Router服务：</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">class</span> Router&#123;</div><div class=\"line\"><span class=\"number\">2.</span>         errorHandler:ErrorHandler</div><div class=\"line\"><span class=\"number\">3.</span>         navigated: <span class=\"built_in\">boolean</span></div><div class=\"line\"><span class=\"number\">4.</span>         urlHandlingStrategy:UrlHandlingStrategy</div><div class=\"line\"><span class=\"number\">5.</span>         routeReuseStrategy:RouteReuseStrategy</div><div class=\"line\"><span class=\"number\">6.</span>         config:Routes</div><div class=\"line\"><span class=\"number\">7.</span>        initialNavigation():<span class=\"built_in\">void</span></div><div class=\"line\"><span class=\"number\">8.</span>        setUpLocationChangeListener():<span class=\"built_in\">void</span></div><div class=\"line\"><span class=\"number\">9.</span>        <span class=\"keyword\">get</span> routerState():RouterState</div><div class=\"line\"><span class=\"number\">10.</span>       <span class=\"keyword\">get</span> url(): <span class=\"built_in\">string</span></div><div class=\"line\"><span class=\"number\">11.</span>       <span class=\"keyword\">get</span> events():Observable&lt;Event&gt;</div><div class=\"line\"><span class=\"number\">12.</span>       resetConfig(config:Routes):<span class=\"built_in\">void</span></div><div class=\"line\"><span class=\"number\">13.</span>       ngOnDestroy():<span class=\"built_in\">void</span></div><div class=\"line\"><span class=\"number\">14.</span>       dispose():<span class=\"built_in\">void</span></div><div class=\"line\"><span class=\"number\">15.</span>       createUrlTree(commands: <span class=\"built_in\">any</span>[], navigationExtras:NavigationExtras):UrlTree</div><div class=\"line\"><span class=\"number\">16.</span>       navigateByUrl(url: <span class=\"built_in\">string</span>|UrlTree, extras:NavigationExtras):Promise&lt;<span class=\"built_in\">boolean</span>&gt;</div><div class=\"line\"><span class=\"number\">17.</span>       navigate(commands: <span class=\"built_in\">any</span>[], extras:NavigationExtras):Promise&lt;<span class=\"built_in\">boolean</span>&gt;</div><div class=\"line\"><span class=\"number\">18.</span>       serializeUrl(url:UrlTree): <span class=\"built_in\">string</span></div><div class=\"line\"><span class=\"number\">19.</span>       parseUrl(url: <span class=\"built_in\">string</span>):UrlTree</div><div class=\"line\"><span class=\"number\">20.</span>       isActive(url: <span class=\"built_in\">string</span>|UrlTree, exact: <span class=\"built_in\">boolean</span>): <span class=\"built_in\">boolean</span></div><div class=\"line\"><span class=\"number\">21.</span>       &#125;</div></pre></td></tr></table></figure>\n<p>这是Router API为我们提供的方法和属性；</p>\n<p>看看几个常用的：</p>\n<h3 id=\"navigate\"><a href=\"#navigate\" class=\"headerlink\" title=\"navigate()\"></a><code>navigate()</code></h3><p>该方法支持的参数类型和routerLink指令一样，所以他们的作用也是一样的：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.router.navigate([<span class=\"string\">'test'</span>, id]);</div></pre></td></tr></table></figure></p>\n<p><strong>或者</strong><br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.router.navigate([<span class=\"string\">'test'</span>]);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>调用该方法后页面会自动跳转到对应的路由地址；<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.router.navigate([<span class=\"string\">'test'</span>], &#123; relativeTo: <span class=\"keyword\">this</span>.route&#125;);</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>我们可以设置一个参照路径，参照路径this.route从ActivatedRoute里面取；配置这个可以让自己知道相对于什么位置导航，this.route就是相对于当前的路由进行导航，<br>假如当前url：localhost:4200/hero ,那么导航后的结果就是：localhost:4200/hero/test</p>\n<h3 id=\"navigateByUrl\"><a href=\"#navigateByUrl\" class=\"headerlink\" title=\"navigateByUrl()\"></a>navigateByUrl()</h3><p> 这个叫做绝对路由；<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.router.navigateByUrl(<span class=\"string\">'home'</span>);</div></pre></td></tr></table></figure></p>\n<p>可以帮助你快速的切换到某个路由下面，如果你当时的路由是这样的：<br>localhost:4200/hero/test 点击这个路由后就是：localhost:4200/home 我们一般用这个路由来回到首页；<br>和navigate()的区别还有点是：这个不是根据参数来确定路由地址的</p>\n<h3 id=\"config-会将页面所有的路由配置信息都显示：\"><a href=\"#config-会将页面所有的路由配置信息都显示：\" class=\"headerlink\" title=\"config 会将页面所有的路由配置信息都显示：\"></a>config 会将页面所有的路由配置信息都显示：</h3><p><img src=\"/images/router-3.png\" alt=\"cmd-markdown-logo\"><br>看看路由树：<br><img src=\"/images/router-4.png\" alt=\"cmd-markdown-logo\"></p>\n<h3 id=\"url-输出当前-的路由path\"><a href=\"#url-输出当前-的路由path\" class=\"headerlink\" title=\"url 输出当前 的路由path\"></a>url 输出当前 的路由path</h3><p><code><br>eg：<a href=\"http://localhost:4200/detail/11\" target=\"_blank\" rel=\"external\">http://localhost:4200/detail/11</a><br>url: /detail/11<br></code></p>\n<h3 id=\"每次导航前都会调用events方法；\"><a href=\"#每次导航前都会调用events方法；\" class=\"headerlink\" title=\"每次导航前都会调用events方法；\"></a>每次导航前都会调用events方法；</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">RouterModule.forRoot(routes, &#123;enableTracing: <span class=\"literal\">true</span> &#125;)</div></pre></td></tr></table></figure>\n<p>通过在控制台配置enableTracing: true可以在控制台看到相关改变；<br> <strong>注意：enableTracing: true 只能在forRoot()里面添加</strong><br>具体的事件有：<br><img src=\"/images/router-5.png\" alt=\"cmd-markdown-logo\"><br> chrome控制台:<br><img src=\"/images/router-6.png\" alt=\"cmd-markdown-logo\"><br><strong>注意：这些事件是以Observable的形式提供的</strong></p>\n<h2 id=\"ActivateRoute-API\"><a href=\"#ActivateRoute-API\" class=\"headerlink\" title=\"ActivateRoute API :\"></a>ActivateRoute API :</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">interface</span> ActivatedRoute &#123;</div><div class=\"line\">snapshot: ActivatedRouteSnapshot</div><div class=\"line\">url: Observable&lt;UrlSegment[]&gt;</div><div class=\"line\">params: Observable&lt;Params&gt;</div><div class=\"line\">queryParams: Observable&lt;Params&gt;</div><div class=\"line\">fragment: Observable&lt;<span class=\"built_in\">string</span>&gt;</div><div class=\"line\">data: Observable&lt;Data&gt;</div><div class=\"line\">outlet: <span class=\"built_in\">string</span></div><div class=\"line\">component: Type&lt;<span class=\"built_in\">any</span>&gt;|<span class=\"built_in\">string</span>|<span class=\"literal\">null</span></div><div class=\"line\"><span class=\"keyword\">get</span> routeConfig(): Route|<span class=\"literal\">null</span></div><div class=\"line\"><span class=\"keyword\">get</span> root(): ActivatedRoute</div><div class=\"line\"><span class=\"keyword\">get</span> parent(): ActivatedRoute|<span class=\"literal\">null</span></div><div class=\"line\"><span class=\"keyword\">get</span> firstChild(): ActivatedRoute|<span class=\"literal\">null</span></div><div class=\"line\"><span class=\"keyword\">get</span> children(): ActivatedRoute[]</div><div class=\"line\"><span class=\"keyword\">get</span> pathFromRoot(): ActivatedRoute[]</div><div class=\"line\"><span class=\"keyword\">get</span> paramMap(): Observable&lt;ParamMap&gt;</div><div class=\"line\"><span class=\"keyword\">get</span> queryParamMap(): Observable&lt;ParamMap&gt;</div><div class=\"line\">toString(): <span class=\"built_in\">string</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"parmaMap\"><a href=\"#parmaMap\" class=\"headerlink\" title=\"parmaMap\"></a>parmaMap</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">第一步：import &#123; Router, ActivatedRoute, ParamMap &#125; from '@angular/router';</div><div class=\"line\">第二步：import 'rxjs/add/operator/switchMap';导入switchMap操作符是因为我们稍后将会处理路由参数的可观察对象Observable ;会在以后的章节中介绍操作符的；</div><div class=\"line\">第三步：</div><div class=\"line\">constructor(</div><div class=\"line\"> private heroService: HeroService,</div><div class=\"line\"> private route: ActivatedRoute,</div><div class=\"line\"> private router: Router,</div><div class=\"line\">  ) &#123;&#125;</div><div class=\"line\">&lt;code&gt; &lt;br&gt;&lt;/code&gt;</div></pre></td></tr></table></figure>\n<p>假定事先写好了HeroService：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.route.paramMap</div><div class=\"line\">   .switchMap((params: ParamMap) =&gt; <span class=\"keyword\">this</span>.heroService.getHero(+params.get(<span class=\"string\">'id'</span>)))</div><div class=\"line\">    .subscribe(hero =&gt; <span class=\"keyword\">this</span>.hero = hero );</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>我们这样操作，前面已经介绍过用parmas获取参数；所以这样写也可以，用的是paramMap就引入paramMap，params就引入Params</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.route.params</div><div class=\"line\">     .switchMap((params: Params) =&gt; <span class=\"keyword\">this</span>.heroService.getHero(+params[<span class=\"string\">'id'</span>]))</div><div class=\"line\">     .subscribe(hero =&gt;</div><div class=\"line\">       <span class=\"keyword\">this</span>.hero = hero;</div><div class=\"line\">     &#125;</div><div class=\"line\">     );</div></pre></td></tr></table></figure>\n<p>由于参数是作为Observable提供的，所以我们得用switchMap操作符来根据名字取得id参数，并告诉HeroService来获取带有那个id的英雄。</p>\n<h3 id=\"snapshot-快照\"><a href=\"#snapshot-快照\" class=\"headerlink\" title=\"snapshot(快照)\"></a>snapshot(快照)</h3><p>route.snapshot提供了路由参数的初始值。 我们可以通过它来直接访问参数，而不用订阅或者添加Observable的操作符<br>所以获取参数的id还可以这样：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">\"let hero of heroes\"</span>  [<span class=\"attr\">routerLink</span>]=<span class=\"string\">\"['/detail', hero.id]\"</span>  <span class=\"attr\">class</span>=<span class=\"string\">\"col-1-4\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>this.params = this.route.snapshot.paramMap.get('id');<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>console.log(this.params);</div></pre></td></tr></table></figure></p>\n<p> 所以上面的代码改成这样更好：</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.params = <span class=\"keyword\">this</span>.route.snapshot.paramMap.get(<span class=\"string\">'id'</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.params);</div><div class=\"line\"><span class=\"keyword\">this</span>.heroService.getHero(<span class=\"keyword\">this</span>.params)</div><div class=\"line\">  .then(hero =&gt; <span class=\"keyword\">this</span>.hero = hero);</div></pre></td></tr></table></figure>\n<p>两种方法：params 和snapshot到底什么时候该用哪种呢？</p>\n<ol>\n<li>需要直接访问参数，主要获取初始值，不用订阅的情况下用snapshot；</li>\n<li>需要连续导航多次的用params;</li>\n</ol>\n<h2 id=\"总结-路由主要是用到了这些方面啦：\"><a href=\"#总结-路由主要是用到了这些方面啦：\" class=\"headerlink\" title=\"总结 ,路由主要是用到了这些方面啦：\"></a>总结 ,路由主要是用到了这些方面啦：</h2><p> <img src=\"/images/router-7.png\" alt=\"cmd-markdown-logo\"></p>\n<h2 id=\"给路由添加一些新特性：\"><a href=\"#给路由添加一些新特性：\" class=\"headerlink\" title=\"给路由添加一些新特性：\"></a>给路由添加一些新特性：</h2><h3 id=\"添加动画\"><a href=\"#添加动画\" class=\"headerlink\" title=\"添加动画\"></a>添加动画</h3><p>[1] 在app.module.ts中引入启用Angular动画必备的, 记得在imports中导入：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserAnimationsModule &#125; from <span class=\"string\">'@angular/platform-browser/animations'</span>;</div></pre></td></tr></table></figure></p>\n<p>[2] 在app.component.ts同级下创建一个animation.ts文件，用来存放我们的动画效果；<br> <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">import</span> &#123; animate, AnimationEntryMetadata, state, style, transition, trigger &#125; from <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> slideInDownAnimation: AnimationEntryMetadata =</div><div class=\"line\">  trigger(<span class=\"string\">'routeAnimation'</span>, [</div><div class=\"line\">    state(<span class=\"string\">'*'</span>,</div><div class=\"line\">      style(&#123;</div><div class=\"line\">        opacity: <span class=\"number\">1</span>,</div><div class=\"line\">        transform: <span class=\"string\">'translateX(0)'</span></div><div class=\"line\">      &#125;)</div><div class=\"line\">    ),</div><div class=\"line\">    transition(<span class=\"string\">':enter'</span>, [</div><div class=\"line\">      style(&#123;</div><div class=\"line\">        opacity: <span class=\"number\">0</span>,</div><div class=\"line\">        transform: <span class=\"string\">'translateX(-100%)'</span></div><div class=\"line\">      &#125;),</div><div class=\"line\">      animate(<span class=\"string\">'0.2s ease-in'</span>)</div><div class=\"line\">    ]),</div><div class=\"line\">    transition(<span class=\"string\">':leave'</span>, [</div><div class=\"line\">      animate(<span class=\"string\">'0.5s ease-out'</span>, style(&#123;</div><div class=\"line\">        opacity: <span class=\"number\">0</span>,</div><div class=\"line\">        transform: <span class=\"string\">'translateY(100%)'</span></div><div class=\"line\">      &#125;))</div><div class=\"line\">    ])</div><div class=\"line\">  ]);</div></pre></td></tr></table></figure></p>\n<p> 假定我有以上代码，视图进场和出场；</p>\n<ol>\n<li>构建动画需要的库；</li>\n<li>导出了一个名叫slideInDownAnimation的常量，并把它设置为一个名，用于外部引入此ts文件；</li>\n<li>叫routeAnimation的动画触发器。带动画的组件将会引用这个名字。用在外部html页面引用</li>\n<li>指定了一个通配符状态 —— *，它匹配该路由组件存在时的任何动画状态。</li>\n<li>定义两个过渡效果，其中一个（:enter）在组件进入应用视图时让它从屏幕左侧缓动进入（ease-in），另一个（:leave）在组件离开应用视图时让它向下飞出。</li>\n</ol>\n<p>[3] 如何使用动画；</p>\n<ol>\n<li>在需要的组件中引入变量名为：slideInDownAnimation的文件animation.ts；</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;slideInDownAnimation&#125; from <span class=\"string\">'../animation'</span>;</div></pre></td></tr></table></figure>\n<p>[4]组件中配置<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">templateUrl: <span class=\"string\">'hero-detail.component.html'</span>,</div><div class=\"line\">animations: [slideInDownAnimation]</div></pre></td></tr></table></figure></p>\n<p>[5]html模板中这样引入：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div *ngIf=<span class=\"string\">\"hero\"</span> [<span class=\"meta\">@routeAnimation</span>]=<span class=\"string\">\"'active'\"</span>&gt;</div></pre></td></tr></table></figure></p>\n<p> @routeAnimation 动画触发器名<br><img src=\"/images/router-8.png\" alt=\"cmd-markdown-logo\"><br> 点击之后会自动加载动画的；</p>\n<h3 id=\"多重路由出口\"><a href=\"#多重路由出口\" class=\"headerlink\" title=\"多重路由出口\"></a>多重路由出口</h3><p><strong>一般情况下：我们使用一个路由出口就行啦，什么情况下会使用第二路由呢？</strong></p>\n<p>1.创建一个新组件ComposemessageComponent<br>2.路由配置：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    path:<span class=\"string\">'compose'</span>,</div><div class=\"line\">    component:ComposemessageComponent,</div><div class=\"line\">    outlet:<span class=\"string\">'popup'</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>3.html页面这样配置：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;nav&gt;</div><div class=\"line\">   &lt;a routerLink=\"dashboard\" routerLinkActive=\"active\"  [routerLinkActiveOptions]=\"&#123;exact: true&#125;\"&gt;Dashboard&lt;/a&gt;</div><div class=\"line\">   &lt;a (click)=\"go()\" &gt;Heroes&lt;/a&gt;</div><div class=\"line\">   &lt;a routerLink=\"test\"  routerLinkActive=\"active\"  [routerLinkActiveOptions]=\"&#123;exact: true&#125;\"&gt;Test&lt;/a&gt;</div><div class=\"line\">    &lt;a routerLink=\"loadtest\"  routerLinkActive=\"active\"&gt;loadTest&lt;/a&gt; </div><div class=\"line\">    &lt;a [routerLink]=\"[&#123; outlets: &#123; popup: ['compose'] &#125; &#125;]\"&gt;Contact&lt;/a&gt;</div><div class=\"line\"> &lt;/nav&gt;</div><div class=\"line\">&lt;router-outlet&gt;&lt;/router-outlet&gt;</div><div class=\"line\">&lt;router-outlet name=\"popup\"&gt;&lt;/router-outlet&gt;</div></pre></td></tr></table></figure></p>\n<p>这是我的页面所有的路由配置；<br><img src=\"/images/router-9.png\" alt=\"cmd-markdown-logo\"><br>点击Contact 不会替换其他的组件信息，注意看<code>Url:<a href=\"http://localhost:4200/dashboard(popup:compose\" target=\"_blank\" rel=\"external\">http://localhost:4200/dashboard(popup:compose</a>)</code><br>点击Contact url地址没有变成<code><a href=\"http://localhost:4200/contact\" target=\"_blank\" rel=\"external\">http://localhost:4200/contact</a></code>而是采用圆括号加载</p>\n<ul>\n<li>圆括号包裹的部分是第二路由。</li>\n<li>第二路由包括一个出口名称（popup）、一个冒号分隔符和第二路由的路径（compose）<br>而是显示在下面，点击test也是一样：<br><img src=\"/images/router-10.png\" alt=\"cmd-markdown-logo\"></li>\n</ul>\n<p>Contact路由加载的组件不会被清除，一直显示在下面，状态一直被激活；<br>这里我们就能知道第二路由的用处：即使在应用中的不同页面之间切换，这个组件也应该始终保持打开状态，多重出口可以在同一时间根据不同的路由来显示不同的内容；<br>但是什么时候清除我们的第二路由呢？如果我页面不需要呢？<br>注意：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"go()\"</span> &gt;</span>Heroes<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">go() &#123;</div><div class=\"line\">   this.router.navigateByUrl('heroes');</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>当点击Heroes时，Contact路由加载的内容就不会被显示：<br><img src=\"/images/router-1.png\" alt=\"cmd-markdown-logo\"><br>原因是这样的：<br>它使用Router.navigateNyUrl()方法进行强制导航,所以路由清除啦；<br>还可以这样清除：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.router.navigate([&#123; outlets: &#123; popup: <span class=\"literal\">null</span> &#125;&#125;]);</div><div class=\"line\">outlets属性的值是另一个对象，该对象用一些出口名称作为属性名。 唯一的命名出口是<span class=\"string\">'popup'</span>。但这里，<span class=\"string\">'popup'</span>的值是<span class=\"literal\">null</span>。<span class=\"literal\">null</span>不是一个路由，</div><div class=\"line\">但却是一个合法的值。 把popup这个RouterOutlet设置为<span class=\"literal\">null</span>会清除该出口，并且从当前URL中移除第二路由popup</div></pre></td></tr></table></figure>\n<h3 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h3><p>按照上面所说：任何用户都能在任何时候导航到任何地方，这样就有问题，可能此用户并没有权限切换到此路由，<br>可能用户未登陆不能切换，或者做一些友好提示之后再切换；<br>所以路由守卫就来了：<br>守卫返回一个值，以控制路由器的行为：</p>\n<ol>\n<li>如果它返回true，导航过程会继续</li>\n<li>如果它返回false，导航过程会终止，且用户会留在原地。<br>也就是你导航的路由是可以取消的，路由守卫还有一个好处就是回退功能时，可以防止用户无限回退，走出app；<br>路由守卫怎么做：<br>用CanActivate来处理导航到某路由的情况。<br>用CanActivateChild来处理导航到某子路由的情况。<br>用CanDeactivate来处理从当前路由离开的情况.<br>用Resolve在路由激活之前获取路由数据。<br>用CanLoad来处理异步导航到某特性模块的情况。</li>\n</ol>\n<hr>\n<p>返回的值是一个Observable<boolean>或Promise<boolean>，路由器会等待这个可观察对象被解析为true或false。<br>在分层路由的每个级别上，我们都可以设置多个守卫。 路由器会先按照从最深的子路由由下往上检查的顺序来检查CanDeactivate()和CanActivateChild()守卫。 然后它会按照从上到下的顺序检查CanActivate()守卫。 如果特性模块是异步加载的，在加载它之前还会检查CanLoad()守卫。 如果任何一个守卫返回false，其它尚未完成的守卫会被取消，这样整个导航就被取消了。<br>看看路由守卫怎么实现：<br>1.new 一个新项目activeComponent;<br>2.编写守卫服务：</boolean></boolean></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; Injectable &#125; from <span class=\"string\">'@angular/core'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; CanActivate &#125; from <span class=\"string\">'@angular/router'</span>;</div><div class=\"line\"><span class=\"meta\">@Injectable</span>()</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> LoadTestService <span class=\"keyword\">implements</span> CanActivate&#123;</div><div class=\"line\">   canActivate() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'AuthGuard#canActivate called'</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 3.路由中这样导入我们的守卫：</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; ActiveComponent &#125; from <span class=\"string\">'./active/active.component'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;LoadTestService&#125; from <span class=\"string\">'./loadtest.service'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> route = [</div><div class=\"line\">    &#123;</div><div class=\"line\">        path:<span class=\"string\">''</span>,</div><div class=\"line\">        component: LoadtestComponent,</div><div class=\"line\">        canActivate:[LoadTestService],</div><div class=\"line\">        children:[</div><div class=\"line\">            &#123;</div><div class=\"line\">                path:<span class=\"string\">'a'</span>,</div><div class=\"line\">                component: ActiveComponent</div><div class=\"line\">            &#125;   </div><div class=\"line\">        ]</div><div class=\"line\">    &#125;,</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>这样我们的ActiveComponent就是受保护的； 当然这只是模拟；还有更多用法，以后来列举；</p>\n","comments":true,"categories":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/categories/Angular-2/"}],"tags":[{"name":"Angular 2+","slug":"Angular-2","permalink":"http://www.sulishibaobei.com/tags/Angular-2/"},{"name":"router","slug":"router","permalink":"http://www.sulishibaobei.com/tags/router/"},{"name":"懒加载","slug":"懒加载","permalink":"http://www.sulishibaobei.com/tags/懒加载/"}]}]